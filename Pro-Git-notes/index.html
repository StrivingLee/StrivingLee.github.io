<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-avatar-medium.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-avatar-small.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"strivinglee.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Written on 08-09-2022 很重要的先导内容，但是 missing 了">
<meta property="og:type" content="article">
<meta property="og:title" content="Pro Git 读书笔记">
<meta property="og:url" content="https://strivinglee.github.io/Pro-Git-notes/index.html">
<meta property="og:site_name" content="StrivingLee&#39;s Blog">
<meta property="og:description" content="Written on 08-09-2022 很重要的先导内容，但是 missing 了">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.progit.cn/images/deltas.png">
<meta property="og:image" content="https://www.progit.cn/images/snapshots.png">
<meta property="og:image" content="https://www.progit.cn/images/areas.png">
<meta property="og:image" content="https://www.progit.cn/images/lifecycle.png">
<meta property="og:image" content="https://www.progit.cn/images/commit-and-tree.png">
<meta property="og:image" content="https://www.progit.cn/images/commits-and-parents.png">
<meta property="og:image" content="https://www.progit.cn/images/branch-and-history.png">
<meta property="og:image" content="https://www.progit.cn/images/two-branches.png">
<meta property="og:image" content="https://www.progit.cn/images/head-to-master.png">
<meta property="og:image" content="https://www.progit.cn/images/head-to-testing.png">
<meta property="og:image" content="https://www.progit.cn/images/advance-testing.png">
<meta property="og:image" content="https://www.progit.cn/images/checkout-master.png">
<meta property="og:image" content="https://www.progit.cn/images/advance-master.png">
<meta property="og:image" content="https://www.progit.cn/images/basic-branching-1.png">
<meta property="og:image" content="https://www.progit.cn/images/basic-branching-2.png">
<meta property="og:image" content="https://www.progit.cn/images/basic-branching-3.png">
<meta property="og:image" content="https://www.progit.cn/images/basic-branching-4.png">
<meta property="og:image" content="https://www.progit.cn/images/basic-branching-5.png">
<meta property="og:image" content="https://www.progit.cn/images/basic-branching-6.png">
<meta property="og:image" content="https://www.progit.cn/images/basic-merging-1.png">
<meta property="og:image" content="https://www.progit.cn/images/basic-merging-2.png">
<meta property="og:image" content="https://www.progit.cn/images/lr-branches-1.png">
<meta property="og:image" content="https://www.progit.cn/images/lr-branches-2.png">
<meta property="og:image" content="https://www.progit.cn/images/topic-branches-1.png">
<meta property="og:image" content="https://www.progit.cn/images/topic-branches-2.png">
<meta property="og:image" content="https://www.progit.cn/images/remote-branches-1.png">
<meta property="og:image" content="https://www.progit.cn/images/remote-branches-2.png">
<meta property="og:image" content="https://www.progit.cn/images/remote-branches-3.png">
<meta property="og:image" content="https://www.progit.cn/images/remote-branches-4.png">
<meta property="og:image" content="https://www.progit.cn/images/remote-branches-5.png">
<meta property="og:image" content="https://www.progit.cn/images/basic-rebase-1.png">
<meta property="og:image" content="https://www.progit.cn/images/basic-rebase-2.png">
<meta property="og:image" content="https://www.progit.cn/images/basic-rebase-3.png">
<meta property="og:image" content="https://www.progit.cn/images/basic-rebase-4.png">
<meta property="og:image" content="https://www.progit.cn/images/interesting-rebase-1.png">
<meta property="og:image" content="https://www.progit.cn/images/interesting-rebase-2.png">
<meta property="og:image" content="https://www.progit.cn/images/interesting-rebase-3.png">
<meta property="og:image" content="https://www.progit.cn/images/interesting-rebase-4.png">
<meta property="og:image" content="https://www.progit.cn/images/interesting-rebase-5.png">
<meta property="og:image" content="https://www.progit.cn/images/perils-of-rebasing-1.png">
<meta property="og:image" content="https://www.progit.cn/images/perils-of-rebasing-2.png">
<meta property="og:image" content="https://www.progit.cn/images/perils-of-rebasing-3.png">
<meta property="og:image" content="https://www.progit.cn/images/perils-of-rebasing-4.png">
<meta property="og:image" content="https://www.progit.cn/images/perils-of-rebasing-5.png">
<meta property="article:published_time" content="2022-09-09T08:39:27.803Z">
<meta property="article:modified_time" content="2023-06-30T13:55:27.708Z">
<meta property="article:author" content="StrivingLee">
<meta property="article:tag" content="读书笔记">
<meta property="article:tag" content="OO">
<meta property="article:tag" content="Git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.progit.cn/images/deltas.png">

<link rel="canonical" href="https://strivinglee.github.io/Pro-Git-notes/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Pro Git 读书笔记 | StrivingLee's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">StrivingLee's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">揉合生命千样好</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://strivinglee.github.io/Pro-Git-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="StrivingLee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StrivingLee's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Pro-Git-notes" class="post-title-link post-title-link-external" itemprop="url">Pro Git 读书笔记<i class="fa fa-external-link-alt"></i></a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-09 16:39:27" itemprop="dateCreated datePublished" datetime="2022-09-09T16:39:27+08:00">2022-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-30 21:55:27" itemprop="dateModified" datetime="2023-06-30T21:55:27+08:00">2023-06-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OO/" itemprop="url" rel="index"><span itemprop="name">OO</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OO/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OO/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/S3/" itemprop="url" rel="index"><span itemprop="name">S3</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>59k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2:28</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p><em>Written on 08-09-2022</em></p>
<p>很重要的先导内容，但是 missing 了</p>
</blockquote>
<span id="more"></span>
<p><del>你一定会在我这里看到 Table of Contents</del></p>
<p>[TOC]</p>
<h2 id="起步">起步</h2>
<h3 id="不重要的part">不重要的part</h3>
<h3 id="git-基础但我认为叫git原理更好些">Git
基础（但我认为叫Git原理更好些）</h3>
<p>理解原理有助于使用</p>
<h4 id="直接记录快照">直接记录快照</h4>
<p>其它大部分系统以文件变更列表的方式存储信息。
这类系统将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</p>
<figure>
<img src="https://www.progit.cn/images/deltas.png"
alt="存储每个文件与初始版本的差异。" />
<figcaption
aria-hidden="true">存储每个文件与初始版本的差异。</figcaption>
</figure>
<p>Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在
Git
中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。
Git 对待数据更像是一个 <strong>快照流</strong>。</p>
<figure>
<img src="https://www.progit.cn/images/snapshots.png"
alt="Git 存储项目随时间改变的快照。" />
<figcaption aria-hidden="true">Git
存储项目随时间改变的快照。</figcaption>
</figure>
<h4 id="本地执行操作">本地执行操作</h4>
<p>快而方便，可以进行离线操作</p>
<h4 id="保证完整性">保证完整性</h4>
<p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。
这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在
Git 底层，是构成 Git 哲学不可或缺的部分。
若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p>
<p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40
个十六进制字符（0-9 和 a-f）组成字符串，基于 Git
中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24b9da6552252987aa493b52f8696cd6d3b00373</span><br></pre></td></tr></table></figure>
<p>Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git
数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<h4 id="只添加数据">只添加数据</h4>
<p>你执行的 Git 操作，几乎只往 Git 数据库中增加数据， 很难让 Git
执行任何不可逆操作，或者让它以任何方式清除数据。 一旦你提交快照到 Git
中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。我们可以尽情做各种尝试，而不怕把事情弄糟。</p>
<h4 id="三种状态">三种状态</h4>
<p>好，请注意。 如果你希望后面的学习更顺利，记住下面这些关于 Git
的概念。 Git
有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。
已提交表示数据已经安全的保存在本地数据库中。
已修改表示修改了文件，但还没保存到数据库中。
已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p>
<p>由此引入 Git 项目的三个工作区域的概念：Git
仓库、工作目录以及暂存区域。</p>
<figure>
<img src="https://www.progit.cn/images/areas.png"
alt="工作目录、暂存区域以及 Git 仓库。" />
<figcaption aria-hidden="true">工作目录、暂存区域以及 Git
仓库。</figcaption>
</figure>
<p>Git 仓库是 Git 用来保存项目的元数据和对象数据库的地方。 <strong>这是
Git
中最重要的部分</strong>，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p>
<p>工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git
仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p>
<p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git
仓库目录中。 有时候也被称作`‘索引’'，不过一般说法还是叫暂存区域。</p>
<p>基本的 Git 工作流程如下：</p>
<ol type="1">
<li>在工作目录中修改文件。</li>
<li>暂存文件，将文件的快照放入暂存区域。</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li>
</ol>
<p>如果 Git 目录中保存着特定版本的文件，就属于已提交状态。
如果作了修改并已放入暂存区域，就属于已暂存状态。
如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 在<a
target="_blank" rel="noopener" href="https://www.progit.cn/#_git_basics_chapter">Git
基础</a>一章，你会进一步了解这些状态的细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。</p>
<h4 id="the-three-states">The Three States</h4>
<p>Pay attention now — here is the main thing to remember about Git if
you want the rest of your learning process to go smoothly. Git has three
main states that your files can reside in: <em>modified</em>,
<em>staged</em>, and <em>committed</em>:</p>
<ul>
<li>Modified means that you have changed the file but have not committed
it to your database yet.</li>
<li>Staged means that you have marked a modified file in its current
version to go into your next commit snapshot.</li>
<li>Committed means that the data is safely stored in your local
database.</li>
</ul>
<p>This leads us to the three main sections of a Git project:
<strong>the working tree, the staging area, and the Git
directory</strong>.The working tree is a single checkout of one version
of the project. These files are pulled out of the compressed database in
the Git directory and placed on disk for you to use or modify.</p>
<p>The staging area is a file, generally contained in your Git
directory, that stores information about what will go into your next
commit. Its technical name in Git parlance is the “index”, but the
phrase “staging area” works just as well.</p>
<p>The Git directory is where Git stores the metadata and object
database for your project. This is the most important part of Git, and
it is what is copied when you <em>clone</em> a repository from another
computer.</p>
<p>The basic Git workflow goes something like this:</p>
<ol type="1">
<li>You modify files in your working tree.</li>
<li>You selectively stage just those changes you want to be part of your
next commit, which adds <em>only</em> those changes to the staging
area.</li>
<li>You do a commit, which takes the files as they are in the staging
area and stores that snapshot permanently to your Git directory.</li>
</ol>
<p>If a particular version of a file is in the Git directory, it’s
considered <em>committed</em>. If it has been modified and was added to
the staging area, it is <em>staged</em>. And if it was changed since it
was checked out but has not been staged, it is <em>modified</em>. In <a
target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/ch00/ch02-git-basics-chapter">Git
Basics</a>, you’ll learn more about these states and how you can either
take advantage of them or skip the staged part entirely.</p>
<blockquote>
<p>这段文字太重要了，<del>中译本又译得太好让人不忍卒读</del>，所以我把中英版本都留在这里了。总结下来就是几个知识点：</p>
<p>① 有三个地方存放文件：working tree、the staging area、Git
directory（按照“从弱到强”的顺序）</p>
<ul>
<li>对三个地方的介绍</li>
</ul>
<p>②
file有三个状态：modified、staged、commited（按照“从弱到强”的顺序）</p>
<ul>
<li>对三种状态的介绍</li>
</ul>
</blockquote>
<h3 id="命令行">命令行</h3>
<p>见其他文章</p>
<h3 id="初次运行-git-前的配置">初次运行 Git 前的配置</h3>
<blockquote>
<p>笔者注：我感觉这才是Git Missing
Semester，这解答了我很多疑问（比如config --global
user）并且指引了解决问题的方法</p>
</blockquote>
<p>既然已经在系统上安装了 Git，你会想要做几件事来定制你的 Git 环境。
每台计算机上只需要配置一次，程序升级时会保留配置信息。
你可以在任何时候再次通过运行命令来修改它们。</p>
<p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git
外观和行为的配置变量。 这些变量存储在三个不同的位置：</p>
<ol type="1">
<li><code>/etc/gitconfig</code> 文件:
包含系统上每一个用户及他们仓库的通用配置。 如果使用带有
<code>--system</code> 选项的 <code>git config</code>
时，它会从此文件读写配置变量。</li>
<li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code>
文件：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git
读写此文件。</li>
<li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（就是
<code>.git/config</code>）：针对该仓库。</li>
</ol>
<p>每一个级别覆盖上一级别的配置，所以 <code>.git/config</code>
的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p>
<p>在 Windows 系统中，Git 会查找 <code>$HOME</code> 目录下（一般情况下是
<code>C:\Users\$USER</code>）的 <code>.gitconfig</code> 文件。 Git
同样也会寻找 <code>/etc/gitconfig</code> 文件，但只限于 MSys
的根目录下，即安装 Git 时所选的目标位置。</p>
<h4 id="用户信息">用户信息</h4>
<p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。
这样做很重要，因为每一个 Git
的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;John Doe&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email johndoe@example.com</span></span><br></pre></td></tr></table></figure>
<p>再次强调，如果使用了 <code>--global</code>
选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git
都会使用那些信息。
当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有
<code>--global</code> 选项的命令来配置。</p>
<p>很多 GUI 工具都会在第一次运行时帮助你配置这些信息。</p>
<h4 id="文本编辑器">文本编辑器</h4>
<p>既然用户信息已经设置完毕，你可以配置默认文本编辑器了，当 Git
需要你输入信息时会调用它。 如果未配置，Git
会使用操作系统默认的文本编辑器，通常是 Vim。
如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core.editor emacs</span></span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>WARNING</th>
<th>Vim 和 Emacs 是像 Linux 与 Mac 等基于 Unix
的系统上开发者经常使用的流行的文本编辑器。
如果你对这些编辑器都不是很了解或者你使用的是 Windows
系统，那么可能需要搜索如何在 Git 中配置你最常用的编辑器。
如果你不设置编辑器并且不知道 Vim 或 Emacs
是什么，当它们运行起来后你可能会被弄糊涂、不知所措。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="检查配置信息">检查配置信息</h4>
<p>如果想要检查你的配置，可以使用 <code>git config --list</code>
命令来列出所有 Git 当时能找到的配置。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --list</span></span><br><span class="line">user.name=John Doe</span><br><span class="line">user.email=johndoe@example.com</span><br><span class="line">color.status=auto</span><br><span class="line">color.branch=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">color.diff=auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>你可能会看到重复的变量名，因为 Git
会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与
<code>~/.gitconfig</code>）。 这种情况下，Git
会使用它找到的每一个变量的最后一个配置。</p>
<p>你可以通过输入 <code>git config &lt;key&gt;</code>： 来检查 Git
的某一项配置</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.name</span></span><br><span class="line">John Doe</span><br></pre></td></tr></table></figure>
<h3 id="获取帮助">获取帮助</h3>
<p>若你使用 Git 时需要获取帮助，有三种方法可以找到 Git
命令的使用手册：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">help</span> &lt;verb&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git &lt;verb&gt; --<span class="built_in">help</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man git-&lt;verb&gt;</span></span><br></pre></td></tr></table></figure>
<p>例如，要想获得 config 命令的手册，执行</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">help</span> config</span></span><br></pre></td></tr></table></figure>
<p>这些命令很棒，因为你随时随地可以使用而无需联网。
如果你觉得手册或者本书的内容还不够用，你可以尝试在 Freenode IRC 服务器（
irc.freenode.net ）的 <code>#git</code> 或 <code>#github</code>
频道寻求帮助。 这些频道经常有上百人在线，他们都精通 Git
并且乐于助人。</p>
<h2 id="git-基础">Git 基础</h2>
<p><strong>本章是最重要的一章，涵盖使用 Git
完成各种工作中将要使用的各种基本命令。</strong>
在学习完本章之后，你应该能够配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit)更改。
本章也将向你演示如何配置 Git
来忽略指定的文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。</p>
<h3 id="获取-git-仓库">获取 Git 仓库</h3>
<p>有两种取得 Git 项目仓库的方法。
第一种是在现有项目或目录下导入所有文件到 Git 中；
第二种是从一个服务器克隆一个现有的 Git 仓库。</p>
<h4 id="在现有目录中初始化仓库">在现有目录中初始化仓库</h4>
<p>如果你打算使用 Git
来对现有的项目进行管理，你只需要进入该项目目录并输入：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br></pre></td></tr></table></figure>
<p>该命令将创建一个名为 <code>.git</code>
的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是
Git 仓库的骨干。
但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。
(参见 <a target="_blank" rel="noopener" href="https://www.progit.cn/#_git_internals">Git 内部原理</a>
来了解更多关于到底 <code>.git</code> 文件夹中包含了哪些文件的信息。)</p>
<p>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git
仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。 你可通过
<code>git add</code> 命令来实现对指定文件的跟踪，然后执行
<code>git commit</code> 提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add *.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add LICENSE</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;initial project version&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>稍后我们再逐一解释每一条指令的意思。
现在，你已经得到了一个实际维护（或者说是跟踪）着若干个文件的 Git
仓库。</p>
<h4 id="克隆现有的仓库">克隆现有的仓库</h4>
<p>如果你想获得一份已经存在了的 Git
仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，就要用到
<code>git clone</code> 命令。 Git 克隆的是该 Git
仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要的文件。
当你执行 <code>git clone</code> 命令的时候，默认配置下远程 Git
仓库中的每一个文件的每一个版本都将被拉取下来。
事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库（虽然可能会丢失某些服务器端的挂钩设置，但是所有版本的数据仍在，详见
<a target="_blank" rel="noopener" href="https://www.progit.cn/#_git_on_the_server">在服务器上搭建
Git</a> ）。</p>
<p>克隆仓库的命令格式是 <code>git clone [url]</code> 。 比如，要克隆 Git
的可链接库 libgit2，可以用下面的命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2</span></span><br></pre></td></tr></table></figure>
<p>这会在当前目录下创建一个名为 “libgit2”
的目录，并在这个目录下初始化一个 <code>.git</code>
文件夹，从远程仓库拉取下所有数据放入 <code>.git</code>
文件夹，然后从中读取最新版本的文件的拷贝。</p>
<p>自定义本地仓库的名字的命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit</span></span><br></pre></td></tr></table></figure>
<p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为
<code>mylibgit</code>。</p>
<p>Git 支持多种数据传输协议。 详见<a
target="_blank" rel="noopener" href="https://www.progit.cn/#_git_on_the_server">在服务器上搭建
Git</a></p>
<h3 id="记录更新到仓库">记录更新到仓库</h3>
<p>现在我们手上有了一个真实项目的 Git
仓库，并从这个仓库中取出了所有文件的工作拷贝。
接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p>
<p>请记住，<strong>你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。</strong>
已跟踪的文件是指那些<strong>被纳入了版本控制</strong>的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能是未修改，已修改或已放入暂存区。
工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。
<strong>初次克隆</strong>某个仓库的时候，工作目录中的所有文件都属于<strong>已跟踪文件</strong>，并处于未修改状态。</p>
<p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git
将它们标记为已修改文件。
我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用
Git 时文件的生命周期如下：</p>
<figure>
<img src="https://www.progit.cn/images/lifecycle.png"
alt="Git 下文件生命周期图。" />
<figcaption aria-hidden="true">Git 下文件生命周期图。</figcaption>
</figure>
<p>Figure 8. 文件的状态变化周期</p>
<blockquote>
<p>虽然图是down的（划去），但是这个太精辟了，一张图就解释了所有的内容！！！吹爆！！！</p>
</blockquote>
<h4 id="检查当前文件状态">检查当前文件状态</h4>
<p>查看哪些文件处于什么状态的主要手段是 <code>git status</code> 命令。
如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p>这说明你现在的工作目录<strong>相当干净</strong>。换句话说，所有已跟踪文件在上次提交后都未被更改过。
此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则
Git 会在这里列出来。
最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。
现在，分支名是 “master”,这是默认的分支名。 我们在 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_git_branching">Git 分支</a>
会详细讨论分支和引用。</p>
<p>现在，让我们在项目下创建一个新的 README 文件。
如果之前并不存在这个文件，使用 <code>git status</code>
命令，你将看到一个新的未跟踪文件：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;My Project&#x27;</span> &gt; README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">    README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>
<p>在状态报告中可以看到新建的 README 文件出现在
<code>Untracked files</code> 下面。 未跟踪的文件意味着 Git
在之前的快照（提交）中没有这些文件；<strong>Git
不会自动将之纳入跟踪范围</strong>，除非你明明白白地告诉它“我需要跟踪该文件”，
<strong>这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来</strong>。
不过现在的例子中，我们确实想要跟踪管理 README 这个文件。</p>
<h4 id="跟踪新文件">跟踪新文件</h4>
<p>使用命令 <code>git add</code> 开始跟踪一个文件。 所以，要跟踪 README
文件，运行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br></pre></td></tr></table></figure>
<p>此时再运行 <code>git status</code> 命令，会看到 README
文件已被跟踪，并处于暂存状态：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br></pre></td></tr></table></figure>
<p>只要在 <code>Changes to be committed</code>
这行下面的，就说明是已暂存状态。
如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。
你可能会想起之前我们使用 <code>git init</code> 后就运行了
<code>git add (files)</code> 命令，开始跟踪当前目录下的文件。
<code>git add</code>
命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的<strong>所有文件</strong>。</p>
<h4 id="暂存已修改文件">暂存已修改文件</h4>
<p>现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为
<code>CONTRIBUTING.md</code> 的已被跟踪的文件，然后运行
<code>git status</code> 命令，会看到下面内容：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>文件 <code>CONTRIBUTING.md</code> 出现在
<code>Changes not staged for commit</code>
这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。
要暂存这次更新，需要运行 <code>git add</code> 命令。
这是个多功能命令：<strong>可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等</strong>。
<strong>将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适</strong>。
现在让我们运行 <code>git add</code>
将"CONTRIBUTING.md"放到暂存区，然后再看看 <code>git status</code>
的输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。
假设此时，你想要在 <code>CONTRIBUTING.md</code> 里再加条注释，
重新编辑存盘后，准备好提交。 不过且慢，再运行 <code>git status</code>
看看：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>怎么回事？ 现在 <code>CONTRIBUTING.md</code>
文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git
只不过暂存了你运行 <code>git add</code> 命令时的版本，
如果你现在提交，<code>CONTRIBUTING.md</code> 的版本是你最后一次运行
<code>git add</code> 命令时的那个版本，而不是你运行
<code>git commit</code> 时，在工作目录中的当前版本。 所以，运行了
<code>git add</code> 之后又作了修订的文件，需要重新运行
<code>git add</code> 把最新版本重新暂存起来：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<h4 id="状态简览">状态简览</h4>
<p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。
如果你使用 <code>git status -s</code> 命令或
<code>git status --short</code> 命令，你将得到一种更为紧凑的格式输出。
运行 <code>git status -s</code> ，状态报告输出如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -s</span></span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure>
<p>新添加的未跟踪文件前面有 <code>??</code>
标记，新添加到暂存区中的文件前面有 <code>A</code>
标记，修改过的文件前面有 <code>M</code> 标记。 你可能注意到了
<code>M</code> 有两个可以出现的位置（即第三行的 <code>MM</code>
，这是两个位置，笔者注），出现在右边的 <code>M</code>
表示该文件被修改了但是还没放入暂存区，出现在靠左边的 <code>M</code>
表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示：
<code>README</code>
文件在工作区被修改了但是还没有将修改后的文件放入暂存区,<code>lib/simplegit.rb</code>
文件被修改了并将修改后的文件放入了暂存区。 而 <code>Rakefile</code>
在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p>
<h4 id="忽略文件">忽略文件</h4>
<p>一般我们总会有些文件无需纳入 Git
的管理，也不希望它们总出现在未跟踪文件列表。
通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。
在这种情况下，我们可以创建一个名为 <code>.gitignore</code>
的文件，列出要忽略的文件模式。 来看一个实际的例子：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> .gitignore</span></span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure>
<p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code>
结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉
Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如
Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者
pid 目录，以及自动生成的文档等等。 <strong>要养成一开始就设置好
.gitignore 文件的习惯，以免将来误提交这类无用的文件。</strong></p>
<p>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell
所使用的简化了的<strong>正则表达式</strong>。
星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code>
匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个
b，要么匹配一个
c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如
<code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。
使用两个星号（<code>*</code>)
表示匹配任意中间目录，比如<code>a/**/z</code> 可以匹配 <code>a/z</code>,
<code>a/b/z</code> 或 <code>a/b/c/z</code>等。</p>
<blockquote>
<p>注：</p>
<p><strong>Shell</strong>：Shell 是一个用 C
语言编写的应用程序，它是用户使用 Linux
的桥梁。提供了一个访问操作系统内核服务的界面。Shell
既是一种命令语言，又是一种程序设计语言。比如Git Bash（？）</p>
<p><strong>正则表达式</strong>：</p>
</blockquote>
<p>我们再看一个 .gitignore 文件的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># no .a files</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># but do track lib.a, even though you&#x27;re ignoring .a files above</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"># only ignore the TODO file in the current directory, not subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># ignore all files in the build/ directory</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># ignore doc/notes.txt, but not doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># ignore all .pdf files in the doc/ directory</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>TIP</th>
<th>GitHub 有一个十分详细的针对数十种项目及语言的
<code>.gitignore</code> 文件列表，你可以在
https://github.com/github/gitignore 找到它.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="查看已暂存和未暂存的修改">查看已暂存和未暂存的修改</h4>
<p>如果 <code>git status</code>
命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用
<code>git diff</code> 命令。 稍后我们会详细介绍
<code>git diff</code>，你可能通常会用它来回答这两个问题：当前做的哪些更新还没有暂存？
有哪些更新已经暂存起来准备好了下次提交？ 尽管 <code>git status</code>
已经通过在相应栏下列出文件名的方式回答了这个问题，<code>git diff</code>
将通过文件补丁的格式显示<strong>具体哪些行</strong>发生了改变。</p>
<blockquote>
<p>笔者注：显示了具体内容</p>
</blockquote>
<p>假如再次修改 README 文件后暂存，然后编辑 <code>CONTRIBUTING.md</code>
文件后先不暂存， 运行 <code>status</code> 命令将会看到：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入
<code>git diff</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff</span></span><br><span class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</span><br><span class="line">index 8ebb991..643e24f 100644</span><br><span class="line">--- a/CONTRIBUTING.md</span><br><span class="line">+++ b/CONTRIBUTING.md</span><br><span class="line">@@ -65,7 +65,8 @@ branch directly, things can get messy.</span><br><span class="line"> Please include a nice description of your changes when you submit your PR;</span><br><span class="line"> if we have to read the whole diff to figure out why you&#x27;re contributing</span><br><span class="line"> in the first place, you&#x27;re less likely to get feedback and have your change</span><br><span class="line">-merged in.</span><br><span class="line">+merged in. Also, split your changes into comprehensive chunks if your patch is</span><br><span class="line">+longer than a dozen lines.</span><br><span class="line"></span><br><span class="line"> If you are starting to work on a particular area, feel free to submit a PR</span><br><span class="line"> that highlights your work in progress (and note in the PR title that it&#x27;s</span><br></pre></td></tr></table></figure>
<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，
也就是修改之后还没有暂存起来的变化内容。</p>
<p>若要查看已暂存的将要添加到下次提交里的内容，可以用
<code>git diff --staged</code> 命令。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged</span></span><br><span class="line">diff --git a/README b/README</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..03902a1</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/README</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+My Project</span><br></pre></td></tr></table></figure>
<p>请注意，git diff
本身只显示<strong>尚未暂存的改动</strong>，而不是自上次提交以来所做的所有改动。
所以有时候你一下子暂存了所有更新过的文件后，运行 <code>git diff</code>
后却什么也没有，就是这个原因。</p>
<p>像之前说的，暂存 <code>CONTRIBUTING.md</code> 后再编辑，运行
<code>git status</code> 会看到暂存前后的两个版本。
如果我们的环境（终端输出）看起来如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;# test line&#x27;</span> &gt;&gt; CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>现在运行 <code>git diff</code> 看暂存前后的变化：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff</span></span><br><span class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</span><br><span class="line">index 643e24f..87f08c8 100644</span><br><span class="line">--- a/CONTRIBUTING.md</span><br><span class="line">+++ b/CONTRIBUTING.md</span><br><span class="line">@@ -119,3 +119,4 @@ at the</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash"><span class="comment"># Starter Projects</span></span></span><br><span class="line"></span><br><span class="line"> See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).</span><br><span class="line">+# test line</span><br></pre></td></tr></table></figure>
<p>然后用 <code>git diff --staged</code> 查看已经暂存起来的变化：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged</span></span><br><span class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</span><br><span class="line">index 8ebb991..643e24f 100644</span><br><span class="line">--- a/CONTRIBUTING.md</span><br><span class="line">+++ b/CONTRIBUTING.md</span><br><span class="line">@@ -65,7 +65,8 @@ branch directly, things can get messy.</span><br><span class="line"> Please include a nice description of your changes when you submit your PR;</span><br><span class="line"> if we have to read the whole diff to figure out why you&#x27;re contributing</span><br><span class="line"> in the first place, you&#x27;re less likely to get feedback and have your change</span><br><span class="line">-merged in.</span><br><span class="line">+merged in. Also, split your changes into comprehensive chunks if your patch is</span><br><span class="line">+longer than a dozen lines.</span><br><span class="line"></span><br><span class="line"> If you are starting to work on a particular area, feel free to submit a PR</span><br><span class="line"> that highlights your work in progress (and note in the PR title that it&#x27;s</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>Git Diff 的插件版本在本书中，我们使用 <code>git diff</code>
来分析文件差异。
但是，如果你喜欢通过图形化的方式或其它格式输出方式的话，可以使用
<code>git difftool</code> 命令来用 Araxis ，emerge 或 vimdiff 等软件输出
diff 分析结果。 使用 <code>git difftool --tool-help</code>
命令来看你的系统支持哪些 Git Diff 插件。</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h4 id="提交更新">提交更新</h4>
<p>现在的暂存区域已经准备妥当可以提交了。
在此之前，请一定要确认还有什么修改过的或新建的文件还没有
<code>git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。
这些修改过的文件只保留在本地磁盘。 <strong>所以，每次准备提交前，先用
<code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令
<code>git commit</code>：</strong></p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br></pre></td></tr></table></figure>
<p>这种方式会启动文本编辑器以便输入本次提交的说明。 (默认会启用 shell
的环境变量 <code>$EDITOR</code> 所指定的软件，一般都是 vim 或
emacs。当然也可以按照 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_getting_started">起步</a> 介绍的方式，使用
<code>git config --global core.editor</code>
命令设定你喜欢的编辑软件。）</p>
<p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#	new file:   README</span><br><span class="line">#	modified:   CONTRIBUTING.md</span><br><span class="line">#</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">&quot;.git/COMMIT_EDITMSG&quot; 9L, 283C</span><br></pre></td></tr></table></figure>
<p>可以看到，默认的提交消息包含最后一次运行 <code>git status</code>
的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。
你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。
(如果想要更详细的对修改了哪些内容的提示，可以用 <code>-v</code>
选项，这会将你所做的改变的 diff
输出放到编辑器中从而使你知道本次提交具体做了哪些修改。）
退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。</p>
<p>另外，你也可以在 <code>commit</code> 命令后添加 <code>-m</code>
选项，将提交信息与命令放在同一行，如下所示：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;Story 182: Fix benchmarks for speed&quot;</span></span></span><br><span class="line">[master 463dc4f] Story 182: Fix benchmarks for speed</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure>
<p>好，现在你已经创建了第一个提交！
可以看到，提交后它会告诉你，当前是在哪个分支（<code>master</code>）提交的，本次提交的完整
SHA-1
校验和是什么（<code>463dc4f</code>），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p>
<p>请记住，提交时记录的是放在暂存区域的快照。
任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。
每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<h4 id="跳过使用暂存区域">跳过使用暂存区域</h4>
<p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。
Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给
<code>git commit</code> 加上 <code>-a</code> 选项，Git
就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过
<code>git add</code> 步骤：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;added new benchmarks&#x27;</span></span></span><br><span class="line">[master 83e38c7] added new benchmarks</span><br><span class="line"> 1 file changed, 5 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure>
<p>看到了吗？提交之前不再需要 <code>git add</code>
文件“CONTRIBUTING.md”了。</p>
<h4 id="移除文件">移除文件</h4>
<p>要从 Git
中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从<strong>暂存区域移除</strong>），然后提交。
可以用 <code>git rm</code>
命令完成此项工作，并<strong>连带从工作目录中删除指定的文件</strong>，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code>
时就会在 “Changes not staged for commit” 部分（也就是
<em>未暂存清单</em>）看到：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> PROJECTS.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    PROJECTS.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>然后再运行 <code>git rm</code> 记录此次移除文件的操作：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> PROJECTS.md</span></span><br><span class="line">rm &#x27;PROJECTS.md&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    deleted:    PROJECTS.md</span><br></pre></td></tr></table></figure>
<p>下一次提交时，该文件就不再纳入版本管理了。
如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项
<code>-f</code>（译注：即 force 的首字母）。
这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被
Git 恢复。</p>
<p>另外一种情况是，我们想<strong>把文件从 Git
仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中</strong>。
换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加
<code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆
<code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。
为达到这一目的，使用 <code>--cached</code> 选项：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> --cached README</span></span><br></pre></td></tr></table></figure>
<p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用
<code>glob</code> 模式。 比方说：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> <span class="built_in">log</span>/\*.<span class="built_in">log</span></span></span><br></pre></td></tr></table></figure>
<p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git
有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。
此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code>
的所有文件。 类似的比如：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> \*~</span></span><br></pre></td></tr></table></figure>
<p>该命令为删除以 <code>~</code> 结尾的所有文件。</p>
<h4 id="移动文件">移动文件</h4>
<p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git
中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。
不过 Git
非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p>
<p>既然如此，当你看到 Git 的 <code>mv</code> 命令时一定会困惑不已。 要在
Git 中对文件改名，可以这么做：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">mv</span> file_from file_to</span></span><br></pre></td></tr></table></figure>
<p>它会恰如预期般正常工作。
实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure>
<p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> README.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br></pre></td></tr></table></figure>
<p>如此分开操作，Git
也会意识到这是一次改名，所以不管何种方式结果都一样。
两者唯一的区别是，<code>mv</code>
是一条命令而另一种方式需要三条命令，直接用 <code>git mv</code>
轻便得多。
不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p>
<h3 id="查看提交历史">查看提交历史</h3>
<p>在提交了若干更新，又或者克隆了某个项目之后，你也许想<strong>回顾下提交历史</strong>。
完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。</p>
<p>接下来的例子会用我专门用于演示的 simplegit 项目，
运行下面的命令获取该项目源代码：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/schacon/simplegit-progit</span><br></pre></td></tr></table></figure>
<p>然后在此项目中运行 git log，应该会看到下面的输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>
<p>默认不用任何参数的话，<code>git log</code>
会按提交时间列出所有的更新，最近的更新排在最上面。
正如你所看到的，这个命令会列出每个提交的 SHA-1
校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<p><code>git log</code> 有许多选项可以帮助你搜寻你所要找的提交，
接下来我们介绍些最常用的。</p>
<p>一个常用的选项是 <code>-p</code>，用来显示每次提交的内容差异。
你也可以加上 <code>-2</code> 来仅显示最近两次提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -p -2</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require &#x27;rake/gempackagetask&#x27;</span><br><span class="line"> spec = Gem::Specification.new do |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   &quot;simplegit&quot;</span><br><span class="line">-    s.version   =   &quot;0.1.0&quot;</span><br><span class="line">+    s.version   =   &quot;0.1.1&quot;</span><br><span class="line">     s.author    =   &quot;Scott Chacon&quot;</span><br><span class="line">     s.email     =   &quot;schacon@gee-mail.com&quot;</span><br><span class="line">     s.summary   =   &quot;A simple gem for using Git in Ruby code.&quot;</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index a0a60ae..47c6340 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -18,8 +18,3 @@ class SimpleGit</span><br><span class="line">     end</span><br><span class="line"></span><br><span class="line"> end</span><br><span class="line">-</span><br><span class="line">-if $0 == __FILE__</span><br><span class="line">-  git = SimpleGit.new</span><br><span class="line">-  puts git.show</span><br><span class="line">-end</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure>
<p>该选项除了显示基本信息之外，<strong>还附带了每次 commit
的变化</strong>。 当进行代码审查，或者快速浏览某个搭档提交的 commit
所带来的变化的时候，这个参数就非常有用了。 你也可以为
<code>git log</code> 附带一系列的总结性选项。
比如说，如果你想看到每次提交的简略的统计信息，你可以使用
<code>--stat</code> 选项：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line"> Rakefile | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line"> lib/simplegit.rb | 5 -----</span><br><span class="line"> 1 file changed, 5 deletions(-)</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> README           |  6 ++++++</span><br><span class="line"> Rakefile         | 23 +++++++++++++++++++++++</span><br><span class="line"> lib/simplegit.rb | 25 +++++++++++++++++++++++++</span><br><span class="line"> 3 files changed, 54 insertions(+)</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，<code>--stat</code>
选项在每次提交的下面列出额所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。
在每次提交的最后还有一个总结。</p>
<p>另外一个常用的选项是 <code>--pretty</code>。
这个选项可以指定使用不同于默认格式的方式展示提交历史。
这个选项有一些内建的子选项供你使用。 比如用 <code>oneline</code>
将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有
<code>short</code>，<code>full</code> 和 <code>fuller</code>
可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949 changed the version number</span><br><span class="line">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test</span><br><span class="line">a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</span><br></pre></td></tr></table></figure>
<p>但最有意思的是 format，可以定制要显示的记录格式。
这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着 Git
的更新而发生改变：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h - %an, %ar : %s&quot;</span></span></span><br><span class="line">ca82a6d - Scott Chacon, 6 years ago : changed the version number</span><br><span class="line">085bb3b - Scott Chacon, 6 years ago : removed unnecessary test</span><br><span class="line">a11bef0 - Scott Chacon, 6 years ago : first commit</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://www.progit.cn/#pretty_format"><code>git log --pretty=format</code>
常用的选项</a> 列出了常用的格式占位符写法及其代表的意义。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">选项</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>%H</code></td>
<td style="text-align: left;">提交对象（commit）的完整哈希字串</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%h</code></td>
<td style="text-align: left;">提交对象的简短哈希字串</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%T</code></td>
<td style="text-align: left;">树对象（tree）的完整哈希字串</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%t</code></td>
<td style="text-align: left;">树对象的简短哈希字串</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%P</code></td>
<td style="text-align: left;">父对象（parent）的完整哈希字串</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%p</code></td>
<td style="text-align: left;">父对象的简短哈希字串</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%an</code></td>
<td style="text-align: left;">作者（author）的名字</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%ae</code></td>
<td style="text-align: left;">作者的电子邮件地址</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%ad</code></td>
<td style="text-align: left;">作者修订日期（可以用 --date=
选项定制格式）</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%ar</code></td>
<td style="text-align: left;">作者修订日期，按多久以前的方式显示</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%cn</code></td>
<td style="text-align: left;">提交者（committer）的名字</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%ce</code></td>
<td style="text-align: left;">提交者的电子邮件地址</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%cd</code></td>
<td style="text-align: left;">提交日期</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%cr</code></td>
<td style="text-align: left;">提交日期，按多久以前的方式显示</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%s</code></td>
<td style="text-align: left;">提交说明</td>
</tr>
</tbody>
</table>
<p>你一定奇怪 <em>作者</em> 和 <em>提交者</em> 之间究竟有何差别，
其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。
所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。
我们会在 <a target="_blank" rel="noopener" href="https://www.progit.cn/#_distributed_git">分布式
Git</a> 再详细介绍两者之间的细微差别。</p>
<p>当 oneline 或 format 与另一个 <code>log</code> 选项
<code>--graph</code> 结合使用时尤其有用。
这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> --graph</span></span><br><span class="line">* 2d3acf9 ignore errors from SIGCHLD on trap</span><br><span class="line">*  5e3ee11 Merge branch &#x27;master&#x27; of git://github.com/dustin/grit</span><br><span class="line">|\</span><br><span class="line">| * 420eac9 Added a method for getting the current branch.</span><br><span class="line">* | 30e367c timeout code and tests</span><br><span class="line">* | 5a09431 add timeout protection to grit</span><br><span class="line">* | e1193f8 support for heads with slashes in them</span><br><span class="line">|/</span><br><span class="line">* d6016bc require time for xmlschema</span><br><span class="line">*  11d191e Merge branch &#x27;defunkt&#x27; into local</span><br></pre></td></tr></table></figure>
<p>这种输出类型会在我们下一章学完分支与合并以后变得更加有趣。</p>
<p>以上只是简单介绍了一些 <code>git log</code> 命令支持的选项。 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#log_options"><code>git log</code>
的常用选项</a>
列出了我们目前涉及到的和没涉及到的选项，以及它们是如何影响 log
命令的输出的：</p>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">选项</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>-p</code></td>
<td style="text-align: left;">按补丁格式显示每个更新之间的差异。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--stat</code></td>
<td style="text-align: left;">显示每次更新的文件修改统计信息。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--shortstat</code></td>
<td style="text-align: left;">只显示 --stat
中最后的行数修改添加移除统计。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--name-only</code></td>
<td style="text-align: left;">仅在提交信息后显示已修改的文件清单。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--name-status</code></td>
<td style="text-align: left;">显示新增、修改、删除的文件清单。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--abbrev-commit</code></td>
<td style="text-align: left;">仅显示 SHA-1 的前几个字符，而非所有的 40
个字符。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--relative-date</code></td>
<td style="text-align: left;">使用较短的相对时间显示（比如，“2 weeks
ago”）。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--graph</code></td>
<td style="text-align: left;">显示 ASCII 图形表示的分支合并历史。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--pretty</code></td>
<td
style="text-align: left;">使用其他格式显示历史提交信息。可用的选项包括
oneline，short，full，fuller 和 format（后跟指定格式）。</td>
</tr>
</tbody>
</table>
<h4 id="限制输出长度">限制输出长度</h4>
<p>除了定制输出格式的选项之外，<code>git log</code>
还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。
之前你已经看到过 <code>-2</code> 了，它只显示最近的两条提交，
实际上，这是 <code>-&lt;n&gt;</code> 选项的写法，其中的 <code>n</code>
可以是任何整数，表示仅显示最近的若干条提交。
不过实践中我们是不太用这个选项的，Git
在输出所有提交时会自动调用分页程序，所以你一次只会看到一页的内容。</p>
<p>另外还有按照时间作限制的选项，比如 <code>--since</code> 和
<code>--until</code> 也很有用。
例如，下面的命令列出所有最近两周内的提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --since=2.weeks</span></span><br></pre></td></tr></table></figure>
<p>这个命令可以在多种格式下工作，比如说具体的某一天
<code>"2008-01-15"</code>，或者是相对地多久以前
<code>"2 years 1 day 3 minutes ago"</code>。</p>
<p>还可以给出若干搜索条件，列出符合的提交。 用 <code>--author</code>
选项显示指定作者的提交，用 <code>--grep</code>
选项搜索提交说明中的关键字。
（请注意，如果要得到同时满足这两个选项搜索条件的提交，就必须用
<code>--all-match</code>
选项。否则，满足任意一个条件的提交都会被匹配出来）</p>
<p>另一个非常有用的筛选选项是
<code>-S</code>，可以列出那些添加或移除了某些字符串的提交。
比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -Sfunction_name</span></span><br></pre></td></tr></table></figure>
<p>最后一个很实用的 <code>git log</code> 选项是路径（path），
如果只关心某些文件或者目录的历史提交，可以在 git log
选项的最后指定它们的路径。
因为是放在最后位置上的选项，所以用两个短划线（--）隔开之前的选项和后面限定的路径名。</p>
<p>在 <a target="_blank" rel="noopener" href="https://www.progit.cn/#limit_options">限制
<code>git log</code> 输出的选项</a> 中列出了常用的选项</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">选项</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>-(n)</code></td>
<td style="text-align: left;">仅显示最近的 n 条提交</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--since</code>,
<code>--after</code></td>
<td style="text-align: left;">仅显示指定时间之后的提交。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--until</code>,
<code>--before</code></td>
<td style="text-align: left;">仅显示指定时间之前的提交。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--author</code></td>
<td style="text-align: left;">仅显示指定作者相关的提交。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--committer</code></td>
<td style="text-align: left;">仅显示指定提交者相关的提交。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--grep</code></td>
<td style="text-align: left;">仅显示含指定关键字的提交</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-S</code></td>
<td style="text-align: left;">仅显示添加或移除了某个关键字的提交</td>
</tr>
</tbody>
</table>
<p>来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio
Hamano 提交的但未合并的测试文件，可以用下面的查询命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=<span class="string">&quot;%h - %s&quot;</span> --author=gitster --since=<span class="string">&quot;2008-10-01&quot;</span> \</span></span><br><span class="line"><span class="language-bash">   --before=<span class="string">&quot;2008-11-01&quot;</span> --no-merges -- t/</span></span><br><span class="line">5610e3b - Fix testcase failure when extended attributes are in use</span><br><span class="line">acd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;() API</span><br><span class="line">f563754 - demonstrate breakage of detached checkout with symbolic link HEAD</span><br><span class="line">d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths</span><br><span class="line">51a94af - Fix &quot;checkout --track -b newbranch&quot; on detached HEAD</span><br><span class="line">b0ad11e - pull: allow &quot;git pull origin $something:$current_branch&quot; into an unborn branch</span><br></pre></td></tr></table></figure>
<p>在近 40000 条提交中，上面的输出仅列出了符合条件的 6 条记录。</p>
<h3 id="撤消操作">撤消操作</h3>
<p>在任何一个阶段，你都有可能想要撤消某些操作。
这里，我们将会学习几个撤消你所做修改的基本工具。
<strong>注意，有些撤消操作是不可逆的。</strong> 这是在使用 Git
的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。
此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure>
<p>这个命令会将暂存区中的文件提交。
如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p>
<p>文本编辑器启动后，可以看到之前的提交信息。
编辑后保存会覆盖原来的提交信息。</p>
<p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;initial commit&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add forgotten_file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure>
<p>最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</p>
<h4 id="取消暂存的文件">取消暂存的文件</h4>
<p>接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。
这些命令在修改文件状态的同时，也会提示如何撤消操作。
例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了
<code>git add *</code> 暂存了它们两个。 如何只取消暂存两个中的一个呢？
<code>git status</code> 命令提示了你：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add *</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>在 “Changes to be committed” 文字正下方，提示使用
<code>git reset HEAD &lt;file&gt;...</code> 来取消暂存。
所以，我们可以这样来取消暂存 <code>CONTRIBUTING.md</code> 文件：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD CONTRIBUTING.md</span></span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	CONTRIBUTING.md</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>这个命令有点儿奇怪，但是起作用了。 <code>CONTRIBUTING.md</code>
文件已经是修改未暂存的状态了。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>虽然在调用时加上 <code>--hard</code> 选项<strong>可以</strong>令
<code>git reset</code>
成为一个危险的命令（译注：可能导致工作目录中所有当前进度丢失！），但本例中工作目录内的文件并不会被修改。
<u>不加选项地调用 <code>git reset</code> 并不危险 —
它只会修改暂存区域。</u></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>到目前为止这个神奇的调用就是你需要对 <code>git reset</code>
命令全部的了解。我们将会在 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_git_reset">重置揭密</a> 中了解
<code>reset</code> 的更多细节以及如何掌握它做一些真正有趣的事。</p>
<h4 id="撤消对文件的修改">撤消对文件的修改</h4>
<p>如果你并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改怎么办？
你该如何方便地撤消修改 -
将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？
幸运的是，<code>git status</code> 也告诉了你应该如何做。
在最后一个例子中，未暂存区域是这样：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>它非常清楚地告诉了你如何撤消之前所做的修改。
让我们来按照提示执行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure>
<p>可以看到那些修改已经被撤消了。</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>IMPORTANT</th>
<th>你需要知道 <code>git checkout -- [file]</code>
是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 -
你只是拷贝了另一个文件来覆盖它。
除非你确实清楚不想要那个文件了，否则不要使用这个命令。</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在
<a target="_blank" rel="noopener" href="https://www.progit.cn/#_git_branching">Git 分支</a>
介绍保存进度与分支；这些通常是更好的做法。</p>
<p>记住，在 Git 中任何 <em>已提交的</em> 东西几乎总是可以恢复的。
甚至那些被删除的分支中的提交或使用 <code>--amend</code>
选项覆盖的提交也可以恢复（阅读 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_data_recovery">数据恢复</a>
了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。</p>
<h3 id="远程仓库的使用">远程仓库的使用</h3>
<p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。
远程仓库是指托管在因特网或其他网络中的你的项目的版本库。
你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。
与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。
管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。
在本节中，我们将介绍一部分远程管理的技能。</p>
<h4 id="查看远程仓库">查看远程仓库</h4>
<p>如果想查看你已经配置的远程仓库服务器，可以运行
<code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。
如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git
给你克隆的仓库服务器的默认名字：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/schacon/ticgit</span></span><br><span class="line">Cloning into &#x27;ticgit&#x27;...</span><br><span class="line">remote: Reusing existing pack: 1857, done.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (772/772), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ticgit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git
保存的简写与其对应的 URL。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin	https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure>
<p>如果你的远程仓库不止一个，该命令会将它们全部列出。
例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> grit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (fetch)</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (push)</span><br><span class="line">cho45     https://github.com/cho45/grit (fetch)</span><br><span class="line">cho45     https://github.com/cho45/grit (push)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (fetch)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (push)</span><br><span class="line">koke      git://github.com/koke/grit.git (fetch)</span><br><span class="line">koke      git://github.com/koke/grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (push)</span><br></pre></td></tr></table></figure>
<p>这样我们可以轻松拉取其中任何一个用户的贡献。
此外，我们大概还会有某些远程仓库的推送权限，虽然我们目前还不会在此介绍。</p>
<p>注意这些远程仓库使用了不同的协议；我们将会在 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_git_on_the_server">在服务器上搭建 Git</a>
中了解关于它们的更多信息。</p>
<h4 id="添加远程仓库">添加远程仓库</h4>
<p>我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。
运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code>
添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add pb https://github.com/paulboone/ticgit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin	https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit (push)</span><br><span class="line">pb	https://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pb	https://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure>
<p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。
例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行
<code>git fetch pb</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch pb</span></span><br><span class="line">remote: Counting objects: 43, done.</span><br><span class="line">remote: Compressing objects: 100% (36/36), done.</span><br><span class="line">remote: Total 43 (delta 10), reused 31 (delta 5)</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure>
<p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到
-
你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。
（我们将会在 <a target="_blank" rel="noopener" href="https://www.progit.cn/#_git_branching">Git
分支</a> 中详细介绍什么是分支以及如何使用分支。）</p>
<h4 id="从远程仓库中抓取与拉取">从远程仓库中抓取与拉取</h4>
<p>就如刚才所见，从远程仓库中获得数据，可以执行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch [remote-name]</span></span><br></pre></td></tr></table></figure>
<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。
执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p>如果你使用 <code>clone</code>
命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin”
为简写。 所以，<code>git fetch origin</code>
会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意
<code>git fetch</code> 命令会将数据拉取到你的本地仓库 -
它并不会自动合并或修改你当前的工作。
当准备好时你必须手动将其合并入你的工作。</p>
<p>如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_git_branching">Git 分支</a>
了解更多信息），可以使用 <code>git pull</code>
命令来自动的抓取然后合并远程分支到当前分支。
这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，<code>git clone</code>
命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master
分支（或不管是什么名字的默认分支）。 运行 <code>git pull</code>
通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<h4 id="推送到远程仓库">推送到远程仓库</h4>
<p>当你想分享你的项目时，必须将其推送到上游。
这个命令很简单：<code>git push [remote-name] [branch-name]</code>。
当你想要将 master 分支推送到 <code>origin</code>
服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master</span></span><br></pre></td></tr></table></figure>
<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。
当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。
你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 阅读 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_git_branching">Git 分支</a>
了解如何推送到远程仓库服务器的详细信息。</p>
<h4 id="查看远程仓库-1">查看远程仓库</h4>
<p>如果想要查看某一个远程仓库的更多信息，可以使用
<code>git remote show [remote-name]</code> 命令。
如果想以一个特定的缩写名运行这个命令，例如
<code>origin</code>，会得到像下面类似的信息：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit</span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                               tracked</span><br><span class="line">    dev-branch                           tracked</span><br><span class="line">  Local branch configured for &#x27;git pull&#x27;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#x27;git push&#x27;:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure>
<p>它同样会列出远程仓库的 URL 与跟踪分支的信息。
这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git
pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master
分支。 它也会列出拉取到的所有远程引用。</p>
<p>这是一个经常遇到的简单例子。 如果你是 Git
的重度使用者，那么还可以通过 <code>git remote show</code>
看到更多的信息。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  URL: https://github.com/my-org/complex-project</span><br><span class="line">  Fetch URL: https://github.com/my-org/complex-project</span><br><span class="line">  Push  URL: https://github.com/my-org/complex-project</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                           tracked</span><br><span class="line">    dev-branch                       tracked</span><br><span class="line">    markdown-strip                   tracked</span><br><span class="line">    issue-43                         new (next fetch will store in remotes/origin)</span><br><span class="line">    issue-45                         new (next fetch will store in remotes/origin)</span><br><span class="line">    refs/remotes/origin/issue-11     stale (use &#x27;git remote prune&#x27; to remove)</span><br><span class="line">  Local branches configured for &#x27;git pull&#x27;:</span><br><span class="line">    dev-branch merges with remote dev-branch</span><br><span class="line">    master     merges with remote master</span><br><span class="line">  Local refs configured for &#x27;git push&#x27;:</span><br><span class="line">    dev-branch                     pushes to dev-branch                     (up to date)</span><br><span class="line">    markdown-strip                 pushes to markdown-strip                 (up to date)</span><br><span class="line">    master                         pushes to master                         (up to date)</span><br></pre></td></tr></table></figure>
<p>这个命令列出了当你在特定的分支上执行 <code>git push</code>
会自动地推送到哪一个远程分支。
它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行
<code>git pull</code> 时哪些分支会自动合并。</p>
<h4 id="远程仓库的移除与重命名">远程仓库的移除与重命名</h4>
<p>如果想要重命名引用的名字可以运行 <code>git remote rename</code>
去修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为
<code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote rename pb paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure>
<p>值得注意的是这同样也会修改你的远程分支名字。 那些过去引用
<code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p>
<p>如果因为一些原因想要移除一个远程仓库 -
你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了
- 可以使用 <code>git remote rm</code> ：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote <span class="built_in">rm</span> paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<h3 id="打标签">打标签</h3>
<p>像其他版本控制系统（VCS）一样，Git
可以给历史中的某一个提交打上标签，以示重要。
比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。
在本节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。</p>
<h4 id="列出标签">列出标签</h4>
<p>在 Git 中列出已有的标签是非常简单直观的。 只需要输入
<code>git tag</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br></pre></td></tr></table></figure>
<p>这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。</p>
<p>你也可以使用特定的模式查找标签。 例如，Git
自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5
系列感兴趣，可以运行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -l <span class="string">&#x27;v1.8.5*&#x27;</span></span></span><br><span class="line">v1.8.5</span><br><span class="line">v1.8.5-rc0</span><br><span class="line">v1.8.5-rc1</span><br><span class="line">v1.8.5-rc2</span><br><span class="line">v1.8.5-rc3</span><br><span class="line">v1.8.5.1</span><br><span class="line">v1.8.5.2</span><br><span class="line">v1.8.5.3</span><br><span class="line">v1.8.5.4</span><br><span class="line">v1.8.5.5</span><br></pre></td></tr></table></figure>
<h4 id="创建标签">创建标签</h4>
<p>Git
使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p>
<p>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</p>
<p>然而，附注标签是存储在 Git 数据库中的一个完整对象。
它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用
GNU Privacy Guard （GPG）签名与验证。
通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p>
<h4 id="附注标签">附注标签</h4>
<p>在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行
<code>tag</code> 命令时指定 <code>-a</code> 选项：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.4 -m <span class="string">&#x27;my version 1.4&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure>
<p><code>-m</code> 选项指定了一条将会存储在标签中的信息。
如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。</p>
<p>通过使用 <code>git show</code>
命令可以看到标签信息与对应的提交信息：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.4</span></span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:19:12 2014 -0700</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure>
<p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p>
<h4 id="轻量标签">轻量标签</h4>
<p>另一种给提交打标签的方式是使用轻量标签。
轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。
创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或
<code>-m</code> 选项，只需要提供标签名字：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag v1.4-lw</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br></pre></td></tr></table></figure>
<p>这时，如果在标签上运行
<code>git show</code>，你不会看到额外的标签信息。
命令只会显示出提交信息：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.4-lw</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure>
<h4 id="后期打标签">后期打标签</h4>
<p>你也可以对过去的提交打标签。 假设提交历史是这样的：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#x27;experiment&#x27;</span><br><span class="line">a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</span><br><span class="line">0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</span><br><span class="line">6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#x27;experiment&#x27;</span><br><span class="line">0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function</span><br><span class="line">4682c3261057305bdd616e23b64b0857d832627b added a todo file</span><br><span class="line">166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br></pre></td></tr></table></figure>
<p>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile”
提交。 你可以在之后补上标签。
要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）:</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.2 9fceb02</span></span><br></pre></td></tr></table></figure>
<p>可以看到你已经在那次提交上打上标签了：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.2</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.2</span></span><br><span class="line">tag v1.2</span><br><span class="line">Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Feb 9 15:32:16 2009 -0800</span><br><span class="line"></span><br><span class="line">version 1.2</span><br><span class="line">commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sun Apr 27 20:43:35 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="共享标签">共享标签</h4>
<p>默认情况下，<code>git push</code>
命令并不会传送标签到远程仓库服务器上。
在创建完标签后你必须显式地推送标签到共享服务器上。
这个过程就像共享远程分支一样 - 你可以运行
<code>git push origin [tagname]</code>。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin v1.5</span></span><br><span class="line">Counting objects: 14, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (12/12), done.</span><br><span class="line">Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.</span><br><span class="line">Total 14 (delta 3), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure>
<p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的
<code>git push</code> 命令。
这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --tags</span></span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.4 -&gt; v1.4</span><br><span class="line"> * [new tag]         v1.4-lw -&gt; v1.4-lw</span><br></pre></td></tr></table></figure>
<p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p>
<h4 id="检出标签">检出标签</h4>
<p>在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。
如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用
<code>git checkout -b [branchname] [tagname]</code>
在特定的标签上创建一个新分支：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b version2 v2.0.0</span></span><br><span class="line">Switched to a new branch &#x27;version2&#x27;</span><br></pre></td></tr></table></figure>
<p>当然，如果在这之后又进行了一次提交，<code>version2</code>
分支会因为改动向前移动了，那么 <code>version2</code> 分支就会和
<code>v2.0.0</code> 标签稍微有些不同，这时就应该当心了。</p>
<h3 id="git-别名">Git 别名</h3>
<p>在我们结束本章 Git 基础之前，正好有一个小技巧可以使你的 Git
体验更简单、容易、熟悉：别名。
我们不会在之后的章节中引用到或假定你使用过它们，但是你大概应该知道如何使用它们。</p>
<p>Git 并不会在你输入部分命令时自动推断出你想要的命令。
如果不想每次都输入完整的 Git 命令，可以通过 <code>git config</code>
文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.co checkout</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.br branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.ci commit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.st status</span></span><br></pre></td></tr></table></figure>
<p>这意味着，当要输入 <code>git commit</code> 时，只需要输入
<code>git ci</code>。 随着你继续不断地使用
Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。</p>
<p>在创建你认为应该存在的命令时这个技术会很有用。
例如，为了解决取消暂存文件的易用性问题，可以向 Git
中添加你自己的取消暂存别名：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.unstage <span class="string">&#x27;reset HEAD --&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>这会使下面的两个命令等价：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git unstage fileA</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD -- fileA</span></span><br></pre></td></tr></table></figure>
<p>这样看起来更清楚一些。 通常也会添加一个 <code>last</code>
命令，像这样：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.last <span class="string">&#x27;log -1 HEAD&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>这样，可以轻松地看到最后一次提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git last</span></span><br><span class="line">commit 66938dae3329c7aebe598c2246a8e6af90d04646</span><br><span class="line">Author: Josh Goebel &lt;dreamer3@example.com&gt;</span><br><span class="line">Date:   Tue Aug 26 19:48:51 2008 +0800</span><br><span class="line"></span><br><span class="line">    test for current head</span><br><span class="line"></span><br><span class="line">    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出，Git 只是简单地将别名替换为对应的命令。
然而，你可能想要执行外部命令，而不是一个 Git 子命令。
如果是那样的话，可以在命令前面加入 <code>!</code> 符号。
如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将
<code>git visual</code> 定义为 <code>gitk</code> 的别名：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.visual <span class="string">&#x27;!gitk&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>现在，你可以完成所有基本的 Git
本地操作－创建或者克隆一个仓库、做更改、暂存并提交这些更改、浏览你的仓库从创建到现在的所有更改的历史。
下一步，本书将介绍 Git 的杀手级特性：分支模型。</p>
<h2 id="git-分支">Git 分支</h2>
<p>在很多版本控制系统中，使用分支常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p>
<p>有人把 Git 的分支模型称为它的`‘必杀技特性’'。 Git
创建新分支速度快，切换便捷。 与许多其它版本控制系统不同，Git
<strong>鼓励</strong>在工作流程中频繁地使用分支与合并。
理解和精通这一特性，你便会意识到 Git
是如此的强大而又独特，并且从此真正改变你的开发方式。</p>
<h3 id="分支简介">分支简介</h3>
<p>为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git
是如何保存数据的。</p>
<p>或许你还记得 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_getting_started">起步</a> 的内容，Git
保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。</p>
<p>在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git
保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。
但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及<strong>指向它的父对象的指针</strong>。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，</p>
<p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。
暂存操作会为每一个文件计算校验和（使用我们在 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_getting_started">起步</a> 中提到的 SHA-1
哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob
对象来保存它们），最终将校验和加入到暂存区域等待提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README test.rb LICENSE</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;The initial commit of my project&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>当使用 <code>git commit</code> 进行提交操作时，Git
会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git
仓库中这些校验和保存为树对象。 随后，Git
便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git
就可以在需要的时候重现此次保存的快照。</p>
<p>现在，Git 仓库中有<strong>五个对象</strong>：三个 blob
对象（保存着文件快照）、一个树对象（记录着目录结构和 blob
对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p>
<figure>
<img src="https://www.progit.cn/images/commit-and-tree.png"
alt="首次提交对象及其树结构。" />
<figcaption aria-hidden="true">首次提交对象及其树结构。</figcaption>
</figure>
<p>Figure 9. 首次提交对象及其树结构</p>
<p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p>
<figure>
<img src="https://www.progit.cn/images/commits-and-parents.png"
alt="提交对象及其父对象。" />
<figcaption aria-hidden="true">提交对象及其父对象。</figcaption>
</figure>
<p>Figure 10. 提交对象及其父对象</p>
<p><strong>Git 的分支，其实本质上仅仅是指向提交对象的可变指针</strong>。
Git 的默认分支名字是 <code>master</code>。
在多次提交操作之后，你其实已经有一个指向最后那个提交对象的
<code>master</code> 分支。 它会在每次的提交操作中自动向前移动。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>Git 的 “master” 分支并不是一个特殊分支。
它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master
分支，是因为 <code>git init</code>
命令默认创建它，并且大多数人都懒得去改动它。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure>
<img src="https://www.progit.cn/images/branch-and-history.png"
alt="分支及其提交历史。" />
<figcaption aria-hidden="true">分支及其提交历史。</figcaption>
</figure>
<p>Figure 11. 分支及其提交历史</p>
<h4 id="分支创建">分支创建</h4>
<p>Git 是怎么创建新分支的呢？
很简单，<strong>它只是为你创建了一个可以移动的新的指针</strong>。
比如，创建一个 testing 分支， 你需要使用 <code>git branch</code>
命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch testing</span></span><br></pre></td></tr></table></figure>
<p><strong>这会在当前所在的提交对象上创建一个指针</strong>。</p>
<figure>
<img src="https://www.progit.cn/images/two-branches.png"
alt="两个指向相同提交历史的分支。" />
<figcaption aria-hidden="true">两个指向相同提交历史的分支。</figcaption>
</figure>
<p>Figure 12. 两个指向相同提交历史的分支</p>
<p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为
<code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如
Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git
中，它是一个指针，指向当前所在的本地分支（译注：<strong>将
<code>HEAD</code> 想象为当前分支的别名</strong>）。 在本例中，你仍然在
<code>master</code> 分支上。 因为 <code>git branch</code>
命令<strong>仅仅 <em>创建</em></strong>
一个新分支，并不会自动切换到新分支中去。</p>
<figure>
<img src="https://www.progit.cn/images/head-to-master.png"
alt="HEAD 指向当前所在的分支。" />
<figcaption aria-hidden="true">HEAD 指向当前所在的分支。</figcaption>
</figure>
<p>Figure 13. HEAD 指向当前所在的分支</p>
<p>你可以简单地使用 <code>git log</code>
命令查看各个分支当前所指的对象。 提供这一功能的参数是
<code>--decorate</code>。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --decorate</span></span><br><span class="line">f30ab (HEAD, master, testing) add feature #32 - ability to add new</span><br><span class="line">34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">98ca9 initial commit of my project</span><br></pre></td></tr></table></figure>
<p>正如你所见，当前 “master” 和 “testing” 分支均指向校验和以
<code>f30ab</code> 开头的提交对象。</p>
<h4 id="分支切换">分支切换</h4>
<p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。
我们现在切换到新创建的 <code>testing</code> 分支去：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout testing</span></span><br></pre></td></tr></table></figure>
<p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p>
<figure>
<img src="https://www.progit.cn/images/head-to-testing.png"
alt="HEAD 指向当前所在的分支。" />
<figcaption aria-hidden="true">HEAD 指向当前所在的分支。</figcaption>
</figure>
<p>Figure 14. HEAD 指向当前所在的分支</p>
<p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim test.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;made a change&#x27;</span></span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/advance-testing.png"
alt="HEAD 分支随着提交操作自动向前移动。" />
<figcaption aria-hidden="true">HEAD
分支随着提交操作自动向前移动。</figcaption>
</figure>
<p>Figure 15. HEAD 分支随着提交操作自动向前移动</p>
<p>如图所示，你的 <code>testing</code> 分支向前移动了，但是
<code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code>
时所指的对象。 这就有意思了，现在我们切换回 <code>master</code>
分支看看：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/checkout-master.png"
alt="检出时 HEAD 随之移动。" />
<figcaption aria-hidden="true">检出时 HEAD 随之移动。</figcaption>
</figure>
<p>Figure 16. 检出时 HEAD 随之移动</p>
<p><strong>这条命令做了两件事</strong>。 一是使 HEAD 指回
<code>master</code> 分支，二是将工作目录恢复成 <code>master</code>
分支所指向的快照内容。
也就是说，你现在做修改的话，项目将始于一个较旧的版本。
本质上来讲，这就是忽略 <code>testing</code>
分支所做的修改，以便于向另一个方向进行开发。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>分支切换会改变你工作目录中的文件。在切换分支时，一定要注意你工作目录里的文件会被改变。
如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。
如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>我们不妨再稍微做些修改并提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim test.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;made other changes&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>现在，这个项目的提交历史已经产生了分叉（参见 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#divergent_history">项目分叉历史</a>）。
因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回
master 分支进行了另外一些工作。
上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。
而所有这些工作，你需要的命令只有
<code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p>
<figure>
<img src="https://www.progit.cn/images/advance-master.png"
alt="项目分叉历史。" />
<figcaption aria-hidden="true">项目分叉历史。</figcaption>
</figure>
<p>Figure 17. 项目分叉历史</p>
<p>你可以简单地使用 <code>git log</code> 命令查看分叉历史。 运行
<code>git log --oneline --decorate --graph --all</code>
，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --decorate --graph --all</span></span><br><span class="line">* c2b9e (HEAD, master) made other changes</span><br><span class="line">| * 87ab2 (testing) made a change</span><br><span class="line">|/</span><br><span class="line">* f30ab add feature #32 - ability to add new formats to the</span><br><span class="line">* 34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">* 98ca9 initial commit of my project</span><br></pre></td></tr></table></figure>
<p>由于 Git 的分支<strong>实质上仅是包含所指对象校验和（长度为 40 的
SHA-1 值字符串）的文件</strong>，所以它的创建和销毁都异常高效。
创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1
个换行符），如此的简单能不快吗？</p>
<p>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。
完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。而在
Git 中，任何规模的项目都能在瞬间创建新分支。
同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。
这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。</p>
<p>接下来，让我们看看你为什么应该这样做。</p>
<h3 id="分支的新建与合并">分支的新建与合并</h3>
<p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。
你将经历如下步骤：</p>
<ol type="1">
<li>开发某个网站。</li>
<li>为实现某个新的需求，创建一个分支。</li>
<li>在这个分支上开展工作。</li>
</ol>
<p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。
你将按照如下方式来处理：</p>
<ol type="1">
<li>切换到你的线上分支（production branch）。</li>
<li>为这个紧急任务新建一个分支，并在其中修复它。</li>
<li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li>
<li>切换回你最初工作的分支上，继续工作。</li>
</ol>
<h4 id="新建分支">新建分支</h4>
<p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p>
<figure>
<img src="https://www.progit.cn/images/basic-branching-1.png"
alt="一个简单的提交历史。" />
<figcaption aria-hidden="true">一个简单的提交历史。</figcaption>
</figure>
<p>Figure 18. 一个简单提交历史</p>
<p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。
想要新建一个分支并同时切换到那个分支上，你可以运行一个带有
<code>-b</code> 参数的 <code>git checkout</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b iss53</span></span><br><span class="line">Switched to a new branch &quot;iss53&quot;</span><br></pre></td></tr></table></figure>
<p>它是下面两条命令的简写：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch iss53</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout iss53</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/basic-branching-2.png"
alt="创建一个新分支指针。" />
<figcaption aria-hidden="true">创建一个新分支指针。</figcaption>
</figure>
<p>Figure 19. 创建一个新分支指针</p>
<p>你继续在 #53 问题上工作，并且做了一些提交。
在此过程中，<code>iss53</code>
分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的
<code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim index.html</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;added a new footer [issue 53]&#x27;</span></span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/basic-branching-3.png"
alt="iss53 分支随着工作的进展向前推进。" />
<figcaption aria-hidden="true">iss53
分支随着工作的进展向前推进。</figcaption>
</figure>
<p>Figure 20. iss53 分支随着工作的进展向前推进</p>
<p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git
的帮助，你不必把这个紧急问题和 <code>iss53</code>
的修改混在一起，你也不需要花大力气来还原关于 53#
问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。
你所要做的仅仅是切换回 <code>master</code> 分支。</p>
<p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止
Git 切换到该分支。
最好的方法是，在你切换分支之前，保持好一个干净的状态。
有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit
amending）），我们会在 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_git_stashing">储藏与清理</a>
中看到关于这两个命令的介绍。
现在，我们假设你已经把你的修改全部提交了，这时你可以切换回
<code>master</code> 分支了：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure>
<p>这个时候，你的工作目录和你在开始 #53
问题之前一模一样，现在你可以专心修复紧急问题了。
<strong>请牢记：当你切换分支的时候，Git
会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。</strong>
Git
会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p>
<p>接下来，你要修复这个紧急问题。
让我们建立一个针对该紧急问题的分支（hotfix
branch），在该分支上工作直到问题解决：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b hotfix</span></span><br><span class="line">Switched to a new branch &#x27;hotfix&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim index.html</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;fixed the broken email address&#x27;</span></span></span><br><span class="line">[hotfix 1fb7853] fixed the broken email address</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/basic-branching-4.png"
alt="基于 master 分支的紧急问题分支（hotfix branch）。" />
<figcaption aria-hidden="true">基于 <code>master</code>
分支的紧急问题分支（hotfix branch）。</figcaption>
</figure>
<p>Figure 21. 基于 <code>master</code> 分支的紧急问题分支
<code>hotfix branch</code></p>
<p>你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的
<code>master</code> 分支来部署到线上。 你可以使用 <code>git merge</code>
命令来达到上述目的：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge hotfix</span></span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>
<p>在合并的时候，你应该注意到了"快进<strong>（fast-forward）</strong>"这个词。
由于当前 <code>master</code> 分支所指向的提交是你当前提交（有关 hotfix
的提交）的直接上游，所以 Git 只是简单的将指针向前移动。
换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么
Git
在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做
“快进（fast-forward）”。</p>
<p>现在，最新的修改已经在 <code>master</code>
分支所指向的提交快照中，你可以着手发布该修复了。</p>
<figure>
<img src="https://www.progit.cn/images/basic-branching-5.png"
alt="master 被快进到 hotfix。" />
<figcaption aria-hidden="true"><code>master</code> 被快进到
<code>hotfix</code>。</figcaption>
</figure>
<p>Figure 22. <code>master</code> 被快进到 <code>hotfix</code></p>
<p>关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。
<strong>然而，你应该先删除 <code>hotfix</code>
分支，因为你已经不再需要它了 —— <code>master</code>
分支已经指向了同一个位置。</strong> 你可以使用带 <code>-d</code> 选项的
<code>git branch</code> 命令来删除分支：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d hotfix</span></span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure>
<p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53
问题的那个分支（iss53 分支）。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout iss53</span></span><br><span class="line">Switched to branch &quot;iss53&quot;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim index.html</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;finished the new footer [issue 53]&#x27;</span></span></span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/basic-branching-6.png"
alt="继续在 iss53 分支上的工作。" />
<figcaption aria-hidden="true">继续在 <code>iss53</code>
分支上的工作。</figcaption>
</figure>
<p>Figure 23. 继续在 <code>iss53</code> 分支上的工作</p>
<p>你在 <code>hotfix</code> 分支上所做的工作并没有包含到
<code>iss53</code> 分支中。 如果你需要拉取 <code>hotfix</code>
所做的修改，你可以使用 <code>git merge master</code> 命令<strong>将
<code>master</code> 分支合并入 <code>iss53</code> 分支，或者你也可以等到
<code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code>
分支</strong>。</p>
<h4 id="分支的合并">分支的合并</h4>
<p>假设你已经修正了 #53 问题，并且打算将你的工作合并入
<code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到
<code>master</code> 分支，这和之前你合并 <code>hotfix</code>
分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行
<code>git merge</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge iss53</span></span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>这和你之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。
在这种情况下，<strong>你的开发历史从一个更早的地方开始分叉开来</strong>（diverged）。
因为，<code>master</code> 分支所在提交并不是 <code>iss53</code>
分支所在提交的直接祖先，Git 不得不做一些额外的工作。
出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code>
和
<code>C5</code>）以及这两个分支的工作祖先（<code>C2</code>），做一个简单的<strong>三方合并</strong>。</p>
<figure>
<img src="https://www.progit.cn/images/basic-merging-1.png"
alt="一次典型合并中所用到的三个快照。" />
<figcaption
aria-hidden="true">一次典型合并中所用到的三个快照。</figcaption>
</figure>
<p>Figure 24. 一次典型合并中所用到的三个快照</p>
<p>和之前将分支指针向前推进所不同的是，Git
将此次三方合并的结果做了一个新的快照<strong>并且自动创建一个新的提交指向它</strong>。
这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p>
<figure>
<img src="https://www.progit.cn/images/basic-merging-2.png"
alt="一个合并提交。" />
<figcaption aria-hidden="true">一个合并提交。</figcaption>
</figure>
<p>Figure 25. 一个合并提交</p>
<p>需要指出的是，Git
会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的
CVS 系统或者 Subversion （1.5
版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。
Git 的这个优势使其在合并操作上比其他系统要简单很多。</p>
<p>既然你的修改已经合并进来了，你已经不再需要 <code>iss53</code>
分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d iss53</span></span><br></pre></td></tr></table></figure>
<h4 id="遇到冲突时的分支合并">遇到冲突时的分支合并</h4>
<p>有时候合并操作不会如此顺利。
<strong>如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git
就没法干净的合并它们。</strong> 如果你对 #53 问题的修改和有关
<code>hotfix</code>
的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge iss53</span></span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git
会暂停下来，等待你去解决合并产生的冲突。
你可以在合并冲突后的任意时刻使用 <code>git status</code>
命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git
会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。
出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">=======</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line"> please contact us at support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure>
<p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code>
分支所在的位置，因为你在运行 merge
命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code>
的上半部分），而 <code>iss53</code> 分支所指示的版本在
<code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由
<code>=======</code>
分割的两部分中的一个，或者你也可以自行合并这些内容。
例如，你可以通过把这段内容换成下面的样子来解决冲突：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述的冲突解决方案仅保留了其中一个分支的修改，并且
<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和
<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。
在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code>
命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git
就会将它们标记为冲突已解决。</p>
<p>如果你想使用图形化工具来解决冲突，你可以运行
<code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git mergetool</span></span><br><span class="line"></span><br><span class="line">This message is displayed because &#x27;merge.tool&#x27; is not configured.</span><br><span class="line">See &#x27;git mergetool --tool-help&#x27; or &#x27;git help config&#x27; for more details.</span><br><span class="line">&#x27;git mergetool&#x27; will now attempt to use one of the following tools:</span><br><span class="line">opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge</span><br><span class="line">Merging:</span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line">Normal merge conflict for &#x27;index.html&#x27;:</span><br><span class="line">  &#123;local&#125;: modified file</span><br><span class="line">  &#123;remote&#125;: modified file</span><br><span class="line">Hit return to start merge resolution tool (opendiff):</span><br></pre></td></tr></table></figure>
<p>如果你想使用除默认工具（在这里 Git 使用 <code>opendiff</code>
做为默认的合并工具，因为作者在 Mac
上运行该程序）外的其他合并工具，你可以在 “下列工具中（one of the
following tools）” 这句后面看到所有支持的合并工具。
然后输入你喜欢的工具名字就可以了。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>如果你需要更加高级的工具来解决复杂的合并冲突，我们会在 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_advanced_merging">高级合并</a>
介绍更多关于分支合并的内容。</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>等你退出合并工具之后，Git 会询问刚才的合并是否成功。
如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行
<code>git status</code> 来确认所有的合并冲突都已被解决：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use &quot;git commit&quot; to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line"></span><br><span class="line">    modified:   index.html</span><br></pre></td></tr></table></figure>
<p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入
<code>git commit</code> 来完成合并提交。
默认情况下提交信息看起来像下面这个样子：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &#x27;iss53&#x27;</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">    index.html</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># It looks like you may be committing a merge.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If this is not correct, please remove the file</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	.git/MERGE_HEAD</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and try again.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">with <span class="string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">All conflicts fixed but you are still merging.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Changes to be committed:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	modified:   index.html</span></span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure>
<p>如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息，添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。</p>
<h3 id="分支管理">分支管理</h3>
<p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p>
<p><code>git branch</code> 命令不只是可以创建与删除分支。
如果不加任何参数运行它，会得到当前所有分支的一个列表：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>
<p>注意 <code>master</code> 分支前的 <code>*</code>
字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code>
指针所指向的分支）。 这意味着如果在这时候提交，<code>master</code>
分支将会随着新的工作向前移动。
如果需要查看每一个分支的最后一次提交，可以运行
<code>git branch -v</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -v</span></span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch &#x27;iss53&#x27;</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure>
<p><code>--merged</code> 与 <code>--no-merged</code>
这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。
如果要查看哪些分支已经合并到当前分支，可以运行
<code>git branch --merged</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --merged</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>
<p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。
<strong>在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用
<code>git branch -d</code>
删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</strong></p>
<p>查看所有包含未合并工作的分支，可以运行
<code>git branch --no-merged</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --no-merged</span></span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>
<p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用
<code>git branch -d</code> 命令删除它时会失败：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d testing</span></span><br><span class="line">error: The branch &#x27;testing&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D testing&#x27;.</span><br></pre></td></tr></table></figure>
<p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用
<code>-D</code> 选项强制删除它。</p>
<h3 id="分支开发工作流">分支开发工作流</h3>
<p>现在你已经学会新建和合并分支，那么你可以或者应该用它来做些什么呢？
在本节，我们会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出这些典型的工作模式，你可以根据项目实际情况选择一种用用看。</p>
<h4 id="长期分支">长期分支</h4>
<p>因为 Git
使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。
也就是说，在整个项目开发周期的不同阶段，<strong>你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中</strong>。</p>
<p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在
<code>master</code>
分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。
他们还有一些名为 <code>develop</code> 或者 <code>next</code>
的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入
<code>master</code> 分支了。
这样，在确保这些已完成的特性分支（短期分支，比如之前的
<code>iss53</code> 分支）能够通过所有测试，并且不会引入更多 bug
之后，就可以合并入主干分支中，等待下一次的发布。</p>
<p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。
稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p>
<figure>
<img src="https://www.progit.cn/images/lr-branches-1.png"
alt="渐进稳定分支的线性图。" />
<figcaption aria-hidden="true">渐进稳定分支的线性图。</figcaption>
</figure>
<p>Figure 26. 渐进稳定分支的线性图</p>
<p>通常把他们想象成流水线（work
silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p>
<figure>
<img src="https://www.progit.cn/images/lr-branches-2.png"
alt="渐进稳定分支的工作流（“silo”）视图。" />
<figcaption
aria-hidden="true">渐进稳定分支的工作流（“silo”）视图。</figcaption>
</figure>
<p>Figure 27. 渐进稳定分支的流水线（“silo”）视图</p>
<p>你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个
<code>proposed</code>（建议） 或
<code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入
<code>next</code> 或者 <code>master</code> 分支。
这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。
再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</p>
<h4 id="特性分支">特性分支</h4>
<p>特性分支对任何规模的项目都适用。
特性分支是一种短期分支，<strong>它被用来实现单一特性或其相关工作</strong>。
也许你从来没有在其他的版本控制系统（<code>VCS</code>）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。
然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。</p>
<p>你已经在上一节中你创建的 <code>iss53</code> 和 <code>hotfix</code>
特性分支中看到过这种用法。 你在上一节用到的特性分支（<code>iss53</code>
和 <code>hotfix</code>
分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。
这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。
你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p>
<p>考虑这样一个例子，你在 <code>master</code> 分支上工作到
<code>C1</code>，这时为了解决一个问题而新建 <code>iss91</code> 分支，在
<code>iss91</code> 分支上工作到
<code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个
<code>iss91v2</code> 分支试图用另一种方法解决那个问题，接着你回到
<code>master</code>
分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 <code>C10</code>
的时候新建一个 <code>dumbidea</code> 分支，并在上面做些实验。
你的提交历史看起来像下面这个样子：</p>
<figure>
<img src="https://www.progit.cn/images/topic-branches-1.png"
alt="拥有多个特性分支的提交历史。" />
<figcaption aria-hidden="true">拥有多个特性分支的提交历史。</figcaption>
</figure>
<p>Figure 28. 拥有多个特性分支的提交历史</p>
<p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在
<code>iss91v2</code> 分支中方案；另外，你将 <code>dumbidea</code>
分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃
<code>iss91</code> 分支（即丢弃 <code>C5</code> 和 <code>C6</code>
提交），然后把另外两个分支合并入主干分支。
最终你的提交历史看起来像下面这个样子：</p>
<figure>
<img src="https://www.progit.cn/images/topic-branches-2.png"
alt="合并了 dumbidea 和 iss91v2 分支之后的提交历史。" />
<figcaption aria-hidden="true">合并了 <code>dumbidea</code> 和
<code>iss91v2</code> 分支之后的提交历史。</figcaption>
</figure>
<p>Figure 29. 合并了 <code>dumbidea</code> 和 <code>iss91v2</code>
分支之后的提交历史</p>
<p>我们将会在 <a target="_blank" rel="noopener" href="https://www.progit.cn/#_distributed_git">分布式
Git</a>
中向你揭示更多有关分支工作流的细节，因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching
scheme）。</p>
<p>请牢记，当你做这么多操作的时候，这些分支全部都存于本地。
当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 ——
没有与服务器发生交互。</p>
<h3 id="远程分支">远程分支</h3>
<p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过
<code>git ls-remote (remote)</code>
来显式地获得远程引用的完整列表，或者通过
<code>git remote show (remote)</code> 获得远程分支的更多信息。
然而，一个更常见的做法是利用远程跟踪分支。</p>
<p>远程跟踪分支是远程分支状态的引用。
它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。
远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。</p>
<p>它们以 <code>(remote)/(branch)</code> 形式命名。
例如，如果你想要看你最后一次与远程仓库 <code>origin</code> 通信时
<code>master</code> 分支的状态，你可以查看 <code>origin/master</code>
分支。 你与同事合作解决一个问题并且他们推送了一个 <code>iss53</code>
分支，你可能有自己的本地 <code>iss53</code>
分支；但是在服务器上的分支会指向 <code>origin/iss53</code> 的提交。</p>
<p>这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在
<code>git.ourcompany.com</code> 的 Git 服务器。 如果你从这里克隆，Git 的
<code>clone</code> 命令会为你自动将其命名为
<code>origin</code>，拉取它的所有数据，创建一个指向它的
<code>master</code> 分支的指针，并且在本地将其命名为
<code>origin/master</code>。 Git 也会给你一个与 origin 的
<code>master</code> 分支在指向同一个地方的本地 <code>master</code>
分支，这样你就有工作的基础。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>“origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master”
一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行
<code>git init</code>
时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行
<code>git clone</code> 时默认的远程仓库名字。 如果你运行
<code>git clone -o booyah</code>，那么你默认的远程分支名字将会是
<code>booyah/master</code>。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure>
<img src="https://www.progit.cn/images/remote-branches-1.png"
alt="克隆之后的服务器与本地仓库。" />
<figcaption aria-hidden="true">克隆之后的服务器与本地仓库。</figcaption>
</figure>
<p>Figure 30. 克隆之后的服务器与本地仓库</p>
<p>如果你在本地的 <code>master</code>
分支做了一些工作，然而在同一时间，其他人推送提交到
<code>git.ourcompany.com</code> 并更新了它的 <code>master</code>
分支，那么你的提交历史将向不同的方向前进。 也许，只要你不与 origin
服务器连接，你的 <code>origin/master</code> 指针就不会移动。</p>
<figure>
<img src="https://www.progit.cn/images/remote-branches-2.png"
alt="本地与远程的工作可以分叉。" />
<figcaption aria-hidden="true">本地与远程的工作可以分叉。</figcaption>
</figure>
<p>Figure 31. 本地与远程的工作可以分叉</p>
<p>如果要同步你的工作，运行 <code>git fetch origin</code> 命令。
这个命令查找 “origin” 是哪一个服务器（在本例中，它是
<code>git.ourcompany.com</code>），从中抓取本地没有的数据，并且更新本地数据库，移动
<code>origin/master</code> 指针指向新的、更新后的位置。</p>
<figure>
<img src="https://www.progit.cn/images/remote-branches-3.png"
alt="git fetch 更新你的远程仓库引用。" />
<figcaption aria-hidden="true"><code>git fetch</code>
更新你的远程仓库引用。</figcaption>
</figure>
<p>Figure 32. <code>git fetch</code> 更新你的远程仓库引用</p>
<p>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git
服务器，仅用于你的 sprint 小组的开发工作。 这个服务器位于
<code>git.team1.ourcompany.com</code>。 你可以运行
<code>git remote add</code>
命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_git_basics_chapter">Git 基础</a>
中详细说明。 将这个远程仓库命名为 <code>teamone</code>，将其作为整个 URL
的缩写。</p>
<figure>
<img src="https://www.progit.cn/images/remote-branches-4.png"
alt="添加另一个远程仓库。" />
<figcaption aria-hidden="true">添加另一个远程仓库。</figcaption>
</figure>
<p>Figure 33. 添加另一个远程仓库</p>
<p>现在，可以运行 <code>git fetch teamone</code> 来抓取远程仓库
<code>teamone</code> 有而本地没有的数据。 因为那台服务器上现有的数据是
<code>origin</code> 服务器上的一个子集，所以 Git
并不会抓取数据而是会设置远程跟踪分支 <code>teamone/master</code> 指向
<code>teamone</code> 的 <code>master</code> 分支。</p>
<figure>
<img src="https://www.progit.cn/images/remote-branches-5.png"
alt="远程跟踪分支 teamone/master。" />
<figcaption aria-hidden="true">远程跟踪分支
<code>teamone/master</code>。</figcaption>
</figure>
<p>Figure 34. 远程跟踪分支 <code>teamone/master</code></p>
<h4 id="推送">推送</h4>
<p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。
本地的分支并不会自动与远程仓库同步 - 你必须显式地推送想要分享的分支。
这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p>
<p>如果希望和别人一起在名为 <code>serverfix</code>
的分支上工作，你可以像推送第一个分支那样推送它。 运行
<code>git push (remote) (branch)</code>:</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin serverfix</span></span><br><span class="line">Counting objects: 24, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.</span><br><span class="line">Total 24 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure>
<p>这里有些工作被简化了。 Git 自动将 <code>serverfix</code>
分支名字展开为
<code>refs/heads/serverfix:refs/heads/serverfix</code>，那意味着，“推送本地的
serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_git_internals">Git 内部原理</a> 的
<code>refs/heads/</code> 部分，但是现在可以先把它放在儿。 你也可以运行
<code>git push origin serverfix:serverfix</code>，它会做同样的事 -
相当于它说，“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix
分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。
如果并不想让远程仓库上的分支叫做 <code>serverfix</code>，可以运行
<code>git push origin serverfix:awesomebranch</code> 来将本地的
<code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code>
分支。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>如何避免每次输入密码如果你正在使用 HTTPS URL 来推送，Git
服务器会询问用户名与密码。
默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，你可以设置一个
“credential cache”。
最简单的方式就是将其保存在内存中几分钟，可以简单地运行
<code>git config --global credential.helper cache</code>
来设置它。想要了解更多关于不同验证缓存的可用选项，查看 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_credential_caching">凭证存储</a>。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支
<code>origin/serverfix</code>，指向服务器的 <code>serverfix</code>
分支的引用：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch origin</span></span><br><span class="line">remote: Counting objects: 7, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix    -&gt; origin/serverfix</span><br></pre></td></tr></table></figure>
<p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。
换一句话说，这种情况下，不会有一个新的 <code>serverfix</code> 分支 -
只有一个不可以修改的 <code>origin/serverfix</code> 指针。</p>
<p>可以运行 <code>git merge origin/serverfix</code>
将这些工作合并到当前所在的分支。 如果想要在自己的 <code>serverfix</code>
分支上工作，可以将其建立在远程跟踪分支之上：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b serverfix origin/serverfix</span></span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure>
<p>这会给你一个用于工作的本地分支，并且起点位于
<code>origin/serverfix</code>。</p>
<h4 id="跟踪分支">跟踪分支</h4>
<p>从一个远程跟踪分支检出一个本地分支会自动创建一个叫做
“跟踪分支”（有时候也叫做 “上游分支”）。
跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入
<code>git pull</code>，Git
能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪
<code>origin/master</code> 的 <code>master</code> 分支。
然而，如果你愿意的话可以设置其他的跟踪分支 -
其他远程仓库上的跟踪分支，或者不跟踪 <code>master</code> 分支。
最简单的就是之前看到的例子，运行
<code>git checkout -b [branch] [remotename]/[branch]</code>。
这是一个十分常用的操作所以 Git 提供了 <code>--track</code>
快捷方式：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout --track origin/serverfix</span></span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure>
<p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地增加一个不同名字的本地分支的上一个命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b sf origin/serverfix</span></span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;sf&#x27;</span><br></pre></td></tr></table></figure>
<p>现在，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code>
拉取。</p>
<p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用
<code>-u</code> 或 <code>--set-upstream-to</code> 选项运行
<code>git branch</code> 来显式地设置。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -u origin/serverfix</span></span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>上游快捷方式当设置好跟踪分支后，可以通过 <code>@&#123;upstream&#125;</code> 或
<code>@&#123;u&#125;</code> 快捷方式来引用它。 所以在 <code>master</code>
分支时并且它正在跟踪 <code>origin/master</code> 时，如果愿意的话可以使用
<code>git merge @&#123;u&#125;</code> 来取代
<code>git merge origin/master</code>。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的
<code>-vv</code> 选项。
这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -vv</span></span><br><span class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure>
<p>这里可以看到 <code>iss53</code> 分支正在跟踪
<code>origin/iss53</code> 并且 “ahead” 是
2，意味着本地有两个提交还没有推送到服务器上。 也能看到
<code>master</code> 分支正在跟踪 <code>origin/master</code>
分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪
<code>teamone</code> 服务器上的 <code>server-fix-good</code>
分支并且领先 2 落后
1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。
最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p>
<p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。
这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。
如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。
可以像这样做：<code>$ git fetch --all; git branch -vv</code></p>
<h4 id="拉取">拉取</h4>
<p>当 <code>git fetch</code>
命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。
它只会获取数据然后让你自己合并。 然而，有一个命令叫作
<code>git pull</code> 在大多数情况下它的含义是一个
<code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。
如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过
<code>clone</code> 或 <code>checkout</code>
命令为你创建的，<code>git pull</code>
都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p>
<p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用
<code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p>
<h4 id="删除远程分支">删除远程分支</h4>
<p>假设你已经通过远程分支做完所有的工作了 -
也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的
<code>master</code> 分支（或任何其他稳定代码分支）。 可以运行带有
<code>--delete</code> 选项的 <code>git push</code>
命令来删除一个远程分支。 如果想要从服务器上删除 <code>serverfix</code>
分支，运行下面的命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete serverfix</span></span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure>
<p>基本上这个命令做的只是从服务器上移除这个指针。 Git
服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<h3 id="变基">变基</h3>
<p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code>
以及 <code>rebase</code>。
在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p>
<h4 id="变基的基本操作">变基的基本操作</h4>
<p>请回顾之前在 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_basic_merging">分支的合并</a>
中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p>
<figure>
<img src="https://www.progit.cn/images/basic-rebase-1.png"
alt="分叉的提交历史。" />
<figcaption aria-hidden="true">分叉的提交历史。</figcaption>
</figure>
<p>Figure 35. 分叉的提交历史</p>
<p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。
它会把两个分支的最新快照（<code>C3</code> 和
<code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p>
<figure>
<img src="https://www.progit.cn/images/basic-rebase-2.png"
alt="通过合并操作来整合分叉了的历史。" />
<figcaption
aria-hidden="true">通过合并操作来整合分叉了的历史。</figcaption>
</figure>
<p>Figure 36. 通过合并操作来整合分叉了的历史</p>
<p>其实，还有一种方法：你可以提取在 <code>C4</code>
中引入的补丁和修改，然后在 <code>C3</code> 的基础上应用一次。 在 Git
中，这种操作就叫做 <em>变基</em>。 你可以使用 <code>rebase</code>
命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p>
<p>在上面这个例子中，运行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout experiment</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master</span></span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br></pre></td></tr></table></figure>
<p>它的原理是首先找到这两个分支（即当前分支
<code>experiment</code>、变基操作的目标基底分支
<code>master</code>）的最近共同祖先
<code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底
<code>C3</code>,
最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit
id，以便理解，下同）</p>
<figure>
<img src="https://www.progit.cn/images/basic-rebase-3.png"
alt="将 C4 中的修改变基到 C3 上。" />
<figcaption aria-hidden="true">将 <code>C4</code> 中的修改变基到
<code>C3</code> 上。</figcaption>
</figure>
<p>Figure 37. 将 <code>C4</code> 中的修改变基到 <code>C3</code> 上</p>
<p>现在回到 <code>master</code> 分支，进行一次快进合并。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge experiment</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/basic-rebase-4.png"
alt="master 分支的快进合并。" />
<figcaption aria-hidden="true">master 分支的快进合并。</figcaption>
</figure>
<p>Figure 38. master 分支的快进合并</p>
<p>此时，<code>C4'</code> 指向的快照就和上面使用 <code>merge</code>
命令的例子中 <code>C5</code> 指向的快照一模一样了。
这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。
你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p>
<p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。
在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到
<code>origin/master</code> 上，然后再向主项目提交修改。
这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p>
<p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。
变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>
<h4 id="更有趣的变基例子">更有趣的变基例子</h4>
<p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。
就像 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#rbdiag_e">从一个特性分支里再分出一个特性分支的提交历史</a>
中的例子那样。 你创建了一个特性分支
<code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和
<code>C4</code>。 然后从 <code>C3</code> 上创建了特性分支
<code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和
<code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了
<code>C10</code>。</p>
<figure>
<img src="https://www.progit.cn/images/interesting-rebase-1.png"
alt="从一个特性分支里再分出一个特性分支的提交历史。" />
<figcaption
aria-hidden="true">从一个特性分支里再分出一个特性分支的提交历史。</figcaption>
</figure>
<p>Figure 39. 从一个特性分支里再分出一个特性分支的提交历史</p>
<p>假设你希望将 <code>client</code>
中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code>
中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用
<code>git rebase</code> 命令的 <code>--onto</code> 选项，选中在
<code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即
<code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code>
分支上重放：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase --onto master server client</span></span><br></pre></td></tr></table></figure>
<p>以上命令的意思是：“取出 <code>client</code> 分支，找出处于
<code>client</code> 分支和 <code>server</code>
分支的共同祖先之后的修改，然后把它们在 <code>master</code>
分支上重放一遍”。 这理解起来有一点复杂，不过效果非常酷。</p>
<figure>
<img src="https://www.progit.cn/images/interesting-rebase-2.png"
alt="截取特性分支上的另一个特性分支，然后变基到其他分支。" />
<figcaption
aria-hidden="true">截取特性分支上的另一个特性分支，然后变基到其他分支。</figcaption>
</figure>
<p>Figure 40. 截取特性分支上的另一个特性分支，然后变基到其他分支</p>
<p>现在可以快进合并 <code>master</code> 分支了。（如图 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#rbdiag_g">快进合并 master
分支，使之包含来自 client 分支的修改</a>）：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge client</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/interesting-rebase-3.png"
alt="快进合并 master 分支，使之包含来自 client 分支的修改。" />
<figcaption aria-hidden="true">快进合并 master 分支，使之包含来自 client
分支的修改。</figcaption>
</figure>
<p>Figure 41. 快进合并 master 分支，使之包含来自 client 分支的修改</p>
<p>接下来你决定将 <code>server</code> 分支中的修改也整合进来。 使用
<code>git rebase [basebranch] [topicbranch]</code>
命令可以直接将特性分支（即本例中的
<code>server</code>）变基到目标分支（即
<code>master</code>）上。这样做能省去你先切换到 <code>server</code>
分支，再对其执行变基命令的多个步骤。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master server</span></span><br></pre></td></tr></table></figure>
<p>如图 <a target="_blank" rel="noopener" href="https://www.progit.cn/#rbdiag_h">将 server
中的修改变基到 master 上</a> 所示，<code>server</code>
中的代码被“续”到了 <code>master</code> 后面。</p>
<figure>
<img src="https://www.progit.cn/images/interesting-rebase-4.png"
alt="将 server 中的修改变基到 master 上。" />
<figcaption aria-hidden="true">将 server 中的修改变基到 master
上。</figcaption>
</figure>
<p>Figure 42. 将 server 中的修改变基到 master 上</p>
<p>然后就可以快进合并主分支 master 了：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge server</span></span><br></pre></td></tr></table></figure>
<p>至此，<code>client</code> 和 <code>server</code>
分支中的修改都已经整合到主分支里了，你可以删除这两个分支，最终提交历史会变成图
<a target="_blank" rel="noopener" href="https://www.progit.cn/#rbdiag_i">最终的提交历史</a>
中的样子：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d client</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d server</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/interesting-rebase-5.png"
alt="最终的提交历史。" />
<figcaption aria-hidden="true">最终的提交历史。</figcaption>
</figure>
<p>Figure 43. 最终的提交历史</p>
<h4 id="变基的风险">变基的风险</h4>
<p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p>
<p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p>
<p>如果你遵循这条金科玉律，就不会出差错。
否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>
<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。
如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用
<code>git rebase</code>
命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>
<p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。
假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。
你的提交历史如图所示：</p>
<figure>
<img src="https://www.progit.cn/images/perils-of-rebasing-1.png"
alt="克隆一个仓库，然后在它的基础上进行了一些开发。" />
<figcaption
aria-hidden="true">克隆一个仓库，然后在它的基础上进行了一些开发。</figcaption>
</figure>
<p>Figure 44. 克隆一个仓库，然后在它的基础上进行了一些开发</p>
<p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。
你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p>
<figure>
<img src="https://www.progit.cn/images/perils-of-rebasing-2.png"
alt="抓取别人的提交，合并到自己的开发分支。" />
<figcaption
aria-hidden="true">抓取别人的提交，合并到自己的开发分支。</figcaption>
</figure>
<p>Figure 45. 抓取别人的提交，合并到自己的开发分支</p>
<p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用
<code>git push --force</code> 命令覆盖了服务器上的提交历史。
之后你从服务器抓取更新，会发现多出来一些新的提交。</p>
<figure>
<img src="https://www.progit.cn/images/perils-of-rebasing-3.png"
alt="有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。" />
<figcaption
aria-hidden="true">有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。</figcaption>
</figure>
<p>Figure 46.
有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</p>
<p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code>
命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p>
<figure>
<img src="https://www.progit.cn/images/perils-of-rebasing-4.png"
alt="你将相同的内容又合并了一次，生成了一个新的提交。" />
<figcaption
aria-hidden="true">你将相同的内容又合并了一次，生成了一个新的提交。</figcaption>
</figure>
<p>Figure 47. 你将相同的内容又合并了一次，生成了一个新的提交</p>
<p>此时如果你执行 <code>git log</code>
命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。
此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。
很明显对方并不想在提交历史中看到 <code>C4</code> 和
<code>C6</code>，因为之前就是他把这两个提交通过变基丢弃的。</p>
<h4 id="用变基解决变基">用变基解决变基</h4>
<p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git
还有一些高级魔法可以帮到你。
如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p>
<p>实际上，Git 除了对整个提交计算 SHA-1
校验和以外，也对本次提交所引入的修改计算了校验和—— 即 “patch-id”。</p>
<p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下
Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p>
<p>举个例子，如果遇到前面提到的 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_pre_merge_rebase_work">有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</a>
那种情境，如果我们不是执行合并，而是执行
<code>git rebase teamone/master</code>, Git 将会：</p>
<ul>
<li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li>
<li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li>
<li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和
C3，因为 C4 其实就是 C4'）</li>
<li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li>
</ul>
<p>从而我们将得到与 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_merge_rebase_work">你将相同的内容又合并了一次，生成了一个新的提交</a>
中不同的结果，如图 <a
target="_blank" rel="noopener" href="https://www.progit.cn/#_rebase_rebase_work">在一个被变基然后强制推送的分支上再次执行变基</a>
所示。</p>
<figure>
<img src="https://www.progit.cn/images/perils-of-rebasing-5.png"
alt="在一个被变基然后强制推送的分支上再次执行变基。" />
<figcaption
aria-hidden="true">在一个被变基然后强制推送的分支上再次执行变基。</figcaption>
</figure>
<p>Figure 48. 在一个被变基然后强制推送的分支上再次执行变基</p>
<p>要想上述方案有效，还需要对方在变基时确保 C4' 和 C4 是几乎一样的。
否则变基操作将无法识别，并新建另一个类似 C4
的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p>
<p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code>
命令而不是直接 <code>git pull</code>。
又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再
<code>git rebase teamone/master</code>。</p>
<p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项
<code>--rebase</code>，你可以执行这条语句
<code>git config --global pull.rebase true</code> 来更改
<code>pull.rebase</code> 的默认配置。</p>
<p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，就不会有事。
假如在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。</p>
<p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行
<code>git pull --rebase</code>
命令，这样尽管不能避免伤痛，但能有所缓解。</p>
<h4 id="变基-vs.-合并">变基 vs. 合并</h4>
<p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。
在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p>
<p>有一种观点认为，仓库的提交历史即是
<strong>记录实际发生过什么</strong>。
它是针对历史的文档，本身就有价值，不能乱改。
从这个角度看来，改变提交历史是一种亵渎，你使用_谎言_掩盖了实际发生过的事情。
如果由合并产生的提交历史是一团糟怎么办？
既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p>
<p>另一种观点则正好相反，他们认为提交历史是
<strong>项目过程中发生的事</strong>。
没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。
持这一观点的人会使用 rebase 及 filter-branch
等工具来编写故事，怎么方便后来的读者就怎么写。</p>
<p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。
Git
是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。
既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p>
<p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>
<h3 id="总结-1">总结</h3>
<p>我们已经讲完了 Git 分支与合并的基础知识。
你现在应该能自如地创建并切换至新分支、在不同分支之间切换以及合并本地分支。
你现在应该也能通过推送你的分支至共享服务以分享它们、使用共享分支与他人协作以及在共享之前使用变基操作合并你的分支。
下一章，我们将要讲到，如果你想要运行自己的 Git
仓库托管服务器，你需要知道些什么。</p>

    </div>

    
    
    
        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"># 读书笔记</a>
              <a href="/tags/OO/" rel="tag"># OO</a>
              <a href="/tags/Git/" rel="tag"># Git</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/subject3/" rel="prev" title="科目三实战技巧">
      <i class="fa fa-chevron-left"></i> 科目三实战技巧
    </a></div>
      <div class="post-nav-item">
    <a href="/combinational-logic-concerning-clock/" rel="next" title="时钟参与组合逻辑的心得">
      时钟参与组合逻辑的心得 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%B7%E6%AD%A5"><span class="nav-number">1.</span> <span class="nav-text">起步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E9%87%8D%E8%A6%81%E7%9A%84part"><span class="nav-number">1.1.</span> <span class="nav-text">不重要的part</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-%E5%9F%BA%E7%A1%80%E4%BD%86%E6%88%91%E8%AE%A4%E4%B8%BA%E5%8F%ABgit%E5%8E%9F%E7%90%86%E6%9B%B4%E5%A5%BD%E4%BA%9B"><span class="nav-number">1.2.</span> <span class="nav-text">Git
基础（但我认为叫Git原理更好些）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%AE%B0%E5%BD%95%E5%BF%AB%E7%85%A7"><span class="nav-number">1.2.1.</span> <span class="nav-text">直接记录快照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.2.</span> <span class="nav-text">本地执行操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="nav-number">1.2.3.</span> <span class="nav-text">保证完整性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.4.</span> <span class="nav-text">只添加数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.5.</span> <span class="nav-text">三种状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#the-three-states"><span class="nav-number">1.2.6.</span> <span class="nav-text">The Three States</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="nav-number">1.3.</span> <span class="nav-text">命令行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">1.4.</span> <span class="nav-text">初次运行 Git 前的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="nav-number">1.4.1.</span> <span class="nav-text">用户信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">文本编辑器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="nav-number">1.4.3.</span> <span class="nav-text">检查配置信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%B8%AE%E5%8A%A9"><span class="nav-number">1.5.</span> <span class="nav-text">获取帮助</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git-%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">Git 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-git-%E4%BB%93%E5%BA%93"><span class="nav-number">2.1.</span> <span class="nav-text">获取 Git 仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%8E%B0%E6%9C%89%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%93%E5%BA%93"><span class="nav-number">2.1.1.</span> <span class="nav-text">在现有目录中初始化仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%8B%E9%9A%86%E7%8E%B0%E6%9C%89%E7%9A%84%E4%BB%93%E5%BA%93"><span class="nav-number">2.1.2.</span> <span class="nav-text">克隆现有的仓库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93"><span class="nav-number">2.2.</span> <span class="nav-text">记录更新到仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="nav-number">2.2.1.</span> <span class="nav-text">检查当前文件状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%9F%E8%B8%AA%E6%96%B0%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.2.</span> <span class="nav-text">跟踪新文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9A%82%E5%AD%98%E5%B7%B2%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.3.</span> <span class="nav-text">暂存已修改文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%AE%80%E8%A7%88"><span class="nav-number">2.2.4.</span> <span class="nav-text">状态简览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.5.</span> <span class="nav-text">忽略文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E6%9A%82%E5%AD%98%E5%92%8C%E6%9C%AA%E6%9A%82%E5%AD%98%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">2.2.6.</span> <span class="nav-text">查看已暂存和未暂存的修改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0"><span class="nav-number">2.2.7.</span> <span class="nav-text">提交更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%BF%87%E4%BD%BF%E7%94%A8%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">2.2.8.</span> <span class="nav-text">跳过使用暂存区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.9.</span> <span class="nav-text">移除文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.10.</span> <span class="nav-text">移动文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2"><span class="nav-number">2.3.</span> <span class="nav-text">查看提交历史</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E8%BE%93%E5%87%BA%E9%95%BF%E5%BA%A6"><span class="nav-number">2.3.1.</span> <span class="nav-text">限制输出长度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%92%A4%E6%B6%88%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.</span> <span class="nav-text">撤消操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%96%E6%B6%88%E6%9A%82%E5%AD%98%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">2.4.1.</span> <span class="nav-text">取消暂存的文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%92%A4%E6%B6%88%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">2.4.2.</span> <span class="nav-text">撤消对文件的修改</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.5.</span> <span class="nav-text">远程仓库的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">2.5.1.</span> <span class="nav-text">查看远程仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">2.5.2.</span> <span class="nav-text">添加远程仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%AD%E6%8A%93%E5%8F%96%E4%B8%8E%E6%8B%89%E5%8F%96"><span class="nav-number">2.5.3.</span> <span class="nav-text">从远程仓库中抓取与拉取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">2.5.4.</span> <span class="nav-text">推送到远程仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93-1"><span class="nav-number">2.5.5.</span> <span class="nav-text">查看远程仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E7%A7%BB%E9%99%A4%E4%B8%8E%E9%87%8D%E5%91%BD%E5%90%8D"><span class="nav-number">2.5.6.</span> <span class="nav-text">远程仓库的移除与重命名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.</span> <span class="nav-text">打标签</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E5%87%BA%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.1.</span> <span class="nav-text">列出标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.2.</span> <span class="nav-text">创建标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%84%E6%B3%A8%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.3.</span> <span class="nav-text">附注标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.4.</span> <span class="nav-text">轻量标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E6%9C%9F%E6%89%93%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.5.</span> <span class="nav-text">后期打标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.6.</span> <span class="nav-text">共享标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E5%87%BA%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.7.</span> <span class="nav-text">检出标签</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-%E5%88%AB%E5%90%8D"><span class="nav-number">2.7.</span> <span class="nav-text">Git 别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git-%E5%88%86%E6%94%AF"><span class="nav-number">3.</span> <span class="nav-text">Git 分支</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B"><span class="nav-number">3.1.</span> <span class="nav-text">分支简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%88%9B%E5%BB%BA"><span class="nav-number">3.1.1.</span> <span class="nav-text">分支创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%88%87%E6%8D%A2"><span class="nav-number">3.1.2.</span> <span class="nav-text">分支切换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6"><span class="nav-number">3.2.</span> <span class="nav-text">分支的新建与合并</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF"><span class="nav-number">3.2.1.</span> <span class="nav-text">新建分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-number">3.2.2.</span> <span class="nav-text">分支的合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%87%E5%88%B0%E5%86%B2%E7%AA%81%E6%97%B6%E7%9A%84%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6"><span class="nav-number">3.2.3.</span> <span class="nav-text">遇到冲突时的分支合并</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">分支管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">3.4.</span> <span class="nav-text">分支开发工作流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%BF%E6%9C%9F%E5%88%86%E6%94%AF"><span class="nav-number">3.4.1.</span> <span class="nav-text">长期分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%80%A7%E5%88%86%E6%94%AF"><span class="nav-number">3.4.2.</span> <span class="nav-text">特性分支</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">3.5.</span> <span class="nav-text">远程分支</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A8%E9%80%81"><span class="nav-number">3.5.1.</span> <span class="nav-text">推送</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%9F%E8%B8%AA%E5%88%86%E6%94%AF"><span class="nav-number">3.5.2.</span> <span class="nav-text">跟踪分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%89%E5%8F%96"><span class="nav-number">3.5.3.</span> <span class="nav-text">拉取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">3.5.4.</span> <span class="nav-text">删除远程分支</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA"><span class="nav-number">3.6.</span> <span class="nav-text">变基</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">3.6.1.</span> <span class="nav-text">变基的基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8F%98%E5%9F%BA%E4%BE%8B%E5%AD%90"><span class="nav-number">3.6.2.</span> <span class="nav-text">更有趣的变基例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="nav-number">3.6.3.</span> <span class="nav-text">变基的风险</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E5%8F%98%E5%9F%BA%E8%A7%A3%E5%86%B3%E5%8F%98%E5%9F%BA"><span class="nav-number">3.6.4.</span> <span class="nav-text">用变基解决变基</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA-vs.-%E5%90%88%E5%B9%B6"><span class="nav-number">3.6.5.</span> <span class="nav-text">变基 vs. 合并</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">3.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="StrivingLee"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">StrivingLee</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/StrivingLee" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;StrivingLee" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:735260209@qq.com" title="E-Mail → mailto:735260209@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://augetyvolta.github.io/" title="https:&#x2F;&#x2F;augetyvolta.github.io&#x2F;" rel="noopener" target="_blank">King's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://volcaxiao.top/" title="http:&#x2F;&#x2F;volcaxiao.top&#x2F;" rel="noopener" target="_blank">Volca's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cajzella.cn/" title="https:&#x2F;&#x2F;www.cajzella.cn&#x2F;" rel="noopener" target="_blank">🍊's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://yanna-zy.gitee.io/" title="http:&#x2F;&#x2F;yanna-zy.gitee.io&#x2F;" rel="noopener" target="_blank">Yanna's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://frankie-dejong.github.io/" title="https:&#x2F;&#x2F;frankie-dejong.github.io&#x2F;" rel="noopener" target="_blank">Scott's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://einestages.github.io/" title="https:&#x2F;&#x2F;einestages.github.io&#x2F;" rel="noopener" target="_blank">Blackening's Blog</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">StrivingLee</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">156k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">6:30</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>




  <script>
    (function(d, w, c) {
      w.ChatraID = '';
      var s = d.createElement('script');
      w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
      };
      s.async = true;
      s.src = 'https://call.chatra.io/chatra.js';
      if (d.head) d.head.appendChild(s);
    })(document, window, 'Chatra');
  </script>









  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>
</html>
