<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-avatar-medium.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-avatar-small.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"strivinglee.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":"default","style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="2023 春组合数学笔记，全部资料参见我的 Github Click here to see the remote repository)">
<meta property="og:type" content="article">
<meta property="og:title" content="组合数学笔记">
<meta property="og:url" content="https://strivinglee.github.io/combinatorics-notes/index.html">
<meta property="og:site_name" content="StrivingLee&#39;s Blog">
<meta property="og:description" content="2023 春组合数学笔记，全部资料参见我的 Github Click here to see the remote repository)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://strivinglee.github.io/combinatorics-notes/Images/FaultLine.jpg">
<meta property="og:image" content="https://strivinglee.github.io/combinatorics-notes/Images/Circle.png">
<meta property="og:image" content="c:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611105033290.png">
<meta property="og:image" content="https://strivinglee.github.io/combinatorics-notes/Images/RecursiveGray.png">
<meta property="og:image" content="c:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230608105305919.png">
<meta property="og:image" content="c:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230608111421566.png">
<meta property="og:image" content="c:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611115437992.png">
<meta property="og:image" content="c:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230608114453735.png">
<meta property="og:image" content="c:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611140632902.png">
<meta property="og:image" content="c:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611210113545.png">
<meta property="og:image" content="c:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611213804336.png">
<meta property="og:image" content="c:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611213914755.png">
<meta property="og:image" content="c:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611221943614.png">
<meta property="og:image" content="c:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230613133725520.png">
<meta property="article:published_time" content="2023-06-27T19:19:57.878Z">
<meta property="article:modified_time" content="2023-10-04T04:58:36.406Z">
<meta property="article:author" content="StrivingLee">
<meta property="article:tag" content="Notes">
<meta property="article:tag" content="Combinatorics">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://strivinglee.github.io/combinatorics-notes/Images/FaultLine.jpg">

<link rel="canonical" href="https://strivinglee.github.io/combinatorics-notes/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>组合数学笔记 | StrivingLee's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">StrivingLee's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">揉合生命千样好</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">21</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/StrivingLee" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://strivinglee.github.io/combinatorics-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="StrivingLee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StrivingLee's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/combinatorics-notes" class="post-title-link post-title-link-external" itemprop="url">组合数学笔记<i class="fa fa-external-link-alt"></i></a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-28 03:19:57" itemprop="dateCreated datePublished" datetime="2023-06-28T03:19:57+08:00">2023-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-04 12:58:36" itemprop="dateModified" datetime="2023-10-04T12:58:36+08:00">2023-10-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/" itemprop="url" rel="index"><span itemprop="name">Mathematics</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/S4/" itemprop="url" rel="index"><span itemprop="name">S4</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>39k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1:37</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>2023 春组合数学笔记，全部资料参见我的 Github <a
target="_blank" rel="noopener" href="https://github.com/StrivingLee/Introductory-Combinatorics">Click
here to see the remote repository</a>)</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>总思路：存在 <span class="math inline">\(\rightarrow\)</span> 计数
<span class="math inline">\(\rightarrow\)</span> 算法 <span
class="math inline">\(\rightarrow\)</span> 优化</p>
</blockquote>
<h3 id="timeline">TimeLine</h3>
<p>Created: 2023.05.09</p>
<p>Maximum change: 2023.06.09</p>
<p>Finish: 2023.06.13</p>
<h3 id="第1章-引论">第1章 引论</h3>
<h4 id="例1幻方">例1：幻方</h4>
<p><span class="math inline">\(2\)</span> 阶幻方不存在，对于任意 $n &gt;
3 $ 的整数 <span class="math inline">\(n\)</span>，都存在一个 <span
class="math inline">\(n\)</span> 阶幻方</p>
<h4 id="例236-军官问题">例2：<span class="math inline">\(36\)</span>
军官问题</h4>
<h4 id="例3完美覆盖问题">例3：完美覆盖问题</h4>
<h4 id="一般化">一般化：</h4>
<p>$ m n $ 棋盘被 <span class="math inline">\(b\)</span> -
牌完美覆盖，当且仅当 <span class="math inline">\(b\)</span> 是 <span
class="math inline">\(m\)</span> 或 <span
class="math inline">\(n\)</span> 的一个因子</p>
<h4 id="延伸问题断层线-fault-line">延伸问题：断层线 (Fault Line)</h4>
<p><span class="math inline">\(4 \times 4\)</span> 棋盘用 <span
class="math inline">\(8\)</span>
张多米诺牌完美覆盖，证明：总可以将这个棋盘横向或纵向分成非空两个部分，且没有牌被切断</p>
<p><img src="Images\FaultLine.jpg" alt="FaultLine" style="zoom: 33%;" /></p>
<h4 id="例4相互重叠的圆递推公式">例4：相互重叠的圆（递推公式）</h4>
<p>设这 <span class="math inline">\(h_n\)</span> 个圆将平面分为 <span
class="math inline">\(m\)</span> 个区域，当加入第 <span
class="math inline">\(n\)</span> 个圆时，这个圆与前面 <span
class="math inline">\(n-1\)</span> 个圆交于 <span
class="math inline">\(2(n-1)\)</span> 个点，这 <span
class="math inline">\(2(n-1)\)</span> 个点把第 <span
class="math inline">\(n\)</span> 个圆分成 <span
class="math inline">\(2(n-1)\)</span> 条弧，每条弧将其经过的区域分成
<span class="math inline">\(2\)</span> 个区域（在前面的 <span
class="math inline">\(n-1\)</span> 个圆分成的区域中），故新加入的第
<span class="math inline">\(n\)</span> 个圆使区域数增加了 <span
class="math inline">\(2(n-1)\)</span></p>
<p>建立递推关系如下： <span class="math display">\[
h_n = h_{n-1} + 2(n-1) (n \geq 2) \\ h_1 = 2
\]</span></p>
<blockquote>
<p>解决问题的一般顺序：求通项 <span
class="math inline">\(\rightarrow\)</span> 求递推公式 <span
class="math inline">\(\rightarrow\)</span> 诉诸生成函数</p>
</blockquote>
<h4 id="例5nim-取子游戏">例5：<span class="math inline">\(Nim\)</span>
取子游戏</h4>
<p>有 <span class="math inline">\(k(\geq 1)\)</span> 堆石子，分别含有
<span class="math inline">\(n_1,n_2,\dots, n_k\)</span> 个子</p>
<p>游戏规则:</p>
<ul>
<li>游戏人 <span class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 交替从这些堆里取一定数量石子</li>
<li>取子时，只能选择其中一堆，并且取至少一个石子</li>
<li>最后取完子的人为胜者</li>
</ul>
<p>定义：<span class="math inline">\(n_1, n_2, \dots, n_k\)</span>
是正整数，若它们的二进制数码的<strong>异或值</strong>为 <span
class="math inline">\(0\)</span>，则称它们处于<strong>平衡状态</strong>，否则处于<strong>非平衡状态</strong></p>
<p>结论：<span class="math inline">\(A\)</span> 能在非平衡的 <span
class="math inline">\(Nim\)</span> 取子中获胜，而 <span
class="math inline">\(B\)</span> 能在平衡的 <span
class="math inline">\(Nim\)</span> 取子中获胜</p>
<h3 id="第2章-排列与组合"><strong>第2章 排列与组合</strong></h3>
<h4 id="个基本的计数原理">2.1：4个基本的计数原理</h4>
<ul>
<li>加法原理、乘法原理、减法原理、除法原理
<ul>
<li>例：确定数 <span class="math inline">\(3^4 \times 5^2 \times 11^7
\times 13^8\)</span> 的正整数因子的个数（<strong>注意每个因子取 <span
class="math inline">\(0\)</span> 次！！！</strong>因为 <span
class="math inline">\(1\)</span> 也是因子）</li>
<li>解：由乘法原理，<span class="math inline">\(5 \times 3 \times 8
\times 9\)</span></li>
</ul></li>
</ul>
<h4 id="集合的排列">2.2：集合的排列</h4>
<ul>
<li><p>从 <span class="math inline">\(n\)</span> 个不同元素取出 <span
class="math inline">\(r\)</span> 个元素有序摆放，称 <span
class="math inline">\(n\)</span> 元素集合的 <span
class="math inline">\(r\)</span> - 排列。 用 <span
class="math inline">\(P(n, r)\)</span> 表示 <span
class="math inline">\(n\)</span> 元素集合的全部 <span
class="math inline">\(r\)</span> - 排列数。</p></li>
<li><p>全排列：列出全部元素的排列</p></li>
<li><p><span class="math inline">\(P(n, r) =
\dfrac{n!}{(n-r)!}\)</span></p></li>
<li><p>分步递推：<span class="math inline">\(P(n, r)=n \times
P(n-1,r-1)\)</span></p>
<ul>
<li><p>选择 <span class="math inline">\(1\)</span> 号盒子，放入 <span
class="math inline">\(1\)</span> 个乒乓球</p></li>
<li><p>从 <span class="math inline">\(n-1\)</span> 个球中选出 <span
class="math inline">\(r-1\)</span> 个放入 <span
class="math inline">\(r-1\)</span> 个盒子排列</p></li>
</ul></li>
<li><p>分类递推：<span class="math inline">\(P(n,
r)=P(n-1,r)+rP(n-1,r-1)\)</span></p>
<ul>
<li><p>不选第 <span class="math inline">\(1\)</span> 个球</p></li>
<li><p>选择第 <span class="math inline">\(1\)</span> 个球</p></li>
</ul></li>
<li><p>循环排列：只考虑元素间的相对顺序</p></li>
<li><p><strong>定理2.2.2：</strong> <span
class="math inline">\(n\)</span> 个元素集合的循环 <span
class="math inline">\(r\)</span> 排列个数为： <span
class="math display">\[
\dfrac{P(n, r)}{r}
\]</span></p>
<ul>
<li><p>例：<span class="math inline">\(10\)</span> 个人围坐圆桌，<span
class="math inline">\(2\)</span> 人不彼此相邻，求总排列方法数</p></li>
<li><p><span class="math inline">\((10 - 1)! - 2 \times (9 -
1)!\)</span></p></li>
<li><p>先固定一个人 <span class="math inline">\(P_1\)</span>，然后 <span
class="math inline">\(P_2\)</span> 可选位置为 <span
class="math inline">\(7\)</span>，余下 <span
class="math inline">\(8\)</span> 人任意坐，共 <span
class="math inline">\(7 \times 8!\)</span></p></li>
</ul></li>
<li><p>若是项链排列，为上式除以 <span
class="math inline">\(2\)</span>，考虑正反翻转 <span
class="math inline">\(2\)</span> 种情况</p></li>
</ul>
<h4 id="集合的组合">2.3：集合的组合</h4>
<ul>
<li><p>从 <span class="math inline">\(n\)</span> 个元素中无序地取出
<span class="math inline">\(r\)</span> 个元素，称 <span
class="math inline">\(n\)</span> 元素集合的 <span
class="math inline">\(r\)</span> - 组合。用 <span
class="math inline">\(\left( \begin{matrix} n \\ r
\end{matrix}\right)\)</span> 表示 <span class="math inline">\(n\)</span>
元素集合的全部 <span class="math inline">\(r\)</span> -
组合数。</p></li>
<li><p>约定：</p>
<ul>
<li><p><span class="math inline">\(\left(
\begin{matrix}0\\0\end{matrix}\right)=1\)</span></p></li>
<li><p>当 <span class="math inline">\(r &gt; n\)</span> 时，<span
class="math inline">\(\left(
\begin{matrix}n\\r\end{matrix}\right)=1\)</span></p>
<blockquote>
<p>选择的个数多于总个数时计数为 <span
class="math inline">\(0\)</span></p>
</blockquote></li>
</ul></li>
<li><p>选班委公式：<span class="math inline">\(C(n,r)C(r,k)=C(n,k)C(n-k,
r-k)\)</span>。</p>
<ul>
<li><p>选出 <span class="math inline">\(r\)</span> 个班委、<span
class="math inline">\(k\)</span> 个常委</p></li>
<li><p>先选出 <span class="math inline">\(k\)</span> 个常委，再选出
<span class="math inline">\(r-k\)</span> 个其他班委</p></li>
</ul></li>
<li><p><strong>定理2.3.3（Pascal公式）：</strong>对于满足 <span
class="math inline">\(1 \le k \le n - 1\)</span> 的整数 <span
class="math inline">\(k\)</span> 和 <span
class="math inline">\(n\)</span>，有</p>
<ul>
<li><p><span class="math display">\[
\left( \begin{matrix}n\\k\end{matrix}\right) = \left( \begin{matrix}n -
1\\k\end{matrix}\right) + \left( \begin{matrix}n - 1\\k -
1\end{matrix}\right)
\]</span></p></li>
<li><p>组合证明：</p></li>
<li><p>不包含某个元素 <span class="math inline">\(x\)</span> 的 <span
class="math inline">\(k\)</span> 子集 <span class="math inline">\(\left(
\begin{matrix}n-1\\k\end{matrix}\right)\)</span> 个</p></li>
<li><p>包含这个元素 <span class="math inline">\(x\)</span> 的 <span
class="math inline">\(k\)</span> 子集 <span class="math inline">\(\left(
\begin{matrix}n-1\\k-1\end{matrix}\right)\)</span>​ 个</p></li>
</ul></li>
<li><p>公式：<span class="math inline">\(\left(
\begin{matrix}n\\0\end{matrix}\right)+\left(
\begin{matrix}n\\1\end{matrix}\right)+\left(
\begin{matrix}n\\2\end{matrix}\right)+...+\left(
\begin{matrix}n\\n\end{matrix}\right)=2^n\)</span>
（用子集数量组合计数证明）</p></li>
</ul>
<h4 id="多重集的排列">2.4：多重集的排列</h4>
<blockquote>
<p>主要分无限重复和有限重复</p>
</blockquote>
<ul>
<li><p><strong>定义：</strong><span class="math inline">\(M =
\{a,a,b,c,c,c\} = \{2 \cdot a, 1 \cdot b, 3 \cdot c\}\)</span>，称 <span
class="math inline">\(2, 1, 3\)</span> 是重复集的重数</p>
<ul>
<li>允许元素重复</li>
<li>允许无限重数</li>
</ul></li>
<li><p><strong>定理2.4.2：</strong>令 <span
class="math inline">\(S\)</span> 是多重集，它有 <span
class="math inline">\(k\)</span> 种不同的元素，每种元素的重复数分别为
<span class="math inline">\(n_1，n_2，…，n_k\)</span>，那么，<span
class="math inline">\(S\)</span> 的排列数等于 <span
class="math display">\[
\dfrac{n!}{n_1!n_2!...n_k!}
\]</span></p>
<ul>
<li>证明：依次摆放，约去多余项</li>
<li>例如：数字 <span class="math inline">\(1,1,1, 3, 8\)</span>
可以构造出多少个不同的 <span class="math inline">\(5\)</span>
位数？即</li>
</ul>
<p><span class="math display">\[
\dfrac{5!}{3!1!1!}=20
\]</span></p></li>
<li><p><strong>定理2.4.3：</strong>设 <span class="math inline">\(n =
n_1 + n_2 + \dots + n_k\)</span>，将 <span
class="math inline">\(n\)</span> 个元素集合划分为做了标签的 <span
class="math inline">\(k\)</span> 个盒子 <span class="math inline">\(B_1,
B_2, \dots ,B_k\)</span>，其中 <span class="math inline">\(B_i\)</span>
盒子含有 <span class="math inline">\(n_i\)</span> 个元素，方法数为 <span
class="math display">\[
\dfrac{n!}{n_1!n_2! \dots n_k!}
\]</span> 若盒子无标号且 <span class="math inline">\(n_1 = n_2 = \dots =
n_k\)</span>，则划分数为 <span class="math display">\[
\dfrac{n!}{k!n_1!n_2! \dots n_k!}
\]</span></p>
<blockquote>
<p>多重集的另一种解释：集合划分</p>
<p>如果不是所有的划分数都相等，就需要相同个数的划分去重</p>
</blockquote>
<ul>
<li><p>例：将 <span class="math inline">\(7\)</span> 个不同颜色的球放入
<span class="math inline">\(3\)</span>
个无区别的盒子中，要求每盒球数目不少于 <span
class="math inline">\(2\)</span>，求解放置方案数。</p></li>
<li><p>解：放置方法必为 <span
class="math inline">\(223\)</span>，故方案数为（第一个 <span
class="math inline">\(2!\)</span> 为划分去重） <span
class="math display">\[
\dfrac{7!}{2!2!2!3!} = 105
\]</span></p></li>
</ul></li>
<li><p><strong>定理2.4.4（非攻击性车摆放）：</strong>有 <span
class="math inline">\(n\)</span> 个车共 <span
class="math inline">\(k\)</span> 种颜色，其中第一种颜色的车有 <span
class="math inline">\(n_1\)</span> 个，第二种颜色的车有 <span
class="math inline">\(n_2\)</span> 个，<span
class="math inline">\(\dots\)</span>，第 <span
class="math inline">\(k\)</span> 种颜色的车有 <span
class="math inline">\(n_k\)</span> 个，那么，把这些车放到 <span
class="math inline">\(n \times n\)</span>
的棋盘上，使得没有车能相互攻击的摆放方法数为： <span
class="math display">\[
\dfrac{n!}{n_1!n_2!...n_k!}\cdot n! = \dfrac{(n!)^2}{n_1!n_2!...n_k!}
\]</span></p>
<ul>
<li>例如：当 <span class="math inline">\(8\)</span> 个车，<span
class="math inline">\(1\)</span> 个红车，<span
class="math inline">\(3\)</span> 个蓝车和 <span
class="math inline">\(4\)</span> 个黄车。非攻击车摆放的方法数：</li>
</ul>
<p><span class="math display">\[
8! \times \dfrac{8!}{1!3!4!} = \dfrac{(8!)^2}{3!4!}
\]</span></p>
<blockquote>
<p>先排车，再给车排颜色</p>
</blockquote></li>
</ul>
<h4 id="多重集的组合">2.5：多重集的组合</h4>
<blockquote>
<p>相当于将 <span class="math inline">\(r\)</span> 个相同元素分成 <span
class="math inline">\(k\)</span>
个不同区域，每个区域对应一种元素——隔板法</p>
<p>多重集组合 <span class="math inline">\(\Leftrightarrow\)</span>
不定方程解集 <span class="math inline">\(\Leftrightarrow\)</span>
多重集排列</p>
<p>多重集 <span class="math inline">\(S\)</span> 的 <span
class="math inline">\(r\)</span> - 组合数等于多重集 <span
class="math inline">\(T\)</span> 的排列数</p>
</blockquote>
<ul>
<li><p><strong>定理2.5.1：</strong>令 <span
class="math inline">\(S\)</span> 是多重集，它有 <span
class="math inline">\(k\)</span>
个不同的元素，每个元素都有无限重复次数，那么，<span
class="math inline">\(S\)</span> 的 <span
class="math inline">\(r\)</span> - 组合个数为： <span
class="math display">\[
\left(
\begin{matrix}
r+k-1 \\
r
\end{matrix}
\right)
=
\left(
\begin{matrix}
r+k-1 \\
k-1
\end{matrix}
\right)
\]</span></p>
<ul>
<li><p>例：令 <span class="math inline">\(S＝\{12 \cdot a, 12\cdot b,
12\cdot c\}\)</span>，求 <span class="math inline">\(S\)</span> 的 <span
class="math inline">\(12\)</span> - 组合个数： <span
class="math display">\[
\left(
\begin{matrix}
12+3-1 \\
12
\end{matrix}
\right)=\dfrac{14!}{12!2!}
\]</span></p></li>
<li><p>例：方程 <span class="math inline">\(x_1+x_2+x_3+x_4=20\)</span>
的整数解的个数是多少？其中 <span class="math inline">\(x_1\geq 3,
x_2\geq 1, x_3\geq 0, x_4\geq 5\)</span></p>
<p>作变量代换：<span class="math inline">\(y_1=x_1-3， y_2=x_2-1，
y_3=x_3，y_4=x_4-5\)</span>，那么，得到方程：$ y_1+y_2+y_3+y_4=11$ <span
class="math display">\[
\left(
\begin{matrix}
11+4-1 \\
11
\end{matrix}
\right)=
\left(
\begin{matrix}
14 \\
11
\end{matrix}
\right)
\]</span></p></li>
<li><p>例（出现次数下界约束）：令 <span class="math inline">\(S＝{12
\cdot a, 12 \cdot b, 12 \cdot c }\)</span>。求 <span
class="math inline">\(S\)</span> 的使得 <span
class="math inline">\(3\)</span> 个元素都至少出现一次的 <span
class="math inline">\(12\)</span> - 组合个数。</p>
<ul>
<li>令 <span class="math inline">\(y_i = x_i -
1\)</span>，求非负整数解，套用公式</li>
</ul></li>
<li><p>上界约束：用其他方法做就行，不必拘泥这一章知识</p></li>
</ul></li>
</ul>
<h4 id="x其它一些题目">2.x：其它，一些题目</h4>
<ul>
<li><p>把 <span class="math inline">\(2n\)</span> 个人分成 <span
class="math inline">\(n\)</span> 组，每组 <span
class="math inline">\(2\)</span> 人，有多少分法？</p>
<p>等价为分组问题，相当于将 <span class="math inline">\(2n\)</span>
个不同球投入 $n $ 个相同的盒子中，每个盒子 <span
class="math inline">\(2\)</span> 个。【有点像定理2.4.2除以 <span
class="math inline">\(n!\)</span> 的变体】 <span class="math display">\[
\dfrac{2n!}{(2!)^n \cdot n!}=\dfrac{2n!}{2^n \cdot n!}
\]</span></p></li>
<li><p><strong>不相邻选取问题：</strong>从 <span
class="math inline">\(\{1, 2, \dots, n\}\)</span> 中取出 <span
class="math inline">\(r\)</span> 个不相邻的数，这样的组合有多少种？</p>
<p><span class="math inline">\(\left( \begin{matrix} n-r+1 \\ r
\end{matrix} \right)\)</span> 种，相当于往 $n-r $ 个数的 <span
class="math inline">\(n-r+1\)</span> 个间隔里插入 <span
class="math inline">\(r\)</span>
个<strong>被选取的数</strong>作为“隔板”</p></li>
</ul>
<h3 id="第3章-鸽巢原理"><strong>第3章 鸽巢原理</strong></h3>
<blockquote>
<p>证明存在性的一种主要手段</p>
</blockquote>
<h4 id="鸽巢原理的简单形式">3.1 鸽巢原理的简单形式</h4>
<ul>
<li><p>例：证明，如果从 <span class="math inline">\({1, 2, …,
2n}\)</span> 中任意选择 <span class="math inline">\(n+1\)</span>
个不同的整数，那么一定存在两个整数，它们之间差为 $ 1$。</p>
<p>将集合 <span class="math inline">\(\{1, 2, \dots ,2n\}\)</span>
划分成 <span class="math inline">\(n\)</span> 个子集 <span
class="math inline">\(S_1, S_2, \dots , S_n\)</span>，其中 <span
class="math inline">\(S_n = \{2i-1, 2i\}, i = 1, 2, \dots
,n\)</span></p>
<p>设选择的 <span class="math inline">\(n+1\)</span> 个整数为 $ a_1&lt;
a_2 &lt;…&lt;a_{n+1}$。令 <span class="math inline">\(b_1=a_1+1,
b_2=a_2+1, …, b_{n+1} = a_{n+1} +1\)</span>。此 $ 2n+2$
个数中至少有一对数相等，由于 <span class="math inline">\(a_1, \dots,
a_n\)</span> 互不相等，且 <span class="math inline">\(b_1, \dots
,b_n\)</span> 互不相等。因此存在一对 <span class="math inline">\(b_j =
a_j + 1\)</span> 与 <span class="math inline">\(a_k\)</span> 相等 <span
class="math inline">\((j \ne k)\)</span></p>
<ul>
<li>扩展：从 <span class="math inline">\(1,2, \dots, kn\)</span>
中任意选择 <span class="math inline">\(n+1\)</span> 个，则存在差为 <span
class="math inline">\(k-1\)</span></li>
</ul></li>
<li><p>例：证明，在 <span class="math inline">\(m\)</span> 个正整数
<span class="math inline">\(a_1, a_2, …, a_m\)</span> 中，存在 <span
class="math inline">\(0\leq k&lt; l \leq m\)</span>，使得 <span
class="math inline">\(a_{k+1}+ a_{k+2}+ …+a_l\)</span> 能够被 <span
class="math inline">\(m\)</span> 整除。</p>
<p>证：考虑 <span class="math inline">\(m\)</span> 个和（<span
class="math inline">\(s_m\)</span> 是正整数的前 <span
class="math inline">\(n\)</span> 项和）： <span class="math display">\[
s_1=a_1, s_2=a_1+a_2, s_3=a_1+a_2+a_3, …, s_m=a_1+a_2+…+a_m
\]</span></p>
<ul>
<li><p>若以上和中有一个能被 <span class="math inline">\(m\)</span>
整除，则结论成立；</p>
<blockquote>
<p>这是从头开始的部分和</p>
</blockquote></li>
<li><p>否则设 <span class="math inline">\(r_1, r_2, \dots ,r_n\)</span>
为 <span class="math inline">\(s_1, s_2, \dots ,s_n\)</span> 除以 <span
class="math inline">\(m\)</span> 的非零余数，则 <span
class="math inline">\(1 \leq r_i \leq m-1, i = 1, \dots
,m\)</span>。由鸽巢原理，存在 <span class="math inline">\(r_l = r_k, l
&gt; k\)</span>，则 <span class="math inline">\(a_{k+1} + a_{k+2} +
\dots + a_l\)</span> 能被 <span class="math inline">\(m\)</span>
整除</p>
<blockquote>
<p>这是从中间开始的部分和</p>
</blockquote></li>
</ul></li>
<li><p>例：从整数 <span class="math inline">\(1, 2, …，200\)</span>
中选取 <span class="math inline">\(101\)</span>
个整数。证明所选的数中存在两个整数，使得其中一个是另一个的因子。</p>
<p>证：对于 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(200\)</span> 间的整数 <span
class="math inline">\(n\)</span>，<span class="math inline">\(n\)</span>
可写作以下形式：<span class="math inline">\(n=2^k \times
a\)</span>（其中 <span class="math inline">\(a\)</span> 是 <span
class="math inline">\(1, 2, …, 200\)</span> 内的奇数）</p>
<p>由于要选取 <span class="math inline">\(101\)</span> 个整数，而 <span
class="math inline">\(200\)</span> 内只有 <span
class="math inline">\(100\)</span> 个奇数，由鸽巢原理知必存在两个整数
<span class="math inline">\(n_1\)</span> 与 <span
class="math inline">\(n_2\)</span>
写作上式形式后，两数中的奇数因子相等，均为 <span
class="math inline">\(b\)</span>。 假设 <span
class="math inline">\(n_1=2^{k1} \times b, n_2=2^{k2} \times
b\)</span>，其中 <span class="math inline">\(b\)</span> 是 <span
class="math inline">\(1, 2, …, 200\)</span> 内的奇数。显然，当 <span
class="math inline">\(k_1 \geq k_2\)</span> 时，<span
class="math inline">\(n_2\)</span> 整除 <span
class="math inline">\(n_1\)</span>；否则 <span
class="math inline">\(n_1\)</span> 整除 <span
class="math inline">\(n_2\)</span>。</p></li>
<li><p>例：某厂在五年期间的每一个月里至少试制一种新产品，每年最多试制
<span class="math inline">\(19\)</span>
种新产品。试证明：一定存在连续几个月，恰好试制 <span
class="math inline">\(24\)</span> 种新产品。</p>
<p>证：设五年间每个月新产品数分别为 <span class="math inline">\(a_1,
a_2, \dots , a_{59}, a_{60}\)</span>。构造出数列 <span
class="math inline">\(a_n\)</span> 的前 <span
class="math inline">\(n\)</span> 项和的数列 <span
class="math inline">\(s_1, s_2, \dots , s_{59}, s_{60}\)</span>，则有：
<span class="math display">\[
1≤a_1=s_1&lt;s_2&lt;…&lt;s_{59}&lt;s_{60} \leq 19 \times 5=95
\]</span> 而序列 <span class="math inline">\(s_1+24, s_2+24, \dots ,
s\_{59}+24, s_{60}+24\)</span> 也是一个严格递增序列： <span
class="math display">\[
25≤s_1+24&lt;s_2+24&lt; \dots &lt;s_{59}+24&lt;s-{60}+24 ≤95+24=119
\]</span> 这 <span class="math inline">\(120\)</span> 个数都在区间 <span
class="math inline">\([1,119]\)</span>
内，根据鸽巢原理，必定存在两个数相等</p>
<p>由于 <span class="math inline">\(s_1, s_2, \dots, s_{60}\)</span> 与
<span class="math inline">\(s_1 + 24, s_2 + 24, \dots, s_{60} +
24\)</span> 均为严格单调的，因此必然存在一个 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span>，使得 <span class="math inline">\(s_i =
s_j + 24\)</span> ，因此在第 <span class="math inline">\(j+1\)</span>
个月到第 <span class="math inline">\(i\)</span>
个月的几个月时间里恰好试制了 <span class="math inline">\(24\)</span>
种新产品<strong>（解释含义）</strong></p></li>
</ul>
<p><strong>几何问题：</strong></p>
<ul>
<li><p>例：确定一个整数 <span
class="math inline">\(n_k\)</span>，使得如果在边长为 <span
class="math inline">\(1\)</span> 的等边三角形中任意选择 <span
class="math inline">\(n_k\)</span> 个点，一定存在 <span
class="math inline">\(2\)</span> 个点，其距离至多为 <span
class="math inline">\(\dfrac{1}{k}\)</span></p>
<ul>
<li>解：<span class="math inline">\(n_k = k^2 + 1\)</span></li>
<li>证：将每边均分为 <span class="math inline">\(k\)</span> 份，共有
<span class="math inline">\(k^2\)</span>
个区域，落在任意一个部分中的两点之间的距离至多为 <span
class="math inline">\(\dfrac{1}{k}\)</span>，由鸽巢原理知 <span
class="math inline">\(n_k = k^2 + 1\)</span></li>
</ul></li>
<li><p>例（一道数值计算题，比较暴力，估计不会考）：在直径为 <span
class="math inline">\(5\)</span> 的圆内任意给定 <span
class="math inline">\(10\)</span> 个点，证明存在两点距离小于 <span
class="math inline">\(2\)</span></p>
<ul>
<li>证：<img src="Images\Circle.png" alt="Circle" style="zoom:33%;" /></li>
</ul></li>
<li><p>例：将一个矩形分成 <span class="math inline">\(4\)</span> 行
<span class="math inline">\(19\)</span> 列的网格，每个单元格涂 <span
class="math inline">\(3\)</span> 种颜色当中的 <span
class="math inline">\(1\)</span>
种颜色，证明：无论怎样涂色，必有一个由单元格构成的矩形的 <span
class="math inline">\(4\)</span> 个角上的格子颜色相同</p>
<ul>
<li>思路：两次鸽巢原理</li>
<li>每一列 <span class="math inline">\(4\)</span> 行但只有 <span
class="math inline">\(3\)</span>
个颜色，由鸽巢原理，必有两个单元格颜色相同，其位置组合共 <span
class="math inline">\(\left( \begin{matrix} 4 \\ 2 \end{matrix} \right)
= 6\)</span> 种，<span class="math inline">\(3\)</span> 种颜色下共 <span
class="math inline">\(18\)</span> 种，由鸽巢原理，得证</li>
</ul></li>
<li><p>例：证明在 <span class="math inline">\(n+2\)</span>
个任选的正整数中，存在两个数，或者其差能被 <span
class="math inline">\(2n\)</span> 整除，或者其和能被 <span
class="math inline">\(2n\)</span> 整除。</p>
<p>证明：已知所有正整数除以 <span class="math inline">\(2n\)</span>
的余数只能取值 <span class="math inline">\(0, 1, 2, …,
2n-1\)</span>。</p>
<p>把以上余数构造以下 <span class="math inline">\(n+1\)</span>
个子集：<span class="math inline">\(\{1, 2n-1\}, \{2, 2n-2\}, …, \{n-1,
n+1\}, \{n, n\}, \{0, 0\}\)</span>。</p>
<p>任选 <span class="math inline">\(n+2\)</span>
个正整数，由鸽巢原理知，一定存在两个数，其除以 <span
class="math inline">\(2n\)</span> 的余数来自同一个子集 <span
class="math inline">\(A\)</span>。</p>
<ul>
<li><p>若 <span class="math inline">\(A\)</span> 是前 <span
class="math inline">\(n-2\)</span> 个子集中一个，则这两个数的和能被
<span class="math inline">\(2n\)</span> 整除；</p></li>
<li><p>若 <span class="math inline">\(A\)</span> 是最后 <span
class="math inline">\(2\)</span> 个子集中一个，则这两个数的差能被 <span
class="math inline">\(2n\)</span> 整除。</p></li>
</ul></li>
<li><p>例：一间房屋内有 <span class="math inline">\(10\)</span>
个人，他们当中没有人超过 <span class="math inline">\(60\)</span>
岁（年龄只能以整数给出)，但又至少不低于 <span
class="math inline">\(1\)</span>
岁。证明：总能找出两组人（两组人中不含相同的人 ），使得年龄和相同。</p>
<p>证：<span class="math inline">\(10\)</span> 个人构成的子集一共是
<span class="math inline">\(2^{10}=1024\)</span>
个，去除掉空集与全集，一共 <span class="math inline">\(1022\)</span>
个子集可以是找出的两组人中的一组。由于这些子集的年龄和最小为 <span
class="math inline">\(1\)</span> 岁，且不超过 <span
class="math inline">\(60 \times 9= 540\)</span>
岁。因此，由鸽巢原理知，至少有两组人的年龄和相同，<strong>去除这两组人的相同人后</strong>，所得的两组人满足题目要求</p>
<ul>
<li>如果改成 <span class="math inline">\(9\)</span> 个人，则下面记得改成
<span class="math inline">\(480\)</span></li>
</ul></li>
<li><p>其他问题和作业题整理——todo</p></li>
</ul>
<h4 id="鸽巢原理的加强形式">3.2 鸽巢原理的加强形式</h4>
<ul>
<li><p><strong>定理3.2.1 ：</strong>令 <span class="math inline">\(q_1,
q_2 , \dots, q_n\)</span> 为正整数。若将 <span
class="math inline">\(q_1+q_2+ \dots +q_n - n+1\)</span> 个物体放进
<span class="math inline">\(n\)</span> 个盒子内，那么，</p>
<p>或者第 <span class="math inline">\(1\)</span> 个盒子至少含有 <span
class="math inline">\(q_1\)</span> 个物体，</p>
<p>或者第 <span class="math inline">\(2\)</span> 个盒子至少含有 <span
class="math inline">\(q_2\)</span> 个物体，</p>
<p>…，</p>
<p>或者第 <span class="math inline">\(n\)</span> 个盒子至少含有 <span
class="math inline">\(q_n\)</span> 个物体</p>
<blockquote>
<p>当然，也就是说不会出现每个盒子的物体数少于上述数字的情况</p>
</blockquote>
<blockquote>
<p>令 <span class="math inline">\(q_1 = q_2 = \dots = q_n =
2\)</span>，即为鸽巢原理的简单形式</p>
</blockquote></li>
<li><p><strong>平均原理：</strong>如果 <span
class="math inline">\(m\)</span> 个物体放入 <span
class="math inline">\(n\)</span> 个盒子，则至少有一个盒子含有 <span
class="math inline">\(\lceil m/n\rceil\)</span> 个或更多的物体</p></li>
<li><p>例（判断满足条件的最小物品总数）：一篮水果装有苹果、梨和桔子。为了保证或者至少
<span class="math inline">\(8\)</span> 个苹果，或者至少 <span
class="math inline">\(6\)</span> 个梨或者至少 <span
class="math inline">\(9\)</span>
个桔子，则放入篮子中的水果的最少件数是多少？</p>
<p><span class="math inline">\(8+6+9-3+1=21\)</span> 件</p>
<p><strong>（尽量说明下反面）</strong>：当放入篮子的水果数为 <span
class="math inline">\(20\)</span> 时，可能出现 <span
class="math inline">\(7\)</span> 个苹果，<span
class="math inline">\(5\)</span> 个香蕉和 <span
class="math inline">\(8\)</span> 个桔子的情形，不满足题目要求</p></li>
<li><p>例：证明从任意给出的 <span class="math inline">\(5\)</span>
个正整数中必能选出 <span class="math inline">\(3\)</span>
个数，它们的和能被 <span class="math inline">\(3\)</span> 整除。</p>
<p>任意正整数除以 <span class="math inline">\(3\)</span> 的余数只能为
<span class="math inline">\(0,1,2\)</span>。</p>
<p>设 <span class="math inline">\(A\)</span> 为任意给出的 <span
class="math inline">\(5\)</span> 个正整数的集合。设 <span
class="math inline">\(t_0, t_1, t_2\)</span> 为 <span
class="math inline">\(A\)</span> 中除以 <span
class="math inline">\(3\)</span> 余数分别为 <span
class="math inline">\(0, 1, 2\)</span> 的数的个数。</p>
<ul>
<li><p>若 <span class="math inline">\(t_0, t_1, t_2\)</span> 均不为
<span class="math inline">\(0\)</span>， 则一定有三个数除以 <span
class="math inline">\(3\)</span> 的余数分别为 <span
class="math inline">\(0, 1, 2\)</span>，则这三个数的和能被 <span
class="math inline">\(3\)</span> 整除。</p></li>
<li><p>若 <span class="math inline">\(t_0, t_1, t_2\)</span>
中至少有一个为 <span class="math inline">\(0\)</span>，不妨设 <span
class="math inline">\(t_0=0\)</span>，则 <span
class="math inline">\(t_1+t_2=5\)</span>。由平均原理知，至少有 <span
class="math inline">\(\lceil 5/2\rceil = 3\)</span> 个数除以 <span
class="math inline">\(3\)</span> 的余数相同（全为 <span
class="math inline">\(1\)</span> 或全为 <span
class="math inline">\(2\)</span>），则这三个数的和能被 <span
class="math inline">\(3\)</span> 整除。</p></li>
</ul></li>
<li><p>例：证明每个由<span
class="math inline">\(n^2+1\)</span>个实数构成的序列：<span
class="math inline">\(a_1, a_2, \dots a_{n^2 +
1}\)</span>，或者含有长度为 <span class="math inline">\(n+1\)</span>
的递增子序列，或者含有长度为 <span class="math inline">\(n+1\)</span>
的递减子序列。</p>
<p>证：假设不存在长度为 <span class="math inline">\(n+1\)</span>
的递增子序列，只需构造一个长度为 <span
class="math inline">\(n+1\)</span> 的递减子序列。 设 <span
class="math inline">\(l_k\)</span> 是以 <span
class="math inline">\(a_k\)</span> 为起始的最长递增子序列长度，<span
class="math inline">\(k =1, 2, …，n^2+1\)</span>，则对 <span
class="math inline">\(\forall k\)</span> 有 <span
class="math inline">\(1 \leq l_k \leq n\)</span>。对序列 <span
class="math inline">\(l_1, l_2, …,l_{n^2 + 1}\)</span>
运用鸽巢原理加强形式，一定存在 <span class="math inline">\(\lceil
(n^2+1)/n \rceil =n+1\)</span> 个 <span
class="math inline">\(l_i\)</span> 相等。 设 <span
class="math display">\[
l_{k_1}=l_{k_2}= \dots =l_{k_{n+1}}
\]</span> 其中 <span class="math inline">\(1 \leq k_1&lt; k_2&lt;…&lt;
k_{n+1} \leq n^2+1\)</span></p>
<p>(下面证明 <span class="math inline">\(a_{k_1},a_{k_2}, \dots
,a_{k_{n+1}}\)</span> 是长度为 <span class="math inline">\(n+1\)</span>
的递减序列) 反证：假设存在 <span class="math inline">\(k_i,
k_{i+1}\)</span>，使得 <span
class="math inline">\(a_{k_i}&lt;a_{k_{i+1}}\)</span>，把 <span
class="math inline">\(a_{k_i}\)</span> 加到以 <span
class="math inline">\(a_{k_{i+1}}\)</span>
开始的最长递增子序列，则构成了以 <span
class="math inline">\(a_{k_i}\)</span> 开始的递增子序 列，得 <span
class="math inline">\(l_{k_i}&gt;l_{k_{i+1}}\)</span>，与 <span
class="math inline">\(l_{k_i} = l_{k_{i+1}}\)</span> 矛盾！</p>
<blockquote>
<p>证明不是递增就是递减</p>
</blockquote>
<p>todo 方阵排队问题</p></li>
</ul>
<h4 id="ramsey-定理">3.3 <span class="math inline">\(Ramsey\)</span>
定理</h4>
<ul>
<li><p><strong><span class="math inline">\(Ramsey\)</span>
定理：</strong></p>
<ul>
<li>通俗实例： 在 <span class="math inline">\(6\)</span> 个人中，或者有
$ 3$ 个人，他们中每两个人都互相认识；或者有 <span
class="math inline">\(3\)</span>
个人，他们中的每两个人都彼此不认识。</li>
<li>给图 <span class="math inline">\(K_6\)</span>
的边任意着红色、蓝色后，一定存在一个红色 <span
class="math inline">\(K_3\)</span> 或 蓝色<span
class="math inline">\(K_3\)</span>，记为<span class="math inline">\(K_6
\rightarrow K_3,K_3\)</span></li>
<li><span class="math inline">\(n\)</span> 阶完全图：用 <span
class="math inline">\(K_n\)</span> 表示平面上没有 <span
class="math inline">\(3\)</span> 点共线的 <span
class="math inline">\(n\)</span> 个顶点构成的一个完全图。</li>
</ul></li>
<li><p>证明：给图 <span class="math inline">\(K_6\)</span>
的边任意着红色、蓝色，一定存在一个红色 <span
class="math inline">\(K_3\)</span> 或蓝色 <span
class="math inline">\(K_3\)</span>，记为 <span class="math inline">\(K_6
\rightarrow K_3, K_3\)</span></p>
<p><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611105033290.png" alt="image-20230611105033290" style="zoom:33%;" /></p></li>
<li><p><strong>定理 3.3.1 (<span class="math inline">\(Ramsey\)</span>
定理) ：</strong>如果两个整数 <span class="math inline">\(m ≥ 2, n ≥
2\)</span>，则存在正整数 <span class="math inline">\(p\)</span>，使得
<span class="math inline">\(K_p \rightarrow K_m,K_n\)</span></p></li>
<li><p><strong><span class="math inline">\(Ramsey\)</span>
数：</strong><span class="math inline">\(Ramsey\)</span> 数 <span
class="math inline">\(r(m, n)\)</span> 是使 <span
class="math inline">\(K_p \rightarrow K_m,K_n\)</span> 成立的最小整数
<span class="math inline">\(p\)</span></p>
<ul>
<li><p>一定存在</p></li>
<li><p>对称性：<span class="math inline">\(r(m,n) =
r(n,m)\)</span></p></li>
<li><p>平凡的 <span class="math inline">\(Ramsey\)</span> 数：<span
class="math inline">\(r(2, n)=n, r(m,2)=m\)</span></p>
<blockquote>
<p>或者存在一条边是红色，或者所有边是蓝色</p>
</blockquote></li>
<li><p>推论：<span class="math inline">\(r(m, n) ≤ r(m-1, n) + r(m,
n-1)\)</span>。</p></li>
</ul></li>
<li><p><strong><span class="math inline">\(Ramsey\)</span>
定理推广：</strong>如果<span class="math inline">\(n_1, n_2,\dots,
n_l\)</span> 都是大于或等于 <span class="math inline">\(2\)</span>
的整数，则一定存在正整数 <span class="math inline">\(p\)</span>，使得
<span class="math display">\[
K_p \rightarrow K_{n_1},K_{n_2},\dots,K_{n_l}
\]</span> 满足以上条件的最小整数 <span class="math inline">\(p\)</span>
称为 <span class="math inline">\(Ramsey\)</span> 数。例如：<span
class="math inline">\(K_{17} \rightarrow
K_3,K_3,\dots,K_3\)</span></p></li>
<li><p>例：证明 <span class="math inline">\(r(3, 3, 3) \le 17\)</span>
todo</p></li>
</ul>
<h3 id="第4章-生成排列和组合"><strong>第4章 生成排列和组合</strong></h3>
<blockquote>
<p>排列生成算法：</p>
<ul>
<li>递归生成算法</li>
<li>邻位对换算法</li>
<li>从逆序生成排列算法
<ul>
<li>逆序相关知识</li>
<li>从最大数或最小数</li>
</ul></li>
</ul>
<p>组合生成算法：</p>
<ul>
<li>字典序</li>
<li>反射 <span class="math inline">\(Gray\)</span> 码
<ul>
<li>递归法</li>
<li>逐次法</li>
</ul></li>
<li>基于字典序的 <span class="math inline">\(r\)</span> -
组合生成算法</li>
</ul>
</blockquote>
<h4 id="生成排列">4.1 生成排列</h4>
<ul>
<li>递归生成算法</li>
<li>邻位对换算法：
<ul>
<li>可活动：箭头指向与其相邻但比它小的整数</li>
</ul></li>
<li>两种算法生成的排列顺序一致</li>
</ul>
<h4 id="排序中的逆序">4.2 排序中的逆序</h4>
<ul>
<li><p><strong>逆序：</strong>令 <span
class="math inline">\(i_1,i_2,\dots,i_n\)</span> 是集合 <span
class="math inline">\(\{1, 2,\dots, n\}\)</span> 的一个排列， 如果 <span
class="math inline">\(0\leq k &lt; l \leq n\)</span>， 且 <span
class="math inline">\(i_k &gt; i_l\)</span> , 称数对 <span
class="math inline">\((i_k, i_l)\)</span> 是排列的一个逆序。</p>
<ul>
<li><p>如，排列 <span class="math inline">\(31524\)</span> 的逆序为
<span class="math inline">\((3,1), (3,2), (5,2), (5,4)\)</span></p></li>
<li><p>唯一没有逆序的排列为 <span class="math inline">\(1 2 3 \dots
n\)</span></p></li>
</ul></li>
<li><p><strong>逆序数：</strong>对于 <span class="math inline">\(\{1,
2,\dots, n\}\)</span> 上的一个排列，逆序数 <span
class="math inline">\(a_j\)</span> 是<strong>第二元</strong>是 <span
class="math inline">\(j\)</span> 的逆序的数量，也即排列中先于整数 <span
class="math inline">\(j\)</span> 并大于 <span
class="math inline">\(j\)</span> 的整数的个数，度量 <span
class="math inline">\(j\)</span> 的反序程度。</p></li>
<li><p><strong>逆序列：</strong>令 <span
class="math inline">\(a_j\)</span> 表示排列 <span
class="math inline">\(i_1i_2,\dots,i_n\)</span> 中数 <span
class="math inline">\(j\)</span> 的逆序数， 称<span
class="math inline">\(a_1,a_2,\dots,a_n\)</span>为排列 <span
class="math inline">\(i_1i_2,\dots,i_n\)</span> 的逆序列</p>
<p>例如，排列 <span class="math inline">\(361245\)</span>。</p>
<p>逆序：<span class="math inline">\((3, 1) ,(3, 2), (6, 1),(6, 2), (6,
4) ,(6, 5)\)</span>。</p>
<p>逆序数：<span class="math inline">\(a_1=2, a_2=2, a_3=0, a_4=1,
a_5=1, a_6=0\)</span></p>
<p>逆序列：<span class="math inline">\(2 2 0 1 1 0\)</span></p></li>
<li><p>从逆序生成排列算法：</p>
<ol type="1">
<li><p>从最大数开始。已知 <span class="math inline">\(\{1, 2, …,
8\}\)</span> 的一个排列的逆序列为 <span class="math inline">\(5 3 4 0 2
1 1 0\)</span>，确定此排列。【每个数放在第“逆序数”个位置上】</p>
<ul>
<li>特点：相对位置固定，但是每个整数的位置要到最后才能确定</li>
</ul>
<table>
<thead>
<tr class="header">
<th>当前放置数</th>
<th>当前排列</th>
<th>逆序数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>8：</td>
<td>8</td>
<td>0</td>
</tr>
<tr class="even">
<td>7：</td>
<td>8 7</td>
<td>1</td>
</tr>
<tr class="odd">
<td>6：</td>
<td>8 6 7</td>
<td>1</td>
</tr>
<tr class="even">
<td>5：</td>
<td>8 6 5 7</td>
<td>2</td>
</tr>
<tr class="odd">
<td>4：</td>
<td>4 8 6 5 7</td>
<td>0</td>
</tr>
<tr class="even">
<td>3：</td>
<td>4 8 6 5 3 7</td>
<td>4</td>
</tr>
<tr class="odd">
<td>2：</td>
<td>4 8 6 2 5 3 7</td>
<td>3</td>
</tr>
<tr class="even">
<td>1：</td>
<td>4 8 6 2 5 1 3 7</td>
<td>5</td>
</tr>
</tbody>
</table></li>
<li><p>从最小数开始。仍上例。【每个数放在第“逆序数+1”个<strong>空</strong>位置上】</p>
<table>
<thead>
<tr class="header">
<th>当前放置数</th>
<th>当前排列</th>
<th>逆序数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1：</td>
<td>X X X X X 1 X X</td>
<td>5</td>
</tr>
<tr class="even">
<td>2：</td>
<td>X X X 2 X 1 X X</td>
<td>3</td>
</tr>
<tr class="odd">
<td>3：</td>
<td>X X X 2 X 1 3 X</td>
<td>4</td>
</tr>
<tr class="even">
<td>4：</td>
<td>4 X X 2 X 1 3 X</td>
<td>0</td>
</tr>
<tr class="odd">
<td>5：</td>
<td>4 X X 2 5 1 3 X</td>
<td>2</td>
</tr>
<tr class="even">
<td>6：</td>
<td>4 X 6 2 5 1 3 X</td>
<td>1</td>
</tr>
<tr class="odd">
<td>7：</td>
<td>4 X 6 2 5 1 3 7</td>
<td>1</td>
</tr>
<tr class="even">
<td>8：</td>
<td>4 8 6 2 5 1 3 7</td>
<td>0</td>
</tr>
</tbody>
</table></li>
</ol></li>
<li><p>逆序个数为奇数的排列称为奇排列；
逆序个数为偶数的排列称为偶排列。</p></li>
<li><p><span class="math inline">\(15
Puzzles\)</span>：用逆序数证明无解：左右移动逆序数的和不变，上下移动逆序数的和
<span class="math inline">\(+3\)</span></p></li>
</ul>
<h4 id="生成组合">4.3 生成组合</h4>
<ul>
<li><p><span class="math inline">\(n\)</span> 元集合 <span
class="math inline">\(S=\{x_{n-1},x_{n-2}, \dots, x_0\}\)</span>
的组合与长度为 <span class="math inline">\(n\)</span>
的二进制数一一对应（注意到两者个数均为 <span
class="math inline">\(2^n\)</span>）</p>
<ul>
<li>对应方法：这个整数的二进制表示 <span
class="math inline">\(1\)</span> 所在的位置的元素包含在组合中</li>
<li>如：<span class="math inline">\(29 \in [1, 2^7]\)</span>
的二进制表示 <span class="math inline">\(0011101\)</span>，则 <span
class="math inline">\(29\)</span> 对应的组合为 <span
class="math inline">\(\{x_4, x_3, x_2, x_0\}\)</span></li>
</ul></li>
<li><p>字典序生成算法</p>
<ul>
<li><p>初始：<span class="math inline">\(a_{n-1} \dots a_1a_0 = 0 \dots
00\)</span></p></li>
<li><p>当 <span class="math inline">\(a_{n-1} \dots a_1a_0 \neq 1 \dots
11\)</span> 时，求出使得 <span class="math inline">\(a_j = 0\)</span>
的最小整数 <span class="math inline">\(j\)</span>，用 <span
class="math inline">\(1\)</span> 替换 <span
class="math inline">\(a_j\)</span> 并用 <span
class="math inline">\(0\)</span> 替换每个 <span
class="math inline">\(a_{j-1}, \dots a_1, a_0\)</span></p>
<blockquote>
<p>把最小的 <span class="math inline">\(1\)</span> 找出来，后面的全换成
<span class="math inline">\(0\)</span></p>
</blockquote></li>
<li><p>例1：求组合 <span class="math inline">\(\{x_6, x_4, x_2, x_1,
x_0\}\)</span> 的下一个组合</p>
<ul>
<li><span class="math inline">\(1010111 + 1 =
1011000\)</span>，对应组合为 <span class="math inline">\(\{x_6, x_4,
x_3\}\)</span></li>
</ul></li>
<li><p>例2：<span class="math inline">\(S = \{x_6, x_5, \dots, x_1,
x_0\}\)</span> 的哪个子集是子集列表中的第 <span
class="math inline">\(108\)</span> 个子集？</p>
<ul>
<li>注：位置从 <span class="math inline">\(0\)</span> 开始，第 <span
class="math inline">\(108\)</span> 个子集对应 <span
class="math inline">\(108\)</span>，<span
class="math inline">\(108\)</span> 二进制数为 <span
class="math inline">\(1101100\)</span>，则对应子集为 <span
class="math inline">\(\{x_6, x_5, x_3, x_2\}\)</span></li>
</ul></li>
</ul></li>
<li><p>反射 <span class="math inline">\(Gray\)</span>
码序生成算法：特点为相邻的组合间仅相差一个元素。生成方法：前面补0，1；之后折叠</p>
<blockquote>
<p>对应 <span class="math inline">\(n\)</span> 维空间点坐标</p>
</blockquote>
<ul>
<li>递归生成：见图
<ul>
<li><img src="Images\RecursiveGray.png" alt="RecursiveGray" style="zoom: 33%;" /></li>
</ul></li>
<li>逐次生成：整体思路——每次改变 <span
class="math inline">\(\sigma\)</span> 的奇偶性
<ul>
<li>初始：<span class="math inline">\(a_{n-1} \dots a_1a_0 = 0 \dots
00\)</span></li>
<li>当 <span class="math inline">\(a_{n-1} \dots a_1a_0 \neq 1 \dots
00\)</span> 时，计算 <span class="math inline">\(\sigma(a_{n-1} \dots
a_1 a_0) = a_{n-1} + \dots + a_1 + a_0\)</span>，如果结果为偶数，则改变
<span class="math inline">\(a_0\)</span>；否则确定使得 <span
class="math inline">\(a_j = 1\)</span> 且对于所有 <span
class="math inline">\(i &lt; j\)</span>$， $<span
class="math inline">\(a_i = 0\)</span> 的最小整数 <span
class="math inline">\(j\)</span>，改变 <span
class="math inline">\(a_{j+1}\)</span></li>
</ul></li>
</ul></li>
<li><p>可由归纳法证明二者生成相同顺序的 <span
class="math inline">\(n\)</span> 阶反射 <span
class="math inline">\(Gray\)</span> 码</p></li>
<li><p>确定 <span class="math inline">\(n\)</span> 元组在 <span
class="math inline">\(Gray\)</span>
码序表中的准确位置：<img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230608105305919.png" alt="image-20230608105305919" style="zoom: 33%;" /></p></li>
</ul>
<h4 id="生成-r---组合">4.4 生成 <span class="math inline">\(r\)</span> -
组合</h4>
<ul>
<li><p>先于：若 <span class="math inline">\(A \cup B \setminus A \cap
B\)</span> 中的最小整数属于 <span class="math inline">\(A\)</span>，则称
<span class="math inline">\(A\)</span> 先于 <span
class="math inline">\(B\)</span></p>
<blockquote>
<p>属于 <span class="math inline">\(A \cup B\)</span>， 但不同时属于
<span class="math inline">\(A \cap B\)</span></p>
</blockquote></li>
<li><p>直接后继求解算法：找出满足 <span
class="math inline">\(a_i&lt;n\)</span>，且 <span
class="math inline">\(a_i+1\)</span> 不在 <span
class="math inline">\(\{a_1,…, a_r\}\)</span> 中的最大的 <span
class="math inline">\(i\)</span>，记为 <span
class="math inline">\(k\)</span>，在字典序中 <span
class="math inline">\(a_1a_2…a_r\)</span> 的直接后继是<span
class="math inline">\(a_1a_2…a_{k-1} (a_k+1) (a_k+2)…(a_k+r – k
+1)\)</span></p></li>
<li><p><span class="math inline">\(r\)</span> 子集的生成算法：从 <span
class="math inline">\(12 \dots r\)</span>
开始，逐个列出直接后继，直到得到 <span
class="math inline">\((n-r+1)(n-r+2) \dots n\)</span></p></li>
</ul>
<h3 id="第5章-二项式系数"><strong>第5章 二项式系数</strong></h3>
<blockquote>
<p>讨论二项式系数相关等式和性质</p>
</blockquote>
<h4 id="pascal-三角形">5.1 <span class="math inline">\(Pascal\)</span>
三角形</h4>
<ul>
<li><p><strong>定理5.1.1(<span class="math inline">\(Pascal\)</span>
公式)：</strong>对于满足 <span class="math inline">\(1 \leq k \leq
n\)</span> 的所有整数 <span class="math inline">\(k\)</span> 和 <span
class="math inline">\(n\)</span>，有： <span class="math display">\[
\left(\begin{matrix}
n \\ k
\end{matrix}\right)=
\left(\begin{matrix}
n-1 \\ k
\end{matrix}\right)+
\left(\begin{matrix}
n-1 \\ k-1
\end{matrix}\right)
\]</span></p>
<ul>
<li>组合证明同前，此处从略</li>
<li><span class="math inline">\(Pascal\)</span>
三角形：<img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230608111421566.png" alt="image-20230608111421566" style="zoom:33%;" /></li>
<li>行列套用定义即可，没有很强的几何直观性</li>
<li>另一种解释：路径移动</li>
<li>可以证明若干项求和的等式</li>
</ul></li>
</ul>
<h4 id="二项式定理">5.2 二项式定理</h4>
<ul>
<li><p><strong>定理5.2.1：</strong>令 <span
class="math inline">\(n\)</span> 是一个正整数, 那么对于所有的 <span
class="math inline">\(x, y\)</span> 有： <span class="math display">\[
(x+y)^n=\sum_{k=0}^n \left( \begin{matrix} n \\ k \end{matrix} \right)
x^{n-k} y^k
\]</span></p>
<ul>
<li>可以对换 <span class="math inline">\(x, y\)</span>，对换 <span
class="math inline">\(n\)</span> 和 <span
class="math inline">\(n-k\)</span> 得到等价形式</li>
</ul></li>
<li><p><strong>二项式系数的其它等式：</strong> <span
class="math display">\[
k \left( \begin{matrix} n \\ k \end{matrix} \right) = n \left(
\begin{matrix} n-1 \\ k-1 \end{matrix} \right)
\]</span></p>
<ul>
<li><p><span class="math inline">\(n\)</span> 个人中选 <span
class="math inline">\(k\)</span> 人组成足球队，其中 <span
class="math inline">\(1\)</span> 人为队长，有多少种不同选法？</p>
<p>1、先选足球队，然后从足球队中选队长；</p>
<p>2、先选队长，再在剩下的 <span class="math inline">\(n-1\)</span>
人中选 <span class="math inline">\(k-1\)</span> 个足球队员。</p></li>
</ul>
<p><span class="math display">\[
\sum_{k=0}^n \left( \begin{matrix} n \\ k \end{matrix} \right)^2 =
\left( \begin{matrix} 2n \\ n \end{matrix} \right) (n \geq 0)
\]</span></p>
<ul>
<li><p>设 <span class="math inline">\(A={1, 2, …, n}, B={n+1, n+2, …,
2n}\)</span>，<span class="math inline">\(A \cup B={1, 2, …,
2n}\)</span>。令 <span class="math inline">\(S＝A\cup B\)</span>，<span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 是两个不相交的 <span
class="math inline">\(n\)</span> 个元素集合.</p>
<ul>
<li><p><span class="math inline">\(S\)</span> 的 <span
class="math inline">\(n\)</span> - 组合数是<span
class="math inline">\(\left(\begin{matrix} 2n \\ n
\end{matrix}\right)\)</span></p></li>
<li><p>设 <span class="math inline">\(S\)</span> 的一个 <span
class="math inline">\(n\)</span> - 组合含有 <span
class="math inline">\(A\)</span> 的元素为 <span
class="math inline">\(k\)</span> 个，含有 <span
class="math inline">\(B\)</span> 的元素为 <span
class="math inline">\(n-k\)</span> 个，<span
class="math inline">\(k=0,1,…, n\)</span>。令 <span
class="math inline">\(C_k\)</span> 是含有 <span
class="math inline">\(k\)</span> 个 <span
class="math inline">\(A\)</span> 的元素的 <span
class="math inline">\(n\)</span> - 组合，则 <span
class="math inline">\(S\)</span> 的所有 <span
class="math inline">\(n\)</span> - 组合可划分为：<span
class="math inline">\(C_0, C_1,…, C_n\)</span>。有：</p></li>
</ul>
<p><span class="math display">\[
\left(\begin{matrix} 2n \\ n \end{matrix}\right) =
\left| C_0 \right| + \left| C_1 \right| + \dots + \left| C_n \right|
\]</span></p>
<p><span class="math display">\[
\left| C_k \right| =
\left(\begin{matrix} n \\ k \end{matrix}\right)
\left(\begin{matrix} n \\ n-k \end{matrix}\right) =
\left(\begin{matrix} n \\ k \end{matrix}\right) ^2
\]</span></p>
<p>得证。 <span class="math display">\[
\left(\begin{matrix} n \\ 0 \end{matrix}\right)-
\left(\begin{matrix} n \\ 1 \end{matrix}\right)+
\left(\begin{matrix} n \\ 2 \end{matrix}\right)+ \dots +
(-1)^n\left(\begin{matrix} n \\ n \end{matrix}\right)+ \dots = 0
\]</span></p></li>
<li><p>证明：</p>
<ul>
<li>方法一：令二项式公式中 <span class="math inline">\(x = 1, y =
-1\)</span></li>
<li>方法二：奇偶子集之和之差</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
\left(\begin{matrix} n \\ 0 \end{matrix}\right)+
\left(\begin{matrix} n \\ 2 \end{matrix}\right)+ \dots =
\left(\begin{matrix} n \\ 1 \end{matrix}\right)+
\left(\begin{matrix} n \\ 3 \end{matrix}\right)+ \dots = 2^{n-1}
\]</span></p>
<ul>
<li><p>证明</p>
<ul>
<li>方法一：偶数个元素的子集的个数 = 奇数个元素的子集的个数 = <span
class="math inline">\(\dfrac{1}{2}\)</span>总子集数。</li>
<li>方法二：<span class="math inline">\(x_1,…, x_{n-1}\)</span>
每个有两种选择，但前面的奇偶性决定了 <span
class="math inline">\(x_n\)</span> 只有一种选择（使得总元素个数为 奇数
或 偶数）</li>
</ul></li>
<li><p>例：证明以下等式： <span class="math display">\[
1 \left(\begin{matrix} n \\ 1 \end{matrix}\right)+
2 \left(\begin{matrix} n \\ 2 \end{matrix}\right)+ \dots +
n \left(\begin{matrix} n \\ n \end{matrix}\right) = n 2^{n-1}
\]</span></p>
<ul>
<li><p>利用选队长公式 <span class="math inline">\(k \left(
\begin{matrix} n \\ k \end{matrix} \right) = n \left( \begin{matrix} n-1
\\ k-1 \end{matrix} \right)\)</span> <span class="math display">\[
1 \left(\begin{matrix} n \\ 1 \end{matrix}\right) +
2 \left(\begin{matrix} n \\ 2 \end{matrix}\right) + \dots +
n \left(\begin{matrix} n \\ n \end{matrix}\right) =
n \left(\begin{matrix} n-1 \\ 0 \end{matrix}\right) +
n \left(\begin{matrix} n-1 \\ 1 \end{matrix}\right) + \dots +
n \left(\begin{matrix} n-1 \\ n-1 \end{matrix}\right) = n2^{n-1}
\]</span></p></li>
<li><p>求导法：对 <span class="math inline">\((1+x)^n = 1 +
\left(\begin{matrix} n \\ 1 \end{matrix}\right)x + \left(\begin{matrix}
n \\ 2 \end{matrix}\right)x^2 + \dots + \left(\begin{matrix} n \\ k
\end{matrix}\right)x^k + \dots + \left(\begin{matrix} n \\ n
\end{matrix}\right)x^n\)</span>，左右同求导数，取 <span
class="math inline">\(x = 1\)</span></p></li>
</ul></li>
<li><p>例：<img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611115437992.png" alt="image-20230611115437992" style="zoom:33%;" /></p></li>
<li><p>组合定义扩展</p>
<ul>
<li><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230608114453735.png" alt="image-20230608114453735" style="zoom:33%;" /></li>
</ul></li>
</ul>
<h4 id="二项式系数的单峰性">5.3 二项式系数的单峰性</h4>
<ul>
<li><p><strong>定理5.3.1：</strong>对 <span
class="math inline">\(n\)</span> 是奇数偶数的单峰性讨论</p>
<ul>
<li>证明：考虑相邻两项的商</li>
</ul></li>
<li><p><strong>链与反链：</strong>令 <span
class="math inline">\(S\)</span> 是 <span
class="math inline">\(n\)</span> 个元素的集合，<span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的<strong>子集</strong>的集合</p>
<ul>
<li><p><strong>链：</strong>若 <span class="math inline">\(C\)</span>
中任意两个不同的子集都存在包含关系，则称 <span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的一个链。</p>
<ul>
<li>对 <span class="math inline">\(\forall S_1, S_2 \in C\)</span>，且
<span class="math inline">\(S_1 \ne S_2\)</span>，则 <span
class="math inline">\(S_1 \subset S_2\)</span> 或 <span
class="math inline">\(S_2 \subset S_1\)</span></li>
</ul></li>
<li><p><strong>反链：</strong>若 <span class="math inline">\(C\)</span>
中任意一个子集都不包含在其他子集内，
即任意两个不同的子集都不存在包含关系，则称 <span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的一个反链。</p>
<ul>
<li>一个构造反链的方法：取 <span class="math inline">\(A_k\)</span> 为
<span class="math inline">\(S\)</span> 所有的 <span
class="math inline">\(k\)</span> 子集的集合</li>
</ul></li>
<li><p><strong>链与反链的关系：</strong></p>
<ul>
<li><p><span class="math inline">\(S\)</span> 上的一条链最多只能包含
<span class="math inline">\(S\)</span>
的任意一条反链中的一个子集</p></li>
<li><p><span class="math inline">\(S\)</span> 上的一条反链最多只能包含
<span class="math inline">\(S\)</span> 的任意一条链中的一个子集</p>
<blockquote>
<p>可以有 <span class="math inline">\(0\)</span> 或 <span
class="math inline">\(1\)</span> 个公共元素</p>
</blockquote></li>
<li><p>反证法：设 <span class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的一条链，<span
class="math inline">\(A\)</span> 是 <span
class="math inline">\(S\)</span> 的一条反链。若 <span
class="math inline">\(C\)</span> 包含 <span
class="math inline">\(A\)</span> 中两个子集 <span
class="math inline">\(S_1, S_2\)</span>，则 <span
class="math inline">\(S_1, S_2\)</span> 不存在包含关系，与 <span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的一条链矛盾</p></li>
</ul></li>
<li><p><strong>链与反链的推广：</strong></p>
<ul>
<li>极大元、极小元</li>
</ul></li>
<li><p>一些证明题：todo</p></li>
</ul></li>
<li><p><strong>定理 5.3.3：</strong>设 <span
class="math inline">\(S\)</span> 为 <span
class="math inline">\(n\)</span> 个元素的集合，则 <span
class="math inline">\(S\)</span> 的一个反链最多包含<span
class="math inline">\(\left(\begin{matrix} n \\ \lfloor n/2 \rfloor
\end{matrix}\right)\)</span>个集合。</p></li>
<li><p><strong>最大链：</strong></p>
<ul>
<li><span class="math inline">\(A_0 = \emptyset \subset A_1 \subset A_2
\dots \subset A_n\)</span></li>
<li><span class="math inline">\(|A_i| = i(i = 1, \dots ,
n)\)</span></li>
<li><span class="math inline">\(S\)</span> 的最大链与 <span
class="math inline">\(S\)</span> 的排列一一对应，相应地，最大链的数目为
<span class="math inline">\(n!\)</span></li>
<li>构造方法：
<ul>
<li><span class="math inline">\(A_0 = \emptyset\)</span></li>
<li>从 <span class="math inline">\(S\)</span> 中选择元素 <span
class="math inline">\(i_1\)</span>，<span class="math inline">\(A_1 =
\{i_1\}\)</span></li>
<li>从 <span class="math inline">\(S\)</span> 中选择元素 <span
class="math inline">\(i_2 \ne i_1\)</span>，<span
class="math inline">\(A_2 = \{i_1, i_2\}\)</span></li>
<li><span class="math inline">\(\dots\)</span></li>
<li>从 <span class="math inline">\(S\)</span> 中选择元素 <span
class="math inline">\(i_k \ne i_1, i_2, \dots, i_{k-1}\)</span>，<span
class="math inline">\(A_k = \{i_1, i_2 \dots, i_k\}\)</span></li>
<li><span class="math inline">\(\dots\)</span></li>
<li>从 <span class="math inline">\(S\)</span> 中选择元素 <span
class="math inline">\(i_n \ne i_1, i_2, \dots, i_{n-1}\)</span>，<span
class="math inline">\(A_n = \{i_1, i_2 \dots, i_n\}\)</span></li>
</ul></li>
</ul></li>
<li><p><strong>对称链划分：</strong></p>
<ul>
<li><span class="math inline">\(S\)</span> 的幂集 <span
class="math inline">\(\mathcal{P}(S)\)</span> 的一个链划分
<ul>
<li>链中每一个子集比它前面的子集的元素个数多 <span
class="math inline">\(1\)</span></li>
<li>链中第一个子集与最后一个子集的大小和等于 <span
class="math inline">\(n\)</span></li>
<li>如果只含一个子集，那么既是第一个又是最后一个，大小为 <span
class="math inline">\(\dfrac{n}{2}\)</span></li>
<li>每一个链中必须含有一个 <span class="math inline">\(\lfloor n/2
\rfloor\)</span> 的子集和一个 <span class="math inline">\(\lceil n/2
\rceil\)</span> 的子集</li>
<li>链的个数为 <span class="math inline">\(\left(\begin{matrix} n \\
\lfloor n/2 \rfloor \end{matrix}\right)\)</span></li>
</ul></li>
<li>构造方法：对于 <span class="math inline">\(n=k\)</span>
时的每一个含多个子集的链 <span class="math inline">\(E\)</span>，可构造
<span class="math inline">\(n=k+1\)</span> 时的两个链
<ul>
<li>在 <span class="math inline">\(E\)</span> 的最后一个子集中增加 <span
class="math inline">\(k+1\)</span>，并加入这个新子集</li>
<li>在 <span class="math inline">\(E\)</span>
的除最后一个子集外的所有子集中加入 <span
class="math inline">\(k+1\)</span>，并删除最后一个子集</li>
</ul></li>
</ul></li>
</ul>
<h4 id="多项式定理">5.4 多项式定理</h4>
<ul>
<li><p>把二项式定理 <span class="math inline">\((x+y)^n\)</span>
扩展到<span class="math inline">\((x_1+x_2+ \dots +
x_t)^n\)</span>。其中，多项式系数： <span class="math display">\[
\left(\begin{matrix} n \\ n_1 n_2 \dots n_t \end{matrix}\right) =
\dfrac{n!}{n_1! n_2! \dots n_t!}
\]</span></p></li>
<li><p><strong>定理5.4.1：</strong>设 <span
class="math inline">\(n\)</span> 是正整数，对于所有的 <span
class="math inline">\(x_1, x_2, \dots, x_t\)</span>，有 <span
class="math display">\[
(x_1+x_2+...+x_t)^n=\sum\binom{n}{n_1n_1...n_t}{x_1}^{n_1}{x_2}^{n_2}...{x_t}^{n_t}
\]</span></p></li>
</ul>
<h4 id="牛顿二项式定理">5.5 牛顿二项式定理</h4>
<blockquote>
<p>把二项式定理的指数扩展到实数</p>
</blockquote>
<h3 id="第6章-容斥原理及应用"><strong>第6章 容斥原理及应用</strong></h3>
<blockquote>
<p>解决具有重叠集合的并集的计数原理</p>
</blockquote>
<h4 id="容斥原理">6.1 容斥原理</h4>
<ul>
<li><p><strong>定理6.1.1（容斥原理计数）：</strong>集合 <span
class="math inline">\(S\)</span> 不具有性质 <span
class="math inline">\(P_1,P_2, \dots ,P_m\)</span> 的物体的个数： <span
class="math display">\[
| \overline{A_1} \cap  \overline{A_2} \cap \dots \cap  \overline{A_n}|=
|S| - \sum|A_i| + \sum|A_i \cap A_j| -
\sum |A_i \cap A_j \cap A_k| + \dots +
(-1)^m \sum |A_1 \cap A_2 \cap \dots \cap A_m|
\]</span></p>
<ul>
<li><p>例：求 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(1000\)</span> 不能被 <span
class="math inline">\(5, 6, 8\)</span> 整除的数的个数。</p>
<p>设 <span class="math inline">\(A_1, A_2 ,A_3\)</span> 分别是 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(1000\)</span> 中能被 <span
class="math inline">\(5, 6, 8\)</span> 整除的数集合，那么 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(1000\)</span> 不能被 <span
class="math inline">\(5, 6, 8\)</span> 整除的数的个数为 <span
class="math inline">\(|\overline{A_1} \cap \overline{A_2} \cap
\overline{A_3}|\)</span> <span class="math display">\[
\begin{aligned}
|A_1| &amp;= \lfloor 1000/5 \rfloor = 200 \\
|A_2| &amp;= \lfloor 1000/6 \rfloor = 166 \\
|A_3| &amp;= \lfloor 1000/8 \rfloor = 125 \\
|A_1 \cap A_2| &amp;= \lfloor 1000/30 \rfloor = 33 \\
|A_1 \cap A_3| &amp;= \lfloor 1000/40 \rfloor = 25 \\
|A_2 \cap A_3| &amp;= \lfloor 1000/24 \rfloor = 41 \\
|A_1 \cap A_2 \cap A_3| &amp;= \lfloor 1000/120 \rfloor = 8 \\
\end{aligned}
\]</span> 由容斥原理，原式 <span
class="math inline">\(=1000-(200+166+125)+(33+25+41)-8=600\)</span></p></li>
<li><p>例：从 <span class="math inline">\(0\)</span> 到 <span
class="math inline">\(99999\)</span> 中有多少同时含有数字 <span
class="math inline">\(2, 5, 8\)</span> 的整数。</p>
<p>设 <span class="math inline">\(A_1, A2, A_3\)</span> 分别是不包含数字
<span class="math inline">\(2, 5, 8\)</span> 的集合。 <span
class="math display">\[
\alpha_1 = |A_1| = |A_2| = |A_3| = 9^5 \\
\alpha_2 = |A_1 \cap A_2| = 8^5 \\
\alpha_3 = |A_1 \cap A_2 \cap A_3| = 7^5
\]</span> 满足题意的整数个数为 <span class="math inline">\(10^5 - 3
\times 9^5 + 3 \times 8^5 -7^5\)</span></p></li>
</ul></li>
<li><p><strong>推论6.1.2（容斥原理计数）：</strong>集合 <span
class="math inline">\(S\)</span> 至少具有性质 <span
class="math inline">\(P_1,P_2, \dots ,P_m\)</span> 之一的物体的个数：
<span class="math display">\[
| A_1 \cup  {A_2} \cup \dots \cup  A_n|=
\sum|A_i| - \sum|A_i \cap A_j| +
\sum |A_i \cap A_j \cap A_k| + \dots +
(-1)^{m+1} \sum |A_1 \cap A_2 \cap \dots \cap A_m|
\]</span></p>
<blockquote>
<p>用总数 - 6.1.1</p>
</blockquote></li>
</ul>
<h4 id="带重复的组合">6.2 带重复的组合</h4>
<ul>
<li><p>例：确定多重集 <span class="math inline">\(T=\{3 \cdot a, 4 \cdot
b, 5 \cdot c\}\)</span> 的 <span class="math inline">\(10\)</span>
子集的个数。</p>
<ul>
<li><p>令多重集 <span class="math inline">\(T^*=\{\infty \cdot a, \infty
\cdot b, \infty \cdot c\}\)</span> 的所有 <span
class="math inline">\(10\)</span> 子集的集合为 <span
class="math inline">\(S\)</span>。</p>
<blockquote>
<p>用于下文无穷集取方案表述方便</p>
</blockquote>
<p><span class="math inline">\(A_1\)</span> 是 <span
class="math inline">\(S\)</span> 中包含多于 <span
class="math inline">\(3\)</span> 个 <span
class="math inline">\(a\)</span> 的 <span
class="math inline">\(10\)</span> 子集的集合；<span
class="math inline">\(A_2\)</span> 是 <span
class="math inline">\(S\)</span> 中包含多于 <span
class="math inline">\(4\)</span> 个 <span
class="math inline">\(b\)</span> 的 <span
class="math inline">\(10\)</span> 子集的集合；<span
class="math inline">\(A_3\)</span> 是 <span
class="math inline">\(S\)</span> 中包含多于 <span
class="math inline">\(5\)</span> 个 <span
class="math inline">\(c\)</span> 的 <span
class="math inline">\(10\)</span>子集的集合。</p>
<p>那么，<span class="math inline">\(T\)</span> 的 <span
class="math inline">\(10\)</span> - 组合数等于 <span
class="math inline">\(|\overline{A_1} \cap \overline{A_2} \cap
\overline{A_3}|\)</span>。</p>
<ul>
<li><span class="math inline">\(A_1\)</span> 中的每个子集中 <span
class="math inline">\(a\)</span> 至少出现 <span
class="math inline">\(4\)</span> 次，剩下 <span
class="math inline">\(6\)</span> 个元素可以是 <span
class="math inline">\(T*\)</span> 的任何 <span
class="math inline">\(6\)</span> - 组合，因此：（其余类推）</li>
</ul>
<p><span class="math display">\[
|A_1| =
\left( \begin{matrix} 6+3-1 \\ 6 \end{matrix} \right) =
\left( \begin{matrix} 8 \\ 6 \end{matrix} \right) = 28
\]</span></p>
<ul>
<li><span class="math inline">\(A_1 \cap A_2\)</span> 中的每个子集中
<span class="math inline">\(a\)</span> 至少出现 <span
class="math inline">\(4\)</span> 次同时 <span
class="math inline">\(b\)</span> 至少出现 <span
class="math inline">\(5\)</span> 次，剩下 <span
class="math inline">\(1\)</span> 个元素可以是 <span
class="math inline">\(T*\)</span> 的任何 <span
class="math inline">\(1\)</span> 组合，因此：</li>
</ul>
<p><span class="math display">\[
|A_1 \cap A_2| =
\left( \begin{matrix} 1+3-1 \\ 1 \end{matrix} \right) =
\left( \begin{matrix} 3 \\ 1 \end{matrix} \right) = 3
\]</span></p>
<blockquote>
<p>这个地方先取 <span class="math inline">\(4\)</span> 个 <span
class="math inline">\(a\)</span>，后面仍可以从无穷集 <span
class="math inline">\(T^*\)</span> 中取 <span
class="math inline">\(a\)</span>，保证了情况是完备的</p>
</blockquote></li>
</ul></li>
<li><p>例：求满足 <span class="math inline">\(1 \leq x_1 \leq 5, -2 \leq
x_2 \leq 4, 0 \leq x_3 \leq 5, 3 \leq x_4 \leq 9\)</span> 的方程 <span
class="math inline">\(x_1+x_2+x_3+x_4 =18\)</span>的整数解个数。</p>
<ul>
<li>转化为“确定多重集 <span class="math inline">\(T=\{4 \cdot a, 6 \cdot
b, 5 \cdot c, 6 \cdot d\}\)</span> 的 <span
class="math inline">\(16\)</span> 子集的个数”，解法与上类似</li>
</ul></li>
</ul>
<h4 id="错位排列-derangement">6.3 错位排列 Derangement</h4>
<ul>
<li><p><strong>错位排列：</strong> 设 <span
class="math inline">\(X={1,2, \dots ,n}\)</span>，它的排列用 <span
class="math inline">\(i_1 i_2 \dots i_n\)</span> 表示, 错位排列是使得
<span class="math inline">\(i_1 \neq 1, i_2 \neq 2,\dots, i_n \neq
n\)</span> 的排列。用<span
class="math inline">\(D_n\)</span>表示错位排列个数。</p>
<ul>
<li>前几项：<span class="math inline">\(D_1 = 0，D_2 = 1，D_3 = 2，D_4 =
9\)</span></li>
</ul></li>
<li><p><strong>定理6.3.1：</strong> 对 <span class="math inline">\(n
\geq 1\)</span>，（应用容斥原理） <span class="math display">\[
D_n=n!-\binom{n}{1}(n-1)!+\binom{n}{2}(n-2)!+...+(-1)^n\binom{n}{n}0!
\]</span></p>
<p><span class="math display">\[
D_n = n! \ (1 - \dfrac{1}{1!} + \dfrac{1}{2!} - \dfrac{1}{3!} + \dots +
(-1)^n \dfrac{1}{n!})
\]</span></p>
<ul>
<li>计算可得：<span class="math inline">\(D_5=44, D_6=265, D_7=1854,
D_8=14833\)</span></li>
</ul></li>
<li><p>例：确定 <span class="math inline">\({1, 2,…, 8}\)</span>
的排列中恰有四个整数在它们的自然位置上的排列数。</p>
<ul>
<li><p>解：任选四个整数在自然位置上：<span
class="math inline">\(\begin{pmatrix} 8 \\ 4 \end{pmatrix}\)</span></p>
<p>剩下四个整数不在其自然位置上： <span
class="math inline">\(D_4\)</span></p>
<p>因此，恰有四个整数在它们的自然位置上的排列数为<span
class="math inline">\(\begin{pmatrix} 8 \\ 4 \end{pmatrix}
D_4\)</span></p></li>
</ul></li>
<li><p><strong>错位排列的递推关系1：</strong><span
class="math inline">\(D_n\)</span> 满足如下递推关系： <span
class="math display">\[
D_n = (n-1)(D_{n-2} + D_{n-1}), (n=3,4,\dots) \\
D_2 = 1; D_1 = 0
\]</span> <strong>计算用的递推关系2：</strong> <span
class="math display">\[
D_n = nD_{n-1} + (-1)^n
\]</span></p></li>
</ul>
<h4 id="带有禁止位置的排列">6.4 带有禁止位置的排列</h4>
<ul>
<li><p><strong>带禁止位置的“非攻击型车”：</strong><span
class="math inline">\(\{1,2,…, n\}\)</span> 的排列 <span
class="math inline">\(i_1 i_2 \dots i_n\)</span> 对应于棋盘上以方格
<span class="math inline">\((1, i_1), (2, i_2),\dots, (n, i_n)\)</span>
为坐标的 <span class="math inline">\(n\)</span>
个车的位置。一些位置禁止。</p></li>
<li><p><strong>定理6.4.1：</strong> 将 <span
class="math inline">\(n\)</span>
个非攻击型不可区分的车放到带有禁止位置的 <span class="math inline">\(n
\times n\)</span> 的棋盘中，放法总数等于： <span class="math display">\[
n! - r_1 (n-1)! +  r_2 (n-2)! - \dots + (-1)^k r_k (n-k)! + \dots +
(-1)^n r_n
\]</span></p>
<ul>
<li><span class="math inline">\(r_k\)</span>：所有的 <span
class="math inline">\(k\)</span>
个车放置在其禁止位置上的放置方法数，<span class="math inline">\(k=1,2,…,
n\)</span>，且其计算不考虑剩下的 <span
class="math inline">\(n-k\)</span> 个车的放置</li>
<li>应满足：任意两个车不在同一行或同一列</li>
</ul></li>
</ul>
<h4 id="另一个禁止位置问题">6.5 另一个禁止位置问题</h4>
<ul>
<li><p><strong>相对禁止位置排列计数：</strong><span
class="math inline">\(Q_n\)</span>：<span class="math inline">\(\{1, 2,
\dots , n\}\)</span> 的排列中没有 <span class="math inline">\(12, 23,
\dots , (n-1)n\)</span> 这些模式出现的排列的个数</p>
<ul>
<li>前几项：<span class="math inline">\(Q_1= 1， Q_2 = 1, Q_3 = 3, Q_4 =
11\)</span></li>
</ul></li>
<li><p><strong>用容斥原理计算 <span
class="math inline">\(Q_n\)</span>：</strong>令 <span
class="math inline">\(A_i\)</span> 是 <span
class="math inline">\(i(i+1)\)</span> 出现的排列的集合，<span
class="math inline">\(i=1,2,\dots,n-1\)</span></p>
<ul>
<li><p>计算 <span class="math inline">\(A_i\)</span> : <span
class="math inline">\(A_1\)</span> 可看作 <span
class="math inline">\(1,2, 3,\dots, n\)</span> 的所有排列的集合，因此
<span class="math inline">\(|A_1|=(n-1)!\)</span>。
显然，由于对称性，对任意 <span
class="math inline">\(i\)</span>，都有<span
class="math inline">\(|A_i|=(n-1)!\)</span></p></li>
<li><p>计算<span class="math inline">\(|A_i \cap
A_j|\)</span>：讨论两种情况：</p>
<ol type="1">
<li><span class="math inline">\(A_i \cap A_{i+1}\)</span>。可看作 <span
class="math inline">\(1, 2, …, (i, i+1, i+2), i+3, …, n\)</span> 的所有
排列的集合，因此<span class="math inline">\(|A_i \cap
A_{i+1}|=(n-2)!\)</span></li>
<li><span class="math inline">\(A_i \cap A_j\)</span>，其中 <span
class="math inline">\(j&gt;i+1\)</span>。可看作 <span
class="math inline">\(1,2,…, (i, i+1), i+2, …, ( j, j+1), …, n\)</span>
的所有排列的集合，因此<span class="math inline">\(|A_i \cap
A_j|=(n-2)!\)</span></li>
</ol>
<p>所以，对任意 <span class="math inline">\(i, j\)</span>，都有<span
class="math inline">\(|A_i \cap A_j|=(n-2)!\)</span></p></li>
<li><p>同理可证 ，对于每个 <span class="math inline">\(k\)</span> 子集
<span class="math inline">\(\{i_1,…, i_k\}\)</span>，有 <span
class="math inline">\(|A_{i_1} \cap A_{i_2} \cap \dots \cap
A_{i_k}|=(n-k)!\)</span></p></li>
<li><p>由此推出下面公式。</p></li>
</ul></li>
<li><p><strong>定理6.5.1：</strong>对于 <span class="math inline">\(n
\ge 1\)</span> <span class="math display">\[
\begin{align}
Q_n &amp;= n! + \sum_{k=1}^{n-1} (-1)^k
\left( \begin{matrix} n-1 \\ k \end{matrix} \right) (n-k)!    \\
&amp;= n! -
\left( \begin{matrix} n-1 \\ 1 \end{matrix} \right) (n-1)! +
\left( \begin{matrix} n-1 \\ 2 \end{matrix} \right) (n-2)! + \dots +
(-1)^{n-1} \left( \begin{matrix} n-1 \\ n-1 \end{matrix} \right) 1!
\end{align}
\]</span></p></li>
<li><p>例：旋转木马有 <span class="math inline">\(8\)</span>
个座，每个座位都代表一种不同的动物。<span
class="math inline">\(8\)</span>
个男孩脸朝里围坐在旋转木马上，使得每一个男孩都面对到另一个男孩。他们能够有多少种方法改变座位使得每人面对的男孩都不同于之前面对的男孩？</p>
<ul>
<li>假设 <span class="math inline">\(8\)</span> 个男孩分成了四对：<span
class="math inline">\((1,5), (2,6), (3,7), (4,8)\)</span>。 假设 <span
class="math inline">\(A_1, A_2, A_3, A_4\)</span> 分别表示仍然有 <span
class="math inline">\((1,5), (2,6), (3,7), (4,8)\)</span>
出现的坐法的集合。则使得每人面对的男孩都不同的坐法的数目为：<span
class="math inline">\(|\overline{A_1} \cap \overline{A_2} \cap
\overline{A_3} \cap \overline{A_4}|\)</span></li>
</ul>
<p><span class="math display">\[
|A_1| = |A_i| = 8 * 6! \\
|A_1 \cap A_2| = 8 * 6 * 4! \\
|A_1 \cap A_2 \cap A_3| = 8 * 6 * 4*2! \\
|A_1 \cap A_2 \cap A_3 \cap A_4| = 8 * 6 * 4 * 2
\]</span></p></li>
<li><p>相对禁止位置 <span class="math inline">\(Q_n\)</span> 与错位排列
<span class="math inline">\(D_n\)</span> 的关系： <span
class="math display">\[
Q_n = D_n + D_{n-1}
\]</span></p></li>
</ul>
<h3 id="第7章-递推关系和生成函数"><strong>第7章
递推关系和生成函数</strong></h3>
<blockquote>
<p>生成函数核心思想：</p>
<ol type="1">
<li>把离散数列和幂级数一一对应起来</li>
<li>把离散数列间的相互结合关系对应成为幂级数间的运算关系</li>
<li>由幂级数形式确定离散数列的构造</li>
</ol>
</blockquote>
<blockquote>
<p><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611140632902.png" alt="image-20230611140632902" style="zoom:50%;" /></p>
</blockquote>
<h4 id="若干数列">7.1 若干数列</h4>
<ul>
<li><p>例：设 <span class="math inline">\(h_n\)</span> 是 <span
class="math inline">\(1\)</span> 行 <span
class="math inline">\(n\)</span>
列棋盘用红黄蓝三种颜色着色并使得没有着成红色的方格相邻的着色方法数。求
<span class="math inline">\(h_n\)</span> 满足的递推关系。</p>
<ul>
<li><p>末尾为红：必须前面再放黄色or蓝色保证不相邻 <span
class="math inline">\(2h_{n-2}\)</span></p></li>
<li><p>末尾为蓝or黄：直接拼接即可 <span
class="math inline">\(2h_{n-1}\)</span></p></li>
</ul></li>
<li><p>例：确定 <span class="math inline">\(2 \times n\)</span>
棋盘用多米诺牌完全覆盖的方法数 <span
class="math inline">\(h_n\)</span></p></li>
<li><p>例：确定用单牌和多米诺牌完美覆盖 <span class="math inline">\(1
\times n\)</span> 棋盘的方法数 <span
class="math inline">\(b_n\)</span></p></li>
<li><p><strong><span class="math inline">\(Fibonacci\)</span>
数列：</strong></p>
<ul>
<li>部分和：<span class="math inline">\(s_n = f_0+f_1+ \dots +f_n =
f_{n+2}-1\)</span>
<ul>
<li>证明：数学归纳法</li>
</ul></li>
<li><span class="math inline">\(f_n\)</span> 是偶数当且仅当 <span
class="math inline">\(n\)</span> 被 <span
class="math inline">\(3\)</span> 整除
<ul>
<li>每三项都是偶奇奇</li>
</ul></li>
</ul></li>
<li><p><strong>定理7.1.2：</strong>沿 <span
class="math inline">\(Pascal\)</span>
三角形从左下到右上的对角线上的二项式系数和是斐波那契数，即 <span
class="math display">\[
f_n =
\left( \begin{matrix} n-1 \\ 0 \end{matrix} \right) +
\left( \begin{matrix} n-2 \\ 1 \end{matrix} \right) +
\left( \begin{matrix} n-3 \\ 2 \end{matrix} \right) + \dots +
\left( \begin{matrix} n-k \\ k-1 \end{matrix} \right)
\]</span> 其中，<span class="math inline">\(k=\lfloor (n+1)/2
\rfloor\)</span></p></li>
</ul>
<h4 id="生成函数">7.2 生成函数</h4>
<ul>
<li>令 <span class="math inline">\(h_0, h_1, \dots ,h_n \dots\)</span>
为一无穷数列，其生成函数定义为：</li>
</ul>
<p><span class="math display">\[
g(x)=h_0 +h_1x+h_2x^2+\dots+h_nx^n+\dots
\]</span></p>
<ul>
<li><p>例：设 <span class="math inline">\(k\)</span> 是正整数，<span
class="math inline">\(h_n\)</span> 等于方程 <span
class="math inline">\(e_1+e_2+ \dots +e_k =n\)</span>
的非负整数解个数，即 <span class="math inline">\(h_n\)</span> 为多重集
$S={a_1, a_2, , a_k} $的 <span class="math inline">\(n\)</span> -
组合个数，求数列 <span class="math inline">\(h_0, h_1,…, h_n…\)</span>
的生成函数 <span class="math inline">\(g(x)\)</span>。</p>
<ul>
<li>由于<span class="math inline">\(h_n = \left( \begin{matrix} n+k-1 \\
n \end{matrix} \right)\)</span>。因此，</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
g(x) &amp;= \sum_{n=0}^\infty
\left( \begin{matrix} n+k-1 \\ n \end{matrix} \right) x^n =
\dfrac{1}{(1-x)^k} \ (|x|&lt;1)  \\
&amp;= (\sum_{e_1=0}^\infty x^{e_1})
(\sum_{e_2=0}^\infty x^{e_2}) \dots
(\sum_{e_k=0}^\infty x^{e_k})
\end{aligned}
\]</span></p></li>
<li><p>例：设 <span class="math inline">\(S\)</span> 是多重集合${a_1,
a_2, a_3 , a_4} $。确定数列 <span class="math inline">\(h_0, h_1,…, h_n,
…\)</span> 的生成函数，其中 <span class="math inline">\(h_n\)</span>
是满足以下约束的 <span class="math inline">\(S\)</span> 的 <span
class="math inline">\(n\)</span> 组合数。 (1) <span
class="math inline">\(a_1\)</span> 出现奇数次，<span
class="math inline">\(a_2\)</span> 出现偶数次。 (2) 元素 <span
class="math inline">\(a_1\)</span> 不会出现，<span
class="math inline">\(a_2\)</span> 至多出现 <span
class="math inline">\(1\)</span> 次。 (3) 每个 <span
class="math inline">\(a_i\)</span> 出现的次数是 <span
class="math inline">\(3\)</span> 的倍数。</p>
<ul>
<li>解: (1) 生成函数 <span class="math display">\[
\begin{align}
g(x)
&amp;=(x+x^3+x^5+...+x^{2n+1}+...) (1+x^2+x^4+...+x^{2n}+...)
(1+x+x^2+...+x^n+...)^2 \\
&amp;=x(1+x^2+x^4+...+x^{2n}+...)^2 (1+x+x^2+...+x^n+...)^2 \\
&amp;= x(\dfrac{1}{1-x^2})^2 (\dfrac{1}{1-x})^2
\end{align}
\]</span>
<ol start="2" type="1">
<li><p>生成函数 <span class="math inline">\(g(x) =1
(1+x)(1+x+x^2+…+x^n+…)^2= (1+x)/(1-x)^2\)</span></p></li>
<li><p>生成函数 <span class="math inline">\(g(x) =
(1+x^3+x^6+…x^{3n}+…)^4 = 1/(1-x^3)^4\)</span></p></li>
</ol></li>
</ul></li>
<li><p>例：由生成函数求通项 <span
class="math inline">\(h_n\)</span></p></li>
<li><p><strong>几个常见的展开式：</strong> <span class="math display">\[
(1-x)^n = \sum_{k=0}^\infty \left( \begin{matrix} n \\ k \end{matrix}
\right) x^k \\
\dfrac{1}{(1-x)^n} = \sum_{k=0}^\infty \left( \begin{matrix} n+k-1 \\ k
\end{matrix} \right) x^k
\]</span></p>
<ul>
<li><span class="math inline">\(+x\)</span> 用 <span
class="math inline">\(-x\)</span> 带入 <span
class="math inline">\(x\)</span> 即可</li>
</ul></li>
<li><p>例：求装有苹果、香蕉、桔子和梨的果篮的数量 <span
class="math inline">\(h_n\)</span>，其中每个果篮中，苹果的个数是偶数，香蕉的个数是
<span class="math inline">\(5\)</span> 的倍数, 桔子不超过 <span
class="math inline">\(4\)</span> 个，而且至多只有一个梨. <span
class="math display">\[
\begin{align}
g(x) &amp;=(1+x^2+x^4+…)( 1+x^5+x^{10}+x^{15}+…)(1+x+x^2+x^3+x^4)(
1+x)   \\
&amp;= \dfrac{1}{1-x^2} \cdot \dfrac{1}{1-x^5} \cdot \dfrac{1-x^5}{1-x}
\cdot (1+x)   \\
&amp;= \dfrac{1}{(1-x)^2} \\
&amp;= \sum_{n=0}^\infty \left( \begin{matrix} n+1 \\ n \end{matrix}
\right) x^n  \\
&amp;= \sum_{n=0}^\infty (n+1) x^n
\end{align}
\]</span> 因此，满足条件的 <span class="math inline">\(n\)</span>
组合个数为 <span class="math inline">\(h_n =n+1\)</span>。</p></li>
<li><p>例（带系数）：设 <span class="math inline">\(h_n\)</span> 是方程
<span class="math inline">\(3e_1+4e_2+2e_3+5e_4=n\)</span>
的非负整数解的个数，求序列 <span class="math inline">\(h_0, h_1,
…,h_n,…\)</span> 的生成函数.</p>
<blockquote>
<p>生成函数针对的是系数为 <span class="math inline">\(1\)</span>
的情况，所以化归一下，化成系数为 <span class="math inline">\(1\)</span>
即可</p>
</blockquote>
<p>作变量替换 <span class="math inline">\(f_1=3e_1, f_2=4e_2, f_3=2e_3,
f_4=5e_4\)</span> 得到 <span class="math inline">\(f_1+f_2+f_3+f_4=n
\quad (1)\)</span></p>
<p>因此，<span class="math inline">\(h_n\)</span> 等于方程 <span
class="math inline">\((1)\)</span> 的非负整数解的个数，满足 <span
class="math inline">\(f_1\)</span> 是 <span
class="math inline">\(3\)</span> 的倍数，<span
class="math inline">\(f_2\)</span> 是 <span
class="math inline">\(4\)</span> 的倍数，<span
class="math inline">\(f_3\)</span> 是 <span
class="math inline">\(2\)</span> 的倍数，<span
class="math inline">\(f_4\)</span> 是 <span
class="math inline">\(5\)</span> 的倍数。</p>
<p>因此，生成函数为 <span class="math display">\[
\begin{align}
g(x) &amp;=(1+x^3+x^6+…)(1+x^4+x^8+…)(1+x^2+x^4+…)(1+x^5+x^{10}+…) \\
&amp;=\dfrac{1}{1-x^3}\cdot\dfrac{1}{1-x^4}\cdot\dfrac{1}{1-x^2}\cdot\dfrac{1}{1-x^5}
\end{align}
\]</span></p></li>
</ul>
<h4 id="指数生成函数">7.3 指数生成函数</h4>
<ul>
<li><p>数列 <span class="math inline">\(h_0,h_1,h_2, \dots ,h_n\)</span>
的指数生成函数定义为： <span class="math display">\[
g^{(e)}(x) = h_0 + \dfrac{h_1}{1!} x +
\dfrac{h_2}{2!} x^2 + \dfrac{h_3}{3!} x^3 + \dots +
\dfrac{h_k}{k!} x^k + \dots
\]</span></p></li>
<li><p><strong>带有附加限制的多重集合 <span
class="math inline">\(n\)</span> 排列数列：</strong></p>
<ul>
<li><p>例：用红、蓝、黄三种颜色给 <span class="math inline">\(1 \times
n\)</span>
的棋盘着色，如果要求被着成红色的方格数是偶数，确定给这个棋盘着色的方法数
<span class="math inline">\(h_n\)</span>。</p>
<p>设 <span class="math inline">\(h_n\)</span> 表示着色的方法数，定义
<span class="math inline">\(h_0=1\)</span>。 显然，<span
class="math inline">\(h_n\)</span> 等于 <span
class="math inline">\(3\)</span> 种颜色的多重集合的 <span
class="math inline">\(n\)</span>
排列数，其中每种颜色的重数是无穷的，且要求红色出现的次数是偶数。
因此，指数生成函数为 <span class="math display">\[
\begin{align}
g^{(e)}(x) &amp;= (1 + \dfrac{x^2}{2!} + \dfrac{x^4}{4!} + \dots)
(1 + \dfrac{x^1}{1!} + \dfrac{x^2}{2!} + \dots)
(1 + \dfrac{x^1}{1!} + \dfrac{x^2}{2!} + \dots) \\
&amp;= \dfrac{1}{2}(e^x+e^{-x})e^x e^x = \dfrac{1}{2} (e^{3x}+e^x)  \\
&amp;= \dfrac{1}{2} (\sum_{n=0}^\infty 3^n \dfrac{x^n}{n!} +
\sum_{n=0}^\infty \dfrac{x^n}{n!})
= \dfrac{1}{2} \sum_{n=0}^\infty (3^n+1) \dfrac{x^n}{n!}
\end{align}
\]</span> 得$ h_n=(3^n+1)/2$。</p></li>
</ul></li>
<li><p><strong>常见展开</strong> <span class="math display">\[
e^x = \sum_{n=0}^\infty \dfrac{x^n}{n!}
= 1 + x + \dfrac{x^2}{2!} + \dots + \dfrac{x^n}{n!} + \dots   \\
\dfrac{1}{2} (e^x+e^{-x})  = 1 + \dfrac{x^2}{2!} + \dfrac{x^4}{4!} +
\dots + \dfrac{x^{2n}}{2n!} + \dots    \\
\dfrac{1}{2} (e^x-e^{-x})  = x + \dfrac{x^3}{3!} + \dfrac{x^5}{5!} +
\dots + \dfrac{x^{2n+1}}{(2n+1)!} + \dots
\]</span></p></li>
</ul>
<h4 id="求解线性齐次递推关系">7.4 求解线性齐次递推关系</h4>
<ul>
<li><p><strong>（齐次）线性递推关系：</strong>令 <span
class="math inline">\(h_0, h_1, h_2,…, h_n,…\)</span>
是一个数列，若存在量 <span class="math inline">\(a_1, a_2,…,a_k\)</span>
和量 <span
class="math inline">\(b_n\)</span>（每个量是常数或<strong>依赖于 <span
class="math inline">\(n\)</span> 的数</strong>）使得： <span
class="math display">\[
h_n = a_1 h_{n-1} +  a_2 h_{n-2} + \dots +  a_k h_{n-k} +b_n \ (n \geq
k)
\]</span> 则称该数列满足 <strong><span
class="math inline">\(k\)</span></strong> 阶线性递推关系</p>
<p>若 <span class="math inline">\(b_n =0\)</span>，则称该数列是 <span
class="math inline">\(k\)</span> 阶线性齐次递推关系</p>
<p>若 <span class="math inline">\(a_1, a_2, \dots, a_k\)</span>
都为常数，则称该数列是 <span class="math inline">\(k\)</span>
阶常系数线性递推关系</p>
<blockquote>
<p>解法：</p>
<ul>
<li>特征方程法</li>
<li>生成函数法</li>
</ul>
</blockquote></li>
<li><p><strong>定理7.4.1（特征方程与原递推关系同解）：</strong>令 <span
class="math inline">\(q\)</span> 为一个非零数，则 <span
class="math inline">\(h_n =q_n\)</span> 是常系数线性齐次递推关系 <span
class="math display">\[
h_n = a_1 h_{n-1} +  a_2 h_{n-2} + \dots +  a_k h_{n-k} +b_n \ (a_k \neq
0, n \geq k)
\]</span> 的解当且仅当 <span
class="math inline">\(q\)</span>（特征根）是多项式方程 <span
class="math display">\[
x^k - a_1 x_{k-1} - a_2 x_{k-2} - \dots - a_{k-1} x -a_k = 0
\]</span> 的一个根。</p>
<p>若特征根多项式方程有 <span class="math inline">\(k\)</span>
个不同的根 <span class="math inline">\(q_1, q_2,…, q_k\)</span>，则
<span class="math display">\[
h_n = c_1 q_1 ^n  +  c_2 q_2 ^n + \dots +  c_k q_k ^n
\]</span> 是下述意义下原递推关系的通解：任意给定初始值 <span
class="math inline">\(h_0, h_1, …,h_{k-1}\)</span>，都存在 <span
class="math inline">\(c_1, c_2,…, c_k\)</span>
使得上式是满足原递推关系式和初始条件的唯一的数列.</p>
<blockquote>
<p>线性组合的意思</p>
</blockquote></li>
<li><p>例：确定由 <span class="math inline">\(0, 1, 2\)</span>
组成的长度为 <span class="math inline">\(n\)</span> 且不包含两个连续的
<span class="math inline">\(0\)</span> 或两个连续的 <span
class="math inline">\(1\)</span> 的三进制串的个数 <span
class="math inline">\(a_n\)</span> 的递推关系，然后求出 <span
class="math inline">\(a_n\)</span> 的公式。</p>
<ul>
<li><p>解: 当 <span class="math inline">\(n=0\)</span> 时，为空串，此时
<span class="math inline">\(a_0=1\)</span>；</p>
<p>当 <span class="math inline">\(n=1\)</span> 时, 满足条件的三进制串为
<span class="math inline">\(0, 1, 2\)</span>，得 <span
class="math inline">\(a_1=3\)</span></p>
<p>当 <span class="math inline">\(n&gt;1\)</span> 时，设以 <span
class="math inline">\(0，1，2\)</span> 开头的长度为三进制串的个数分别为
<span class="math inline">\(b_n, c_n, d_n\)</span>，则 <span
class="math inline">\(a_n =b_n+c_n+d_n\)</span>。</p>
<ol type="a">
<li><p>当以 <span class="math inline">\(0\)</span> 开头时，<span
class="math inline">\(b_n=c_{n-1}+d_{n-1} \quad (1)\)</span></p></li>
<li><p>当以 <span class="math inline">\(1\)</span> 开头时，<span
class="math inline">\(c_n=b_{n-1}+d_{n-1} \quad (2)\)</span></p></li>
<li><p>当以 <span class="math inline">\(2\)</span> 开头时，<span
class="math inline">\(d_n=b_{n-1}+c_{n-1}+d_{n-1}=a_{n-1} \quad
(3)\)</span></p></li>
</ol>
<p>把 <span class="math inline">\((1), (2), (3)\)</span>
式左右两边分别相加得：<span class="math inline">\(a_n = b_n+c_n+d_n =
c_{n-1}+d_{n-1}+b_{n-1}+d_{n-1}+a_{n-1} = a_{n-1}+a_{n-2}+a_{n-1} =
2a_{n-1} + a_{n-2}\)</span></p></li>
</ul></li>
<li><p>例：利用<strong>生成函数</strong>求解 <span
class="math inline">\(h_n=h_{n-1}+9h_{n-2}-9h_{n-3} (n&gt;2), h_0=0,
h_1=1, h_2=2\)</span>。（配凑递推式的系数）</p>
<ul>
<li><p>令生成函数为 <span
class="math inline">\(g(x)=h_0+h_1x+h_2x^2+…+h_nx^n+… \quad
(1)\)</span></p>
<p><span class="math inline">\((1)\)</span> 式两边分别同乘 <span
class="math inline">\(–x, -9x^2, 9x^3\)</span> , 得 <span
class="math display">\[
\begin{aligned}
&amp;(1-x-9x^2+9x^3) g(x) \\
&amp;= h_0 + (h_1-h_0)x+(h_2-h_1-9h_0)x^2+(h_3-h_2-9h_1+9h_0)x +… \\
&amp;= h_0 + (h_1-h_0)x+(h_2-h_1-9h_0)x^2 \\
&amp;= x+x^2
\end{aligned}
\]</span> 得<span class="math inline">\(g(x) =(x+x^2)/(1-x-9x^2+9x^3) =
(x+x^2)/(1-x)(1-3x)(1+3x)\)</span>，再求得 <span
class="math inline">\(h_n\)</span></p></li>
</ul></li>
<li><p>例：求解递推关系 <span
class="math inline">\(h_n+h_{n-1}-16h_{n-2}+20h_{n-3}=0 (n \ge
3)\)</span> 其中 <span class="math inline">\(h_0=0, h_1=1, h_2=
-1\)</span>.</p>
<ul>
<li><ol type="1">
<li>求数列的生成函数。<span
class="math inline">\(g(x)=x/(1+x-16x^2+20x^3)\)</span></li>
</ol></li>
<li><ol start="2" type="1">
<li>将 <span class="math inline">\(g(x)\)</span> 表示成代数分式和。由于
<span
class="math inline">\((1+x-16x^2+20x^3)=(1-2x)^2(1+5x)\)</span>，得到
<span class="math display">\[
\begin{align}
g(x)&amp; = \dfrac{x}{(1-2x)^2(1+5x)}   \\
&amp;= \dfrac{c_1}{1-2x} + \dfrac{c_2}{(1-2x)^2} +
\dfrac{c_3}{1+5x}    \\
&amp;= -\dfrac{2/49}{1-2x} + \dfrac{7/49}{(1-2x)^2} - \dfrac{5/49}{1+5x}
\end{align}
\]</span></li>
</ol></li>
<li><ol start="3" type="1">
<li>利用牛顿二项式定理展开。 <span class="math display">\[
\dfrac{1}{1-2x} = \sum_{k=0}^\infty 2^k x^k \\
\dfrac{1}{(1-2x)^2} = \sum_{k=0}^\infty
\left( \begin{matrix} k+1 \\ k \end{matrix} \right) 2^k x^k =
\sum_{k=0}^\infty (k+1) 2^k x^k \\
\dfrac{1}{1+5x} = \sum_{k=0}^\infty (-5)^k x^k
\]</span> 于是得到： <span class="math display">\[
g(x) = \sum_{k=0}^\infty
[-\dfrac{2}{49}2^k + \dfrac{7}{49} (k+1) 2^k - \dfrac{5}{49}(-5)^k] x^k
\\
h_n = -\dfrac{2}{49}2^n + \dfrac{7}{49} (n+1) 2^n - \dfrac{5}{49}(-5)^n
\]</span></li>
</ol></li>
</ul></li>
</ul>
<h4 id="非齐次递推关系">7.5 非齐次递推关系</h4>
<ul>
<li><p><strong>一般非齐次递推关系的通解：</strong>假设有非齐次递推关系
<span class="math inline">\(h_n = a_1 h_{n-1} + a_2 h_{n-2} + \dots +
a_k h_{n-k} +b_n\)</span></p>
<p>若 <span class="math inline">\(f_n\)</span> 是对应齐次递推关系 <span
class="math inline">\(h_n&#39; = h_n - b_n = a_1 h_{n-1} + a_2 h_{n-2} +
\dots + a_k h_{n-k}\)</span> 的通解，而 <span
class="math inline">\(c_n\)</span> 是原非齐次递推关系 <span
class="math inline">\((1)\)</span> 的一个特解，那么 <span
class="math inline">\(h_n = c f_n + c_n\)</span> 是原非齐次递推关系
<span class="math inline">\((1)\)</span> 的通解。</p></li>
<li><p>例：求递推关系 <span class="math inline">\(h_n=3h_{n-1}-4n,
h_0=2\)</span>.</p>
<ul>
<li><p>（1）首先求解对应的齐次递推关系 <span
class="math inline">\(h_n=3h_{n-1}\)</span> 的通解。 特征方程为 <span
class="math inline">\(x-3=0\)</span>，特征根为 <span
class="math inline">\(x=3\)</span>，因此通解为 <span
class="math inline">\(h_n =c3^n\)</span></p></li>
<li><p>（2）求 <span class="math inline">\(h_n=3h_{n-1}-4n\)</span>
的一个特解： 猜测解的形式 <span class="math inline">\(h_n
=r_n+s\)</span>，代入递推关系得到：<span class="math inline">\(r_n+s =
3(r_{n-1}+s)-4n= (3r-4)n+(-3r+3s)\)</span> 得到：<span
class="math inline">\(r=3r-4, s=-3r+3s\)</span> 因此，<span
class="math inline">\(r=2\)</span> 和$ s=3$, 从而 <span
class="math inline">\(h_n=2n+3\)</span> 是递推关系的一个特解。</p></li>
<li><p>代入。从而问题的解为：<span class="math inline">\(h_n=
-3^n+2n+3\)</span></p></li>
</ul></li>
<li><p><strong>尝试特解的一些方法：</strong></p>
<ul>
<li><ol type="1">
<li>如果 <span class="math inline">\(b_n\)</span> 是 <span
class="math inline">\(n\)</span> 的 <span
class="math inline">\(k\)</span> 次多项式，那么尝试 <span
class="math inline">\(h_n\)</span> 也是 <span
class="math inline">\(n\)</span> 的 <span
class="math inline">\(k\)</span> 次多项式</li>
</ol>
<ul>
<li>① 若 <span class="math inline">\(b_n =d\)</span> (常数)，尝试 <span
class="math inline">\(h_n =r\)</span> (常数);</li>
<li>② 若 <span class="math inline">\(b_n =d_n+c\)</span> (<span
class="math inline">\(d, c\)</span> 是常数)，尝试 <span
class="math inline">\(h_n = r_n+s\)</span> (<span
class="math inline">\(r,s\)</span> 是常数);</li>
<li>③ 若 <span class="math inline">\(b_n = a_n^2+dn+c\)</span> (<span
class="math inline">\(a,d,c\)</span> 是常数)，尝试 <span
class="math inline">\(h_n = r_n^2+s_n+t\)</span> (<span
class="math inline">\(r,s,t\)</span> 是常数);</li>
</ul></li>
<li><ol start="2" type="1">
<li>若 <span class="math inline">\(b_n =d^n\)</span> (<span
class="math inline">\(d\)</span> 是常数)是指数形式， 尝试 <span
class="math inline">\(h_n = pd^n\)</span> (<span
class="math inline">\(p\)</span> 是常数)也是指数形式。</li>
</ol>
<ul>
<li>如果失败了可以尝试 <span class="math inline">\(h_n =
pnd^n\)</span></li>
</ul></li>
</ul></li>
</ul>
<h4 id="一个几何例子">7.6 一个几何例子</h4>
<ul>
<li><strong>定理7.6.1（凸多边形三角形剖分方法计数）：</strong>设 <span
class="math inline">\(h_n\)</span>
表示用下面方法把凸多边形区域分成三角形区域的方法数： 在有 <span
class="math inline">\(n+1\)</span>
条边的凸多边形区域内通过插入不相交的对角线，而把它分成三角形区域。 定义
<span class="math inline">\(h_1 =1\)</span>。则 <span
class="math inline">\(h_n\)</span> 满足如下递推关系: <span
class="math display">\[
\begin{align}
h_n &amp;= h_1 h_{n-1} + h_2 h_{n-2} + \dots + h_{n-1} h_1    \\
&amp;= \sum_{k=1}^{n-1} h_k h_{n-k} \ (n \geq 2)
\end{align}
\]</span> 该递推关系解为： <span class="math display">\[
h_n = \dfrac{1}{n}
\left( \begin{matrix} 2n-2 \\ n-1 \end{matrix} \right),(n=1,2,3,\dots)
\]</span> 前几项：<span class="math inline">\(h_1 = 1, h_2 = 1, h_3 = 2,
h_4 = 5\)</span></li>
</ul>
<h3 id="第8章-特殊计数序列"><strong>第8章 特殊计数序列</strong></h3>
<h4 id="catalan-数">8.1 <span class="math inline">\(Catalan\)</span>
数</h4>
<ul>
<li><p>（接上文）<strong><span class="math inline">\(Catalan\)</span>
数列：</strong> <span class="math inline">\(Catalan\)</span> 数列是序列
<span class="math inline">\(C_0, C_1,…, C_n,…,\)</span> 其中 <span
class="math display">\[
C_n = \dfrac{1}{n+1}
\left( \begin{matrix} 2n \\ n \end{matrix} \right),(n=0,1,2,\dots)
\]</span> 是第 <span class="math inline">\(n\)</span> 个 <span
class="math inline">\(Catalan\)</span> 数。</p>
<blockquote>
<p>记法：重要的组合部分是 <span class="math inline">\(n\)</span>
相关，外面的分子不太重要</p>
</blockquote>
<p>前几项：<span class="math inline">\(C_1 = 1, C_2 = 2, C_3 = 5, C_4 =
14\)</span></p>
<blockquote>
<p>千万注意是第 <span class="math inline">\(n\)</span> 个还是第 <span
class="math inline">\(n+1\)</span> 个</p>
<p>且 <span class="math inline">\(C_{n-1}\)</span> 对应凸 <span
class="math inline">\(n+1\)</span> 多边形，相差 <span
class="math inline">\(2\)</span></p>
</blockquote></li>
<li><p>例（括号化问题）：矩阵连乘 <span class="math inline">\(P=
A_1×A_2×…×A_n\)</span>，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？</p>
<ul>
<li>分别计算两个部分，然后对两个部分分别括号化</li>
<li><span class="math inline">\(h_n = h_1h_{n-1} + h_2h_{n-2} +
h_3h_{n-3} + \dots + h_{n-1}h_1\)</span></li>
<li><span class="math inline">\(h_n=C_{n-1}\)</span></li>
</ul></li>
<li><p>例（出栈次序问题）：一个栈(无穷大)的进栈序列为 <span
class="math inline">\(1, 2, 3, …, n\)</span>，有多少个不同的出栈序列?
（后进先出）</p>
<ul>
<li><p>记出栈序列数目为 <span
class="math inline">\(h_n\)</span></p></li>
<li><p>假设一个出栈序列的最后一个出栈元素为 <span
class="math inline">\(k (1≤k ≤n)\)</span>，则有</p>
<p>（1）元素 <span class="math inline">\(1, 2, …, k-1\)</span>
的进栈与出栈在 <span class="math inline">\(k\)</span>
入栈前全部完成;</p>
<p>（2）元素 <span class="math inline">\(k+1,…, n\)</span>
的进栈与出栈在 <span class="math inline">\(k\)</span> 入栈后直至 <span
class="math inline">\(k\)</span> 出栈前全部完成。</p>
<p>因此，由乘法原理，最后一个出栈元素为 <span
class="math inline">\(k\)</span> 的出栈序列的个数为 <span
class="math inline">\(h_{k-1} h_{n-k}\)</span></p></li>
<li><p>由递推关系知 <span
class="math inline">\(h_n=C_n\)</span></p></li>
</ul></li>
<li><p>例（二叉树数目）：<span class="math inline">\(n\)</span>
个节点构成的二叉树的情况有 <span class="math inline">\(h_n =
C_n\)</span> 种</p></li>
<li><p><strong>定理8.1.1：</strong>考虑由 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(+1\)</span> 和 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(-1\)</span> 构成的 <span
class="math inline">\(2n\)</span> 项序列 <span
class="math inline">\(a_1,a_2,\dots,a_{2n}\)</span>，
其部分和满足：<span class="math inline">\(a_1 + a_2 + \dots + a_k \geq 0
\ (k=1,2,…,2n)\)</span> 的序列的个数等于第 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(Catalan\)</span> 数 <span class="math display">\[
C_n = \dfrac{1}{n+1}
\left( \begin{matrix} 2n \\ n \end{matrix} \right) (n \geq 0)
\]</span></p>
<ul>
<li><p>例（找零）：有 <span class="math inline">\(2n\)</span>
个人排成一对进电影院，门票 <span class="math inline">\(50\)</span>
元，<span class="math inline">\(2n\)</span> 个人中的 <span
class="math inline">\(n\)</span> 个人有 <span
class="math inline">\(50\)</span> 元纸币，<span
class="math inline">\(n\)</span> 个人有 <span
class="math inline">\(100\)</span> 元纸币。
电影院设置售票点，假设未备有零钱，有多少种排队方法使得只要有 <span
class="math inline">\(100\)</span> 元的人买票，售票处就有 <span
class="math inline">\(50\)</span> 元的纸币找零？</p>
<p>（1）情况 <span class="math inline">\(1\)</span>：若把 <span
class="math inline">\(2n\)</span> 个人看成不可区分的，将 <span
class="math inline">\(50\)</span> 元用 <span
class="math inline">\(+1\)</span> 表示，<span
class="math inline">\(100\)</span> 元用 <span
class="math inline">\(-1\)</span> 表示。答案 <span
class="math inline">\(C_n\)</span></p>
<p>（2）情况 <span class="math inline">\(2\)</span>：若把 <span
class="math inline">\(2n\)</span> 个人看成可区分的。则需要考虑 <span
class="math inline">\(n\)</span> 个有 <span
class="math inline">\(50\)</span> 元纸币的人的排列，以及 <span
class="math inline">\(n\)</span> 个有 <span
class="math inline">\(100\)</span> 元纸币的人的排列。 因此排队方法数为：
<span class="math display">\[
(n!\ n!)\dfrac{1}{n+1} \
\left( \begin{matrix} 2n \\ n \end{matrix} \right) (n \geq 0)
\]</span></p></li>
<li><p>例：一位大城市的律师在她住所以北 <span
class="math inline">\(n\)</span> 个街区和以东 <span
class="math inline">\(n\)</span> 个街区处工作。每天她走 <span
class="math inline">\(2n\)</span>
个街区上班。如果她不穿越从家到办公室的对角线，有多少可能的道路？</p>
<p>用 <span class="math inline">\(+1\)</span> 表示向东，<span
class="math inline">\(-1\)</span> 表示向北。则每条路径对应一个 <span
class="math inline">\(+1, -1\)</span> 的序列 <span
class="math inline">\(a_1,a_2,\dots,a_{2n}\)</span></p></li>
</ul></li>
<li><p><strong><span class="math inline">\(Catalan\)</span>
序列递推关系和初始条件为：</strong> <span class="math display">\[
C_n = \dfrac{4n-2}{n+1} C_{n-1} (n \geq 1) ,C_0 = 1
\]</span></p></li>
</ul>
<h4 id="差分序列和-stirling-数">8.2 差分序列和 <span
class="math inline">\(Stirling\)</span> 数</h4>
<ul>
<li><p><strong>差分序列：</strong>设 <span class="math inline">\(h_0,
h_1, h_2, …, h_n, …\)</span> 是一个序列。定义新序列: $h_0, h_1, h_2, ,
h_n, $称为 <span class="math inline">\(h_0, h_1, h_2, …, h_n, …\)</span>
的（一阶）差分序列，其中 <span class="math inline">\(\Delta h_n =
h_{n+1} - h_n (n \geq 0)\)</span>，是序列的相邻项的差。</p></li>
<li><p><strong>定理8.2.2：</strong>差分表的第 <span
class="math inline">\(0\)</span> 条对角线等于 <span
class="math inline">\(c_0, c_1, c_2, …, c_p, 0, 0, 0, …\)</span>， 其中
<span class="math inline">\(c_p≠ 0\)</span> 的序列的通项满足： <span
class="math display">\[
h_n =
c_0 \left( \begin{matrix} n \\ 0 \end{matrix} \right) +
c_1 \left( \begin{matrix} n \\ 1 \end{matrix} \right) +
c_2 \left( \begin{matrix} n \\ 2 \end{matrix} \right) + \dots +
c_p \left( \begin{matrix} n \\ p \end{matrix} \right)
\]</span> 的关于 <span class="math inline">\(n\)</span> 的 <span
class="math inline">\(p\)</span> 次多项式。</p></li>
<li><p><strong>定理 8.2.3：</strong>假设序列 <span
class="math inline">\(h_0, h_1, h_2, …, h_n, …\)</span> 的差分表的第
<span class="math inline">\(0\)</span> 条对角线等于 <span
class="math inline">\(c_0, c_1, …, c_p, 0, 0,…\)</span> 那么 <span
class="math display">\[
\sum_{k=0}^n h_k =
c_0 \left( \begin{matrix} n+1 \\ 1 \end{matrix} \right) +
c_1 \left( \begin{matrix} n+1 \\ 2 \end{matrix} \right) +
c_2 \left( \begin{matrix} n+1 \\ 3 \end{matrix} \right) + \dots +
c_p \left( \begin{matrix} n+1 \\ p+1 \end{matrix} \right)
\]</span></p>
<p>其中差分表中第 <span class="math inline">\(0\)</span> 条对角线上的第
<span class="math inline">\(k\)</span> 个元素，记为 <span
class="math inline">\(c(p, k)\)</span>。</p></li>
<li><p><strong>第二类 <span class="math inline">\(Stirling\)</span>
数：</strong> <span class="math display">\[
h_n = n^p = \sum_{k=0}^n \dfrac{c(p,k)}{k!} [n]_k = \sum_{k=0}^n S(p,k)
[n]_k
\]</span> <span class="math inline">\([n]_k\)</span> = <span
class="math inline">\(n\)</span> 个不同元素中取 <span
class="math inline">\(k\)</span> 个元素的排列数 <span
class="math inline">\(P(n, k)\)</span></p></li>
<li><p><strong>定理8.2.4（第二类 <span
class="math inline">\(Stirling\)</span> 数的递推公式）：</strong>如果
<span class="math inline">\(1 ≤ k ≤ p-1\)</span> 则 <span
class="math inline">\(S(p, k) = kS(p-1,k) + S(p-1,
k-1)\)</span></p></li>
<li><p><strong>定理8.2.5（第二类 <span
class="math inline">\(Stirling\)</span> 数的组合解释）：</strong> 第二类
<span class="math inline">\(Stirling\)</span> 数 <span
class="math inline">\(S(p, k)\)</span> 计数的是把 <span
class="math inline">\(p\)</span> 个物品的集合划分到 <span
class="math inline">\(k\)</span>
个不可区分的盒子且没有空盒子的划分的个数。</p>
<ul>
<li><ol type="1">
<li>当 <span class="math inline">\(p\)</span> 独占一个盒子时， 当把
<span class="math inline">\(p\)</span> 从盒子中拿走时，得到剩下的 <span
class="math inline">\(\{1,2,…, p-1\}\)</span> 划分到 <span
class="math inline">\(k-1\)</span> 个非空且不可区分的盒子的划分。
因此，存在 <span class="math inline">\(S(p-1, k-1)\)</span> 种对 <span
class="math inline">\(\{1, 2, …, p\}\)</span> 的满足条件的划分。</li>
</ol></li>
<li><ol start="2" type="1">
<li>当 <span class="math inline">\(p\)</span> 不独占一个盒子时，
相当于先将 <span class="math inline">\(\{1, 2,…, p-1\}\)</span> 放到
<span class="math inline">\(k\)</span> 个盒子，不允许空盒， 共有 <span
class="math inline">\(S(p-1, k)\)</span> 种方案，然后将 <span
class="math inline">\(p\)</span> 放进其中一盒，由乘法原理得方案数为 $
kS(p-1, k)$ 。</li>
</ol></li>
</ul></li>
<li><p>常见的几个关系：</p>
<ul>
<li><span class="math inline">\(S(p,1) = 1\)</span></li>
<li><span class="math inline">\(S(p,2) = 2^{p-1} -1\)</span></li>
<li><span class="math inline">\(S(p,p-1) = \left( \begin{matrix} p \\ 2
\end{matrix} \right)\)</span></li>
<li><span class="math inline">\(S(p, p-2) = \left( \begin{matrix} p \\ 3
\end{matrix} \right) + 3 \left( \begin{matrix} p \\ 4 \end{matrix}
\right) (p \geq 2)\)</span></li>
</ul></li>
<li><p><strong><span class="math inline">\(Bell\)</span>
数：</strong><span class="math inline">\(Bell\)</span> 数是将 <span
class="math inline">\(p\)</span>
个元素的集合分成非空、不可区分的盒子的划分数，记为 <span
class="math inline">\(B_p\)</span>，则：（至少一个盒子， 最多 <span
class="math inline">\(p\)</span> 个盒子） <span class="math display">\[
B_p = S(p,0)+S(p,1)+\dots+S(p,p)
\]</span></p></li>
<li><p><strong>定理8.2.8（第一类 <span
class="math inline">\(Stirling\)</span> 数的递推公式）：</strong>如果
<span class="math inline">\(1≤ k ≤ p-1\)</span> 则： <span
class="math display">\[
s(p, k) = (p-1)s(p-1, k) + s(p-1, k-1)
\]</span></p></li>
<li><p><strong>定理8.2.9（第一类 <span
class="math inline">\(Stirling\)</span> 数的组合解释）：</strong>第一类
<span class="math inline">\(Stirling\)</span> 数 <span
class="math inline">\(s(p, k)\)</span> 是将 <span
class="math inline">\(p\)</span> 个物品排成 <span
class="math inline">\(k\)</span> 个非空的循环排列的方法数。</p>
<ul>
<li><p>设 <span class="math inline">\(p\)</span> 个物品记为 <span
class="math inline">\(1, 2, 3, …, p\)</span>。 将 <span
class="math inline">\(1, 2, 3, …, p\)</span> 排成 <span
class="math inline">\(k\)</span> 个圆圈有两种类型：</p>
<ol type="1">
<li><p>有一个循环排列中只有 <span class="math inline">\(p\)</span>
自己，则共有 <span class="math inline">\(s(p-1,
k-1)\)</span>种;</p></li>
<li><p><span class="math inline">\(p\)</span>
至少和另一个物品在一个循环排列中，则可以通过把 <span
class="math inline">\(1, 2, …, p-1\)</span> 排成 <span
class="math inline">\(k\)</span> 个循环排列，并把 <span
class="math inline">\(p\)</span> 放在 <span class="math inline">\(1, 2,
…, p-1\)</span> 任何 一个物品的左边得到，因此共有 <span
class="math inline">\((p-1) s(p-1, k)\)</span> 种。</p></li>
</ol></li>
</ul></li>
</ul>
<h4 id="分拆数">8.3 分拆数</h4>
<ul>
<li><p>设一个正整数 <span
class="math inline">\(n\)</span>，若存在正整数集 <span
class="math inline">\(\{n_1, n_2,…, n_k\} ( 1≤ k ≤ n，n_i ≤
n)\)</span>，使得 <span class="math inline">\(n_1+n_2+…+n_k=n\)</span>
，则称 <span class="math inline">\(\{n_1, n_2,…, n_k\}\)</span> 是 <span
class="math inline">\(n\)</span> 的一个分拆(或拆分)。 称每个 <span
class="math inline">\(n_i\)</span> 为 <span
class="math inline">\(n\)</span> 的一个部分（或类）。 记 <span
class="math inline">\(n\)</span> 的所有包含 <span
class="math inline">\(k\)</span> 个部分的不同分拆的个数为 <span
class="math inline">\(p_n^k\)</span>，<span
class="math inline">\(n\)</span> 的所有不同分拆的个数记为 <span
class="math inline">\(p_n\)</span>，称为 <span
class="math inline">\(n\)</span> 的分拆数。</p>
<ul>
<li><p>二者的关系为：<span class="math inline">\(p_n^1 + p_n^2 + \dots +
p_n^n = p_n\)</span></p></li>
<li><p>拆分中部分的顺序并不重要</p></li>
</ul></li>
<li><p><span class="math inline">\(n = na_n + (n-1)a_{n-1} + \dots +
2a_2 + a_1 = n\)</span> 对应 <span class="math inline">\(n\)</span>
的一个分拆记作：<span class="math inline">\(\lambda = n^{a_n} \dots
2^{a_2}1^{a_1}\)</span></p></li>
<li><p><strong>分拆数的递推关系：</strong><span
class="math inline">\(\sum_{j=1}^{k}p_n^j = p_{n+k}^k, p_n^1 = p_n^n =
1\)</span></p></li>
<li><p><strong>求 <span
class="math inline">\(p_n^k\)</span>：</strong><span
class="math inline">\(p_n^k = p_{n-k+k}^k =
\sum_{j=1}^kp_{n-k}^j\)</span></p></li>
<li><p><strong>定理8.3.1（转换关系）：</strong>设 <span
class="math inline">\(p_n(r)\)</span> 是最大部分为 <span
class="math inline">\(r\)</span> 的 <span
class="math inline">\(n\)</span> 的分拆的个数，<span
class="math inline">\(q_n(r)\)</span> 是满足分拆各部分不大于 <span
class="math inline">\(r\)</span> 的 <span
class="math inline">\(n-r\)</span> 的分拆数量，<span
class="math inline">\(p_n(r) = q_n(r)\)</span></p></li>
<li><p><strong><span class="math inline">\(Ferrers\)</span>
图：</strong><span class="math inline">\(k\)</span> 行，第 <span
class="math inline">\(i\)</span> 行有 <span
class="math inline">\(n_i\)</span> 点的左对齐点组</p></li>
<li><p><strong>共轭分拆：</strong>将分拆 <span
class="math inline">\(\lambda\)</span> 的 <span
class="math inline">\(Fereers\)</span> 图转置，记为 <span
class="math inline">\(\lambda^*\)</span></p>
<ul>
<li>原分拆的行数对应共轭分拆的最大部分</li>
</ul></li>
<li><p><strong>拆分数定理：</strong>正整数 <span
class="math inline">\(n\)</span> 分成 <span
class="math inline">\(k\)</span> 个部分的拆分个数，等于 <span
class="math inline">\(n\)</span> 分成以 <span
class="math inline">\(k\)</span> 为最大部分的拆分个数</p></li>
<li><p><strong>自共轭分拆：</strong><span class="math inline">\(\lambda
= \lambda*\)</span></p></li>
<li><p><strong>定理8.3.2</strong> 设 <span
class="math inline">\(n\)</span> 是正整数，设 <span
class="math inline">\(p_n^s\)</span> 等于 <span
class="math inline">\(n\)</span> 的自共轭分拆数， 而 <span
class="math inline">\(p_n^t\)</span>
等于分拆成互不相同的若干奇数和的分拆数，则有 <span
class="math display">\[
p_n^s = p_n^t
\]</span></p>
<ul>
<li>利用 <span class="math inline">\(Ferrers\)</span>
图建立两种分拆的一一对应</li>
</ul></li>
<li><p><strong>定理8.3.3（欧拉恒等式）：</strong>设 <span
class="math inline">\(n\)</span> 是正整数，设 <span
class="math inline">\(p_n^o\)</span> 是把 <span
class="math inline">\(n\)</span> 分成奇数和的分拆数， <span
class="math inline">\(p_n^d\)</span> 是把 <span
class="math inline">\(n\)</span> 分成不同部分的分拆个数。则 <span
class="math display">\[
p_n^o = p_n^d
\]</span></p>
<ul>
<li>利用 <span class="math inline">\(Ferrers\)</span>
图建立两种分拆的一一对应</li>
</ul></li>
<li><p>计算分拆数的方法：</p>
<ul>
<li><p>方法一：定理：<span class="math inline">\(n\)</span> 分拆数 <span
class="math inline">\(p_n^k\)</span> 满足下列递推关系： <span
class="math display">\[
\sum_{j=1}^k p_n^i = p_{n+k}^k, p_n^1 = p_n^n = 1
\]</span></p></li>
<li><p>方法二：生成函数（见下）</p></li>
</ul></li>
<li><p><strong>定理8.3.4</strong> 数列 <span class="math inline">\(p_0,
p_1, …, p_n, …\)</span> 的生成函数是 <span class="math display">\[
g(x) = \sum_{n=0}^\infty p_n x^n =
\prod_{k=1}^\infty (1-x^k)^{-1}
\]</span></p>
<ul>
<li><p>证明：由<span class="math inline">\((1-x^k)^{-1} =
1+x^k+x^{2k}+x^{3k}+\dots+x^{a_k k}+\dots\)</span>得 <span
class="math display">\[
\begin{align}
\prod_{k=1}^\infty (1-x^k)^{-1} =
&amp;(1+x+x^2+\dots+x^{1a_1}+\dots) \times  \\
&amp;(1+x^2+x^4+\dots+x^{2a_2}+\dots) \times    \\
&amp;(1+x^k+x^{2k}+\dots+x^{ka_k}+\dots) \times \dots \\
\end{align}
\]</span> 每一个项 <span class="math inline">\(x_n\)</span>
由通过从第一个因子选择 <span
class="math inline">\(x^{1a_1}\)</span>，从第二个因子选择项 <span
class="math inline">\(x^{2a_2}\)</span>，从第三个因子选择项 <span
class="math inline">\(x^{3a_3}\)</span> , <span
class="math inline">\(…\)</span> 得到，其中，<span
class="math inline">\(1a_1+2a_2+3a_3+… ka_k+… = n (0≤a_i
≤n)\)</span></p>
<p>显然，方程 <span class="math inline">\((1)\)</span>
的每个正整数解均对应 <span class="math inline">\(n\)</span>
的一个拆分，因此，<span class="math inline">\(x_n\)</span>
的系数，即方程 <span class="math inline">\((1)\)</span>
的非负整数解的个数，就是 <span class="math inline">\(n\)</span>
的分拆数。</p></li>
</ul></li>
<li><p>几个特殊的生成函数</p>
<ul>
<li><p><span class="math inline">\(n\)</span> 分成 <span
class="math inline">\(k\)</span> 个部分的分拆数 <span
class="math inline">\(p_n^k\)</span> 的生成函数——转化为以 <span
class="math inline">\(k\)</span> 为最大部分的拆分个数 <span
class="math display">\[
g(x)=x^k(1-x)^{-1}(1-x^2)^{-1}...(1-x^k)^{-1}
\]</span></p></li>
<li><p><span class="math inline">\(n\)</span> 分成奇数和的分拆数 <span
class="math inline">\(p_n\)</span> 的生成函数 <span
class="math display">\[
\begin{aligned}
g(x)&amp; =(1-x)^{-1}(1-x^3)^{-1}(1-x^5)^{-1}(1-x^7)^{-1}...  \\
&amp;=(1+x+x^2+...+x^{1a_1}+....)\times
(1+x^3+x^6+...+x^{3a_2}+....)\times (1+x^5+x^{10}+...+x^{5a_k}+....)
\end{aligned}
\]</span></p></li>
<li><p><span class="math inline">\(n\)</span> 分成互不相等的部分的分拆数
<span class="math inline">\(p_n\)</span> 的生成函数 <span
class="math display">\[
g(x)=(1+x)(1+x^2)(1+x^3)...(1+x^n)...
\]</span></p></li>
<li><p><span class="math inline">\(n\)</span>
分成互不相等的奇数部分的分拆数 <span class="math inline">\(p_n\)</span>
的生成函数 <span class="math display">\[
g(x)=(1+x)(1+x^3)(1+x^5)...(1+x^{2k-1})...
\]</span></p></li>
</ul></li>
</ul>
<h3 id="第14章-pólya-计数"><strong>第14章 <span
class="math inline">\(Pólya\)</span> 计数</strong></h3>
<blockquote>
<p>明确给出两种着色方案异同的数学定义</p>
<p>在规定每种颜色出现次数的情况下对着色方案数给出统一的表达式</p>
</blockquote>
<h4 id="置换群与对称群">14.1 置换群与对称群</h4>
<ul>
<li><p>群的定义：给定集合 <span class="math inline">\(G\)</span> 和
<span class="math inline">\(G\)</span> 上的二元运算 “<span
class="math inline">\(•\)</span>”，如果以下四个条件满足，则称代数结构
<span class="math inline">\((G, •)\)</span> 为群:</p>
<p>封闭性、结合律、单位元、逆元</p>
<ul>
<li>群的阶：有限群 <span class="math inline">\(G\)</span>
的元素个数，记为 <span class="math inline">\(|G|\)</span></li>
<li>循环群的生成元：<span class="math inline">\(\exists a \in
G\)</span>，<span class="math inline">\(G\)</span> 中任意元素 <span
class="math inline">\(b\)</span> 均可以表示成 <span
class="math inline">\(a\)</span> 的方幂，则称 <span
class="math inline">\(G\)</span> 为循环群，<span
class="math inline">\(a\)</span> 为该群生成元</li>
</ul></li>
<li><p>置换</p>
<ul>
<li>双射</li>
<li><span class="math inline">\(S_n\)</span> 为 <span
class="math inline">\(X = \{1,2, \dots, n\}\)</span> 的所有 <span
class="math inline">\(n!\)</span> 个置换构成的集合</li>
<li>是函数，可以合成
<ul>
<li>先 <span class="math inline">\(f\)</span> 后 <span
class="math inline">\(g\)</span> 记作 <span class="math inline">\(g
\circ f\)</span>，<span class="math inline">\(f\)</span> 的内容是 <span
class="math inline">\(i_k\)</span>，则 <span class="math inline">\(g
\circ f\)</span> 记作 <span class="math inline">\(j_{i_k}\)</span></li>
<li>满足分配律，通常不满足交换律</li>
</ul></li>
<li>特殊置换
<ul>
<li>自身合成置换</li>
<li>恒等置换</li>
<li>逆置换
<ul>
<li>求法：交换上下两行，然后按自然顺序重新排列第一行的整数</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>置换群：<span class="math inline">\(S_n\)</span> 的非空子集 <span
class="math inline">\(G\)</span>
满足如下四个性质，则称为置换的群，简称置换群</p>
<ul>
<li>封闭性、结合律、单位元、逆元</li>
<li><span class="math inline">\(S_n\)</span> 称为 <span
class="math inline">\(n\)</span> 阶对称群</li>
<li>仅含恒等置换的集合 <span class="math inline">\(G = \{ \iota
\}\)</span> 是一个置换群</li>
<li>置换群满足左消去：<span class="math inline">\(f \circ g = f \circ
h\)</span>，则 <span class="math inline">\(g = h\)</span></li>
</ul></li>
<li><p>几何图形 <span class="math inline">\(\Omega\)</span> 的对称</p>
<ul>
<li>看作顶点、边以及三维情形下的面上的一个置换</li>
<li>对称构成置换群，称为 <span class="math inline">\(\Omega\)</span>
的对称群
<ul>
<li>顶点对称群 <span class="math inline">\(G_c\)</span>
<ul>
<li><span class="math inline">\(n\)</span> 个旋转</li>
<li><span class="math inline">\(n\)</span> 个反射
<ul>
<li><span class="math inline">\(n\)</span> 为偶数：<span
class="math inline">\(\dfrac{n}{2}\)</span> 个关于对角点的反射，<span
class="math inline">\(\dfrac{n}{2}\)</span>
个关于对边中点连线的反射</li>
<li><span class="math inline">\(n\)</span> 为奇数：<span
class="math inline">\(n\)</span> 个关于角点与其对边中点的连线的反射</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>置换群与着色</p>
<ul>
<li><p>一个着色可由一个对称（置换）得到与其等价的另一个着色</p></li>
<li><p>定义 <span class="math inline">\(f * c\)</span> 是使 <span
class="math inline">\(i_k\)</span> 具有颜色 <span
class="math inline">\(c(k)\)</span> 的着色，即 <span
class="math inline">\((f*c)(i_k) = c(k)\)</span></p>
<p><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611210113545.png" alt="image-20230611210113545" style="zoom: 33%;" /></p></li>
<li><p><span class="math inline">\((g \circ f)*c =
g*(f*c)\)</span></p></li>
</ul></li>
<li><p>着色等价关系</p>
<ul>
<li><span class="math inline">\(C\)</span> 是 <span
class="math inline">\(X\)</span> 的一个着色集合，对于 <span
class="math inline">\(G\)</span> 中的任意置换 <span
class="math inline">\(f\)</span> 和 <span
class="math inline">\(C\)</span> 中任意着色 <span
class="math inline">\(c\)</span>，<span class="math inline">\(X\)</span>
的着色 <span class="math inline">\(f*c\)</span> 仍属于 <span
class="math inline">\(C\)</span></li>
<li>定义 <span class="math inline">\(C\)</span> 中关系 <span
class="math inline">\(\sim\)</span>：设 <span class="math inline">\(c_1,
c_2\)</span> 是 <span class="math inline">\(C\)</span>
中的任意两种着色，如果存在 <span class="math inline">\(G\)</span>
中的一个置换 <span class="math inline">\(f\)</span>，使得 <span
class="math inline">\(f*c_1 = c_2\)</span>，则称 <span
class="math inline">\(c_1\)</span> 等价于 <span
class="math inline">\(c_2\)</span>，记为 <span class="math inline">\(c_1
\sim c_2\)</span>
<ul>
<li>满足等价关系的自反性、对称性、传递性</li>
</ul></li>
</ul></li>
<li><p>计算非等价的着色数方法：</p>
<ul>
<li><span class="math inline">\(Burnside\)</span> 定理、<span
class="math inline">\(Pólya\)</span> 计算公式</li>
</ul></li>
</ul>
<h4 id="burnside-定理">14.2 <span
class="math inline">\(Burnside\)</span> 定理</h4>
<ul>
<li><p>稳定核与不变着色集</p>
<ul>
<li>使着色 <span class="math inline">\(c\)</span> 的 <span
class="math inline">\(G\)</span> 中所有置换的集合 <span
class="math inline">\(G(c) = \{f | f \in G, f*c = c\}, c\in
C\)</span>，称为 <span class="math inline">\(c\)</span> 的稳定核
<ul>
<li>任何着色 <span class="math inline">\(c\)</span>
的稳定核也形成一个置换群</li>
</ul></li>
<li>在置换 <span class="math inline">\(f\)</span> 作用下保持不变的 <span
class="math inline">\(C\)</span> 中所有着色的集合 <span
class="math inline">\(C(f) = \{c | c \in C, f*c = c\}, f \in G\)</span>
称为 <span class="math inline">\(f\)</span> 的不变着色集</li>
</ul></li>
<li><p><strong>定理14.2.3 (<span class="math inline">\(Burnside\)</span>
定理)：</strong>设 <span class="math inline">\(G\)</span> 是 <span
class="math inline">\(X\)</span> 的置换群，<span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(X\)</span> 中一个满足下面条件的着色集合：对于
<span class="math inline">\(G\)</span> 中所有 <span
class="math inline">\(f\)</span> 与 <span
class="math inline">\(C\)</span> 中所有 <span
class="math inline">\(c\)</span>，<span
class="math inline">\(f∗c\)</span> 仍在 <span
class="math inline">\(C\)</span> 中，则 <span
class="math inline">\(C\)</span> 中非等价的着色数 <span
class="math inline">\(N(G, C)\)</span> 为 ： <span
class="math display">\[
N(G,C) = \dfrac{1}{|G|} \sum_{f \in G} |C(f)| = \dfrac{1}{|G|} \sum_{c
\in C} |G(c)|
\]</span> 即，<span class="math inline">\(C\)</span>
中非等价的着色数等于在 <span class="math inline">\(G\)</span>
中的置换作用下保持不变的着色的平均数。<span class="math inline">\(C(f) =
\{c|c \in C, f * c = c\}, f \in G\)</span></p>
<p>具体地，设<span
class="math inline">\(G=\{f_1,f_2,\dots,f_n\}\)</span>，则<span
class="math inline">\(N(G,C) = \dfrac{1}{n} \sum_{i=1}^n
|C(f_i)|\)</span></p></li>
<li><p>计数非等价的着色数 <span class="math inline">\(N(G,C)\)</span>
的步骤：</p>
<ul>
<li>确定置换群 <span class="math inline">\(G\)</span>，确定着色集 <span
class="math inline">\(C\)</span></li>
<li>计数 <span class="math inline">\(G\)</span>
中每个置换的不变着色集（或每个着色的稳定核）的大小</li>
<li>套用公式</li>
</ul></li>
<li><p>例：用红、蓝两种颜色给一个正方形的 <span
class="math inline">\(4\)</span>
个顶点着色，试问存在多少种不同的着色方法数</p></li>
<li><p>例(循环排列计数) ：把 <span class="math inline">\(n\)</span>
个不同的对象放在一个圆上，有多少种放法</p></li>
</ul>
<h4 id="pólya-计数">14.3 <span class="math inline">\(Pólya\)</span>
计数</h4>
<blockquote>
<p><span class="math inline">\(Burnside\)</span>
定理计数部分比较复杂，仅考虑置换的循环结构并引入有向圈概念</p>
</blockquote>
<ul>
<li><p><strong>置换循环结构</strong>：<span
class="math inline">\(f\)</span> 是置换，<span class="math inline">\(D_f
= (X, A_f)\)</span> 是顶点集为 <span class="math inline">\(X\)</span>
且边集为 <span class="math inline">\(A_f = \{(i, f(i)) | i \in
X\}\)</span> 的有向图</p>
<ul>
<li><span class="math inline">\(D_f\)</span> 有 <span
class="math inline">\(n\)</span> 个顶点和 <span
class="math inline">\(n\)</span> 条边，且各顶点的入度和出度均为 <span
class="math inline">\(1\)</span></li>
<li>弧集 <span class="math inline">\(A_f\)</span>
可以被划分为若干个有向圈，且每个顶点恰好属于一个有向圈</li>
<li><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611213804336.png" alt="image-20230611213804336" style="zoom:33%;" /></li>
<li><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611213914755.png" alt="image-20230611213914755" style="zoom:33%;" /></li>
</ul></li>
<li><p><strong>循环因子分解</strong></p>
<ul>
<li><p>循环因子分解是唯一的，但是循环出现的次序可以任意变化</p></li>
<li><p><span class="math inline">\(1\)</span> 循环也即恒等置换</p></li>
<li><p>在 <span class="math inline">\(f\)</span> 的循环因子分解中，<span
class="math inline">\(X\)</span> 中的每个元素只出现一次</p></li>
<li><p>例：设 <span class="math inline">\(X=\{1,2,3,4,5,6,7,8\}\)</span>
的置换 <span class="math inline">\(f\)</span> 为：<span
class="math inline">\(f=\pmatrix{1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8\\
6&amp;8&amp;5&amp;4&amp;1&amp;3&amp;2&amp;7}\)</span></p>
<p><span class="math inline">\(|C(f)|=4^3=64\)</span></p></li>
</ul></li>
<li><p><strong>定理14.3.1：</strong>设 <span
class="math inline">\(f\)</span> 是集合 <span
class="math inline">\(X\)</span> 的一个置换。假如用 <span
class="math inline">\(k\)</span> 种颜色对 <span
class="math inline">\(X\)</span> 的元素进行着色。令 <span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(X\)</span> 的所有着色的集合，则 <span
class="math inline">\(f\)</span> 保持 <span
class="math inline">\(C\)</span> 中着色不变的着色数为：<span
class="math inline">\(|C(f )|=k^{\#(f)}\)</span></p>
<ul>
<li>和循环因子分解中循环个数有关，而与每个循环的阶数无关</li>
<li><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611221943614.png" alt="image-20230611221943614" style="zoom:33%;" /></li>
</ul></li>
<li><p><strong>置换的类型：</strong><span
class="math inline">\(f\)</span> 的循环因子分解中有 <span
class="math inline">\(e_1\)</span> 个 <span
class="math inline">\(1\)</span> - 循环，<span
class="math inline">\(e_2\)</span> 个 <span
class="math inline">\(2\)</span> - 循环，<span
class="math inline">\(\dots\)</span> <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(n\)</span> - 循环，满足 <span
class="math inline">\(1e_1+2e_2+...+ne_n=n\)</span>，称 <span
class="math inline">\(n\)</span> 元组 <span
class="math inline">\((e_1,e_2,...,e_n)\)</span> 是置换 <span
class="math inline">\(f\)</span> 的类型，记作 <span
class="math inline">\(type(f) = (e_1,e_2,...,e_n)\)</span></p></li>
<li><p><strong>置换的单项式：</strong>引入 <span
class="math inline">\(n\)</span> 个变量 <span
class="math inline">\(z_1,z_2,...,z_n\)</span>，<span
class="math inline">\(z_k\)</span> 对应 <span
class="math inline">\(k\)</span> 循环 <span class="math inline">\((k =
1,2, \dots, n)\)</span>，定义 <span class="math inline">\(f\)</span>
的单项式为 <span class="math inline">\(mon(f) =
z_1^{e_1}~z_2^{e_2}...z_n^{e_n}\)</span></p>
<ul>
<li>单项式的总次数 <span class="math inline">\(e_1+e_2+...+e_n =
\#(f)\)</span></li>
<li>按照类型的生成函数是 <span class="math inline">\(G\)</span>
中所有置换的单项式的和 <span class="math inline">\(\sum_{f\in
G}mon(f)=\sum_{f\in
G}{z_1}^{e_1}{z_2}^{e_2}...{z_n}^{e_n}\)</span>，系数对应类型为 <span
class="math inline">\((e_1,e_2, \dots, e_n)\)</span> 的置换的个数</li>
</ul></li>
<li><p><strong>置换的循环指数：</strong><span
class="math inline">\(P_G(z_1,z_2,...,z_n)=\dfrac{1}{|G|}\sum_{f\in
G}mon(f)=\dfrac{1}{|G|}\sum_{f\in
G}{z_1}^{e_1}{z_2}^{e_2}...{z_n}^{e_n}\)</span></p>
<ul>
<li><p>例：求二面体群 <span class="math inline">\(D_4\)</span>
的循环指数</p>
<p><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230613133725520.png" alt="image-20230613133725520" style="zoom:33%;" /></p>
<p><span
class="math inline">\(P_{D_4}(z_1,z_2,z_3,z_4)=\dfrac{1}{8}(z_1^4+2z_4+3z_2^2+2z_1^2z_2)\)</span></p></li>
<li><p>用循环指数计算非等价着色数</p>
<ul>
<li><p>用 <span class="math inline">\(z_i = k\)</span> 代入 <span
class="math inline">\(P_G\)</span> 中</p></li>
<li><p><span
class="math inline">\(P_G(z_1,z_2,...,z_n)=\dfrac{1}{|G|}\sum_{f\in
G}mon(f)=\dfrac{1}{|G|}\sum_{f\in
G}{z_1}^{e_1}{z_2}^{e_2}...{z_n}^{e_n}\)</span></p></li>
<li><p><span class="math inline">\(|C(f)| =k^{\#(f)} = k^{e_1+e_2+ \dots
+e_n} = k^{e_1}k^{e_2} \dots k^{e_n}\)</span></p></li>
<li><p><span class="math inline">\(N(G,C)=\dfrac{1}{|G|}\sum_{f\in
G}|C(f)| =\dfrac{1}{|G|}\sum_{f\in G}k^{e_1}k^{e_2}\dots k^{e_n}
=P_G(k,k,...,k)\)</span>w</p></li>
</ul></li>
</ul></li>
<li><p><strong>定理14.3.2：</strong><span
class="math inline">\(N(G,C)=P_G(k,k,...,k)\)</span></p>
<ul>
<li><p>例：求用 <span class="math inline">\(k\)</span>
种颜色对正方形的顶点进行着色的非等价着色数</p>
<ul>
<li>图略</li>
<li><span
class="math inline">\(P_{D_4}(z_1,z_2,z_3,z_4)=\dfrac{1}{8}(z_1^4+2z_4+3z_2^2+2z_1^2z_2)\)</span></li>
<li><span
class="math inline">\(N(D_4,C)=P_{D_4}(k,k,k,k)=\dfrac{1}{8}(k^4+2k+3k^2+2k^2k)=\dfrac{1}{8}(k^4+2k^3+3k^2+2k)\)</span></li>
</ul></li>
</ul></li>
<li><p><strong>二元变量生成函数：</strong>非等价着色数等于 <span
class="math inline">\(P_G(r+b, r^2+b^2, \dots, r^n+b^n)\)</span> 中
<span class="math inline">\(r^pb^q\)</span> 的系数</p>
<ul>
<li><p>例：用 <span class="math inline">\(2\)</span>
种颜色对一个正方形的顶点着色，求它们的非等价着色数的生成函数</p>
<p>​ <span
class="math inline">\(P_{D_4}(z_1,z_2,z_3,z_4)=\dfrac{1}{8}(z_1^4+2z_4+3z_2^2+2z_1^2z_2)\)</span></p>
<p>​ <span class="math inline">\(\begin{aligned}
&amp;P_{D_4}(r+b,r^2+b^2,r^3+b^3,r^4+b^4) \\
&amp;=\dfrac{1}{8}((r+b)^4+2(r^4+b^4)+3(r^2+b^2)^2+2(r+b)^2(r^2+b^2)) \\
&amp;=r^4+r^3b+2r^2b^2+r b^3+b^4. \end{aligned}\)</span></p></li>
</ul></li>
<li><p><strong><span class="math inline">\(Pólya\)</span>
定理：</strong><span
class="math inline">\(\{u_1,u_2,\ldots,u_k\}\)</span> 是 <span
class="math inline">\(k\)</span> 种颜色的一个集合，则针对各颜色数目的
<span class="math inline">\(C\)</span>
的非等价着色数的生成函数是由循环指数 <span
class="math inline">\(P_G(z_1,z_2,...,z_n)\)</span> 通过做变量代换 <span
class="math inline">\(z_j=u_1^j+u_2^j+...+u_k^j(j=1,2,...,n)\)</span>
得到的表达式 <span
class="math inline">\(P_G(u_1+u_2+\text{...}+u_k,u_1^2+u_2^2+\text{...}+u_k^2,\text{...},u_1^n+u_2^n+\text{...}+u_k^n)\)</span></p>
<ul>
<li><p><span
class="math inline">\(u_1^{p_1}u_2^{p_2}...u_k^{p_k}\)</span> 的系数等于
<span class="math inline">\(X\)</span> 中的 <span
class="math inline">\(p_1\)</span> 个元素着色成 <span
class="math inline">\(u_1\)</span>，<span
class="math inline">\(p_2\)</span> 个元素着色成 <span
class="math inline">\(u_2\)</span>，<span
class="math inline">\(\dots\)</span>，<span
class="math inline">\(p_k\)</span> 个元素着色成 <span
class="math inline">\(u_k\)</span> 的非等价的着色数</p></li>
<li><p>例：用 <span class="math inline">\(3\)</span>
种颜色对一个正方形的顶点着色，求它们的非等价着色数的生成函数</p>
<p>​ <span
class="math inline">\(P_{D_4}(z_1,z_2,z_3,z_4)=\dfrac{1}{8}(z_1^4+2z_4+3z_2^2+2z_1^2z_2)\)</span></p>
<p>​ <span class="math inline">\(\begin{aligned}
&amp;P_{D_4}(r+b+g,r^2+b^2+b^2,r^3+b^3+g^3,r^4+b^4+g^4) \\
&amp;=\dfrac{1}{8}((r+b+g)^4+2(r^4+b^4+g^4)+3(r^2+b^2+g^2)^2+2(r+b+g)^2(r^2+b^2+g^2))
\\ \end{aligned}\)</span></p></li>
</ul></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Notes/" rel="tag"># Notes</a>
              <a href="/tags/Combinatorics/" rel="tag"># Combinatorics</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/c-traps-pitfalls-notes/" rel="prev" title="《C陷阱与缺陷》读书笔记">
      <i class="fa fa-chevron-left"></i> 《C陷阱与缺陷》读书笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/vscode-configure-latex/" rel="next" title="VS Code配置LaTeX">
      VS Code配置LaTeX <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#timeline"><span class="nav-number">1.</span> <span class="nav-text">TimeLine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC1%E7%AB%A0-%E5%BC%95%E8%AE%BA"><span class="nav-number">2.</span> <span class="nav-text">第1章 引论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B1%E5%B9%BB%E6%96%B9"><span class="nav-number">2.1.</span> <span class="nav-text">例1：幻方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B236-%E5%86%9B%E5%AE%98%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.</span> <span class="nav-text">例2：\(36\)
军官问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B3%E5%AE%8C%E7%BE%8E%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.</span> <span class="nav-text">例3：完美覆盖问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%8C%96"><span class="nav-number">2.4.</span> <span class="nav-text">一般化：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E4%BC%B8%E9%97%AE%E9%A2%98%E6%96%AD%E5%B1%82%E7%BA%BF-fault-line"><span class="nav-number">2.5.</span> <span class="nav-text">延伸问题：断层线 (Fault Line)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B4%E7%9B%B8%E4%BA%92%E9%87%8D%E5%8F%A0%E7%9A%84%E5%9C%86%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F"><span class="nav-number">2.6.</span> <span class="nav-text">例4：相互重叠的圆（递推公式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B5nim-%E5%8F%96%E5%AD%90%E6%B8%B8%E6%88%8F"><span class="nav-number">2.7.</span> <span class="nav-text">例5：\(Nim\)
取子游戏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88"><span class="nav-number">3.</span> <span class="nav-text">第2章 排列与组合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%AE%A1%E6%95%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.1.</span> <span class="nav-text">2.1：4个基本的计数原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">3.2.</span> <span class="nav-text">2.2：集合的排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-number">3.3.</span> <span class="nav-text">2.3：集合的组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E9%9B%86%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">3.4.</span> <span class="nav-text">2.4：多重集的排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E9%9B%86%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-number">3.5.</span> <span class="nav-text">2.5：多重集的组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#x%E5%85%B6%E5%AE%83%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE"><span class="nav-number">3.6.</span> <span class="nav-text">2.x：其它，一些题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC3%E7%AB%A0-%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">第3章 鸽巢原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86%E7%9A%84%E7%AE%80%E5%8D%95%E5%BD%A2%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 鸽巢原理的简单形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86%E7%9A%84%E5%8A%A0%E5%BC%BA%E5%BD%A2%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 鸽巢原理的加强形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ramsey-%E5%AE%9A%E7%90%86"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 \(Ramsey\)
定理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC4%E7%AB%A0-%E7%94%9F%E6%88%90%E6%8E%92%E5%88%97%E5%92%8C%E7%BB%84%E5%90%88"><span class="nav-number">5.</span> <span class="nav-text">第4章 生成排列和组合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%8E%92%E5%88%97"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 生成排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 排序中的逆序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E7%BB%84%E5%90%88"><span class="nav-number">5.3.</span> <span class="nav-text">4.3 生成组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90-r---%E7%BB%84%E5%90%88"><span class="nav-number">5.4.</span> <span class="nav-text">4.4 生成 \(r\) -
组合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC5%E7%AB%A0-%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">第5章 二项式系数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pascal-%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 \(Pascal\)
三角形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86"><span class="nav-number">6.2.</span> <span class="nav-text">5.2 二项式定理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0%E7%9A%84%E5%8D%95%E5%B3%B0%E6%80%A7"><span class="nav-number">6.3.</span> <span class="nav-text">5.3 二项式系数的单峰性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86"><span class="nav-number">6.4.</span> <span class="nav-text">5.4 多项式定理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%9B%E9%A1%BF%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86"><span class="nav-number">6.5.</span> <span class="nav-text">5.5 牛顿二项式定理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">第6章 容斥原理及应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86"><span class="nav-number">7.1.</span> <span class="nav-text">6.1 容斥原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-number">7.2.</span> <span class="nav-text">6.2 带重复的组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97-derangement"><span class="nav-number">7.3.</span> <span class="nav-text">6.3 错位排列 Derangement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89%E7%A6%81%E6%AD%A2%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">7.4.</span> <span class="nav-text">6.4 带有禁止位置的排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%A6%81%E6%AD%A2%E4%BD%8D%E7%BD%AE%E9%97%AE%E9%A2%98"><span class="nav-number">7.5.</span> <span class="nav-text">6.5 另一个禁止位置问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0-%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB%E5%92%8C%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">第7章
递推关系和生成函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8B%A5%E5%B9%B2%E6%95%B0%E5%88%97"><span class="nav-number">8.1.</span> <span class="nav-text">7.1 若干数列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="nav-number">8.2.</span> <span class="nav-text">7.2 生成函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E6%95%B0%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.</span> <span class="nav-text">7.3 指数生成函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E9%BD%90%E6%AC%A1%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB"><span class="nav-number">8.4.</span> <span class="nav-text">7.4 求解线性齐次递推关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%BD%90%E6%AC%A1%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB"><span class="nav-number">8.5.</span> <span class="nav-text">7.5 非齐次递推关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%87%A0%E4%BD%95%E4%BE%8B%E5%AD%90"><span class="nav-number">8.6.</span> <span class="nav-text">7.6 一个几何例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC8%E7%AB%A0-%E7%89%B9%E6%AE%8A%E8%AE%A1%E6%95%B0%E5%BA%8F%E5%88%97"><span class="nav-number">9.</span> <span class="nav-text">第8章 特殊计数序列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#catalan-%E6%95%B0"><span class="nav-number">9.1.</span> <span class="nav-text">8.1 \(Catalan\)
数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97%E5%92%8C-stirling-%E6%95%B0"><span class="nav-number">9.2.</span> <span class="nav-text">8.2 差分序列和 \(Stirling\) 数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%8B%86%E6%95%B0"><span class="nav-number">9.3.</span> <span class="nav-text">8.3 分拆数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC14%E7%AB%A0-p%C3%B3lya-%E8%AE%A1%E6%95%B0"><span class="nav-number">10.</span> <span class="nav-text">第14章 \(Pólya\) 计数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%AE%E6%8D%A2%E7%BE%A4%E4%B8%8E%E5%AF%B9%E7%A7%B0%E7%BE%A4"><span class="nav-number">10.1.</span> <span class="nav-text">14.1 置换群与对称群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#burnside-%E5%AE%9A%E7%90%86"><span class="nav-number">10.2.</span> <span class="nav-text">14.2 \(Burnside\) 定理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#p%C3%B3lya-%E8%AE%A1%E6%95%B0"><span class="nav-number">10.3.</span> <span class="nav-text">14.3 \(Pólya\)
计数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="StrivingLee"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">StrivingLee</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/StrivingLee" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;StrivingLee" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:735260208@qq.com" title="E-Mail → mailto:735260208@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://augetyvolta.github.io/" title="https:&#x2F;&#x2F;augetyvolta.github.io&#x2F;" rel="noopener" target="_blank">King's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://volcaxiao.top/" title="http:&#x2F;&#x2F;volcaxiao.top&#x2F;" rel="noopener" target="_blank">Volca's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://yanna-zy.gitee.io/" title="http:&#x2F;&#x2F;yanna-zy.gitee.io&#x2F;" rel="noopener" target="_blank">Yanna's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://frankie-dejong.github.io/" title="https:&#x2F;&#x2F;frankie-dejong.github.io&#x2F;" rel="noopener" target="_blank">Scott's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://einestages.github.io/" title="https:&#x2F;&#x2F;einestages.github.io&#x2F;" rel="noopener" target="_blank">Blackening's Blog</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class=""></i>
  </span>
  <span class="author" itemprop="copyrightHolder">StrivingLee</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">244k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">10:11</span>
</div>

<!---->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>




  <script>
    (function(d, w, c) {
      w.ChatraID = '';
      var s = d.createElement('script');
      w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
      };
      s.async = true;
      s.src = 'https://call.chatra.io/chatra.js';
      if (d.head) d.head.appendChild(s);
    })(document, window, 'Chatra');
  </script>









  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>
</html>
