<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《C陷阱与缺陷》读书笔记</title>
    <url>/c-traps-pitfalls-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="总述">总述</h2>
<blockquote>
<p>C 陷阱与缺陷读书笔记，批判阅读</p>
</blockquote>
<span id="more"></span>
<h1 id="c-陷阱与缺陷">C 陷阱与缺陷</h1>
<h2 id="第1章-词法陷阱">第1章 词法陷阱</h2>
<h3 id="不同于">1.1 =不同于==</h3>
<p>不应该关闭警告选项，而应进行显式比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// improper</span></span><br><span class="line"><span class="keyword">if</span> (x = y)</span><br><span class="line">    foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// proper</span></span><br><span class="line"><span class="keyword">if</span> ((x = y) != <span class="number">0</span>)</span><br><span class="line">    foo();</span><br></pre></td></tr></table></figure>
<p>赋值误写为比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((filedsc == open(argv[i], <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    error();</span><br><span class="line"><span class="comment">// 完全没有调用error的机会</span></span><br></pre></td></tr></table></figure>
<h3 id="和不同于和">1.2 &amp;和|不同于&amp;&amp;和||</h3>
<p>见后</p>
<h3 id="词法分析中的贪心法">1.3 词法分析中的“贪心法”</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a---b;</span><br><span class="line"><span class="comment">/* is same as</span></span><br><span class="line"><span class="comment"> * a -- -b</span></span><br><span class="line"><span class="comment"> * is different from</span></span><br><span class="line"><span class="comment"> * a - --b</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">y = x<span class="comment">/*p; // is regarded as MULTI</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">y = x / *p; <span class="comment">// x point to p</span></span><br><span class="line">y = x/(*p);</span><br></pre></td></tr></table></figure>
<h3 id="整型常量">1.4 整型常量</h3>
<p>1-4.c</p>
<p>不允许出现9</p>
<h3 id="字符和字符串">1.5 字符和字符串</h3>
<p>双引号引起的字符串代表指向无名数组起始字符的指针，无名数组用引号之间的字符以及二进制为0的字符
<code>\0</code> 初始化</p>
<h3 id="练习题">练习题</h3>
<h2 id="第2章-语法陷阱">第2章 语法陷阱</h2>
<h3 id="理解函数声明">2.1 理解函数声明</h3>
<p>C
变量的声明由两部分构成：类型以及一组类似表达式的声明符(declarator)</p>
<p>声明符与表达式类似，对它求值返回一个声明中给定类型的结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> ((f));</span><br></pre></td></tr></table></figure>
<p>这个声明的含义是，当对其求值时，<code>((f))</code>
的类型为浮点类型，由此推知 <code>f</code> 的类型也是浮点类型</p>
<p>且 <code>()</code> 结合优先级高于 <code>*</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> *<span class="title function_">g</span><span class="params">()</span>, <span class="params">(*h)</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// is same as the following statement</span></span><br><span class="line"><span class="type">float</span> *(g()), (*h)();</span><br></pre></td></tr></table></figure>
<p>知道如何声明一个类型的变量后就很容易得到该类型的类型转换符了：去掉声明中的变量名和末尾分号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="type">float</span> (*)())</span><br></pre></td></tr></table></figure>
<p>调用函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*fp)();</span><br><span class="line"><span class="comment">// abbr</span></span><br><span class="line">fp();</span><br></pre></td></tr></table></figure>
<p>todo</p>
<h2 id="第3章-语义陷阱">第3章 语义陷阱</h2>
<h3 id="指针与数组">3.1 指针与数组</h3>
<p>二维数组事实上是一个指向一维数组的指针数组</p>
<p>所以取行就只需取一个下标</p>
<h3 id="非数组的指针">3.2 非数组的指针</h3>
<p><code>malloc()</code> 可能会返回 <code>NULL</code>
作为内存分配失败的标志（不过一般来说也许不用？）</p>
<h3 id="作为参数的数组声明">3.3 作为参数的数组声明</h3>
<p>用数组作为函数参数没什么意义，和传入首地址是等效的</p>
<p>他卖了个关子 todo</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *hello;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> hello[];</span><br></pre></td></tr></table></figure>
<h3 id="避免举隅法">3.4 避免“举隅法”</h3>
<p>玄之又玄，大概就是表达复制指针并不复制原始内容，即shallow
copy，当然，修改字符串常量的行为貌似是UB，与编译器实现有关</p>
<h3 id="空指针并非空字符串">3.5 空指针并非空字符串</h3>
<p>编译器保证由0转换而来的指针不等于任何有效的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br></pre></td></tr></table></figure>
<p>不能访问空指针指向的内容</p>
<h3 id="边界计算与不对称边界">3.6 边界计算与不对称边界</h3>
<p>不对称边界：左闭右开，在数学上的不对称的丑陋带来了编程时出奇的方便</p>
<p>另一种看待不对称问题的方式：把上界视作某序列中第一个被占用的元素，把下界视作序列中第一个被释放的元素</p>
<p>来看一段例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1024</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[N];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *bufptr;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bufwrite</span><span class="params">(<span class="type">char</span> *p, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bufptr == &amp;buffer[N])</span><br><span class="line">            flushbuffer();</span><br><span class="line">        -bufptr++ = *p++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ANSI C 标准中允许与“溢界”的元素地址相比较，但是对其引用是非法的</p>
<p><code>memcpy()</code>
提供了一次复制多个字符的方法，并且通常借助汇编语言的实现提高速度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bufwrite</span><span class="params">(<span class="type">char</span> *p, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> k, rem;</span><br><span class="line">        <span class="keyword">if</span> (bufptr == &amp;buffer[N])</span><br><span class="line">            flushbuffer();</span><br><span class="line">        rem = N - (bufptr - buffer);</span><br><span class="line">        k = n &gt; rem ? rem : n;</span><br><span class="line">        <span class="built_in">memcpy</span>(bufptr, p, k);</span><br><span class="line">        bufptr += k;</span><br><span class="line">        p += k;</span><br><span class="line">        n -= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在“师出有名”的情况下，我们应该有信心写对这些技巧性很强的代码</p>
<p>另一个打印给定行号or列号字符的函数</p>
<h3 id="求值顺序">3.7 求值顺序</h3>
<p>主要说了短路求值</p>
<h3 id="运算符和">3.8 运算符&amp;&amp;、||和!</h3>
<p>逻辑运算符只会返回0或1</p>
<p>&amp;和|两侧的值都会算出，而不会短路求值</p>
<h3 id="溢出">3.9 溢出</h3>
<h3 id="为函数-main-提供返回值">3.10 为函数 main 提供返回值</h3>
<p>忘记显示声明 main 返回值为 int，而又在前面定义了其他 struct</p>
<h2 id="第4章-连接">第4章 连接</h2>
<h3 id="什么是连接器">4.1 什么是连接器</h3>
<h3 id="声明与定义">4.2 声明与定义</h3>
<p>外部变量尽量不要重复定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file1.c</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.c</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>
<h3 id="命名冲突与static修饰符">4.3 命名冲突与static修饰符</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure>
<p>将 a 的作用域限制在一个源文件内</p>
<p>因此，如果若干个函数需要共享一组外部对象，可以将这些函数放到一个源文件中，把他们需要用到的对象在同一个源文件中用
static
声明，如果一个函数仅仅被同一个源文件中的其他函数调用，我们就应该声明该函数为
static</p>
<h3 id="形参实参与返回值">4.4 形参、实参与返回值</h3>
<p>如果一个函数在被定义或声明之前被调用，它的返回类型默认为 int</p>
<p>C 中形参和实参匹配的规则略为复杂，ANSI C
允许程序员在声明时指定函数的参数类型，如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">square</span><span class="params">(<span class="type">double</span>)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">square(<span class="number">2</span>); <span class="comment">// legal, is same as square((double)2)</span></span><br></pre></td></tr></table></figure>
<p>如果一个函数没有 float、short 或者 char
类型的参数，在函数声明中可以省略参数类型的说明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isvowel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isvowel</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scanf 和 printf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// expected: 0 1 2 3 4</span></span><br><span class="line"><span class="comment">// actual:   0 0 0 0 0</span></span><br></pre></td></tr></table></figure>
<p>字符 c 附近的内存因为整型所占存储空间大于字符型而被覆盖</p>
<h3 id="检查外部类型">4.5 检查外部类型</h3>
<p>保证 extern 变量与其声明一致</p>
<h3 id="头文件">4.6 头文件</h3>
<h2 id="第5章-库函数">第5章 库函数</h2>
<p><strong>尽可能</strong>使用库函数</p>
<h3 id="返回整数的getchar函数">5.1 返回整数的getchar函数</h3>
<p>不知所云，不管了</p>
<h3 id="更新顺序文件">5.2 更新顺序文件</h3>
<p>fread 操作，用到时候再细究</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (fread( (<span class="type">char</span> *)&amp;rec, <span class="keyword">sizeof</span>(rec), <span class="number">1</span>, fp) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// do something on rec</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*rec needs to be update*/</span>) &#123;</span><br><span class="line">        fseek(fp, -(<span class="type">long</span>)<span class="keyword">sizeof</span>(rec), <span class="number">1</span>);</span><br><span class="line">        fwrite( (<span class="type">char</span> *)&amp;rec, <span class="keyword">sizeof</span>(rec))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缓存输出与内存分配">5.3 缓存输出与内存分配</h3>
<p>程序输出的两种方式：</p>
<ul>
<li>即时处理（系统负担较大）</li>
<li>先暂存再大块写入</li>
</ul>
<p>因此 C
语言实现通常都允许程序员进行实际的写操作之前控制产生的输出数据量，一般通过库函数
<code>setbuf(stdout, buf)</code> 实现</p>
<p>这个语句通知输入/输出库，所有写入到 stdout 的输出都应该使用 buf
作为缓冲区，直到 buf 被填满或者程序员直接调用
fflush（对于写操作打开的文件，fflush
会直接导致输出缓冲区的内容被实际写入该文件）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> BUF[BUFSIZ];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    </span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != EOF)</span><br><span class="line">        <span class="built_in">putchar</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用errno检测错误">5.4 使用errno检测错误</h3>
<p>先检测作为错误指示的返回值，确定已经执行失败，再检查 errno
确定出错原因</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="comment">/*wrong return value*/</span>) &#123;</span><br><span class="line">    <span class="comment">// check errno</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="库函数signal">5.5 库函数signal</h3>
<p>signal 是一种捕获异步事件的方式</p>
<p>信号是真正的“异步”，可能在 C
语言执行期间的任何时刻发生，甚至可能出现在 malloc
等复杂函数的执行过程中。因此从安全角度考虑，信号处理函数不应该调用上述类型的库函数</p>
<p>唯一绝对安全可移植的操作：print 错误语句，exit 退出</p>
<h2 id="第6章-预处理器">第6章 预处理器</h2>
<blockquote>
<p>主要讲的宏的事情</p>
</blockquote>
<h3 id="不能忽视宏定义中的空格">6.1 不能忽视宏定义中的空格</h3>
<h3 id="宏并不是函数">6.2 宏并不是函数</h3>
<p>主要是括号的问题</p>
<p>但是比如下面这段就会出现重复计算的bug</p>
<p>经典的把 <code>toupper</code> 定义成宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">toupper</span>(*p++);</span><br></pre></td></tr></table></figure>
<p>嵌套宏也可能导致代码过长，比如四层嵌套的 <code>max</code> 语句</p>
<p>其实写成四行 if-else 更好</p>
<h3 id="宏并不是语句">6.3 宏并不是语句</h3>
<h3 id="宏并不是类型定义">6.4 宏并不是类型定义</h3>
<blockquote>
<p>省流：用 typedef</p>
</blockquote>
<h2 id="第7章-可移植性缺陷">第7章 可移植性缺陷</h2>
<p>就感觉...没太大必要</p>
<p>就摸了（不是）</p>
]]></content>
      <categories>
        <category>C</category>
        <category>Notes</category>
        <category>S4 Summer</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>「BUAA-CO」 Pre</title>
    <url>/co-pre/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>2023年Pre题目回忆版及我的3A答案回忆版</p>
</blockquote>
<span id="more"></span>
<p>文件在我的 GitHub</p>
<h2 id="supaltitude">1.supaltitude</h2>
<p>骑手在初始海拔为 <span class="math inline">\(0\)</span>
的原点，依次读入数组大小 <span class="math inline">\(n\)</span>
和相邻两地点的海拔差 <span
class="math inline">\(gain[n]\)</span>，输出骑手所经过的最高海拔</p>
<p>数据范围 <span class="math inline">\(1 \le n \le 64\)</span></p>
<p><span class="math inline">\(-128 \le gain[n] \le 128\)</span></p>
<p>思路：题目所求即为数组最大前缀和，维护一个变量保存当前前缀和，并维护最大值即可，没有开辟数组空间的必要</p>
<p><strong>注</strong>：保存最高海拔的前提是数组的下标连续，而不能像买卖理财产品，只在有收益的时候售出。也即如下的代码思路是错误的（虽然我相信聪明的大家都想到了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (data &gt; <span class="number">0</span>) &#123; <span class="comment">// data is the input value</span></span><br><span class="line">    sum += data;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码挖空：</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="comment"># get n</span></span><br><span class="line">    <span class="comment"># set prefix sum, maximum value and loop var</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">for_loop:</span></span><br><span class="line">    <span class="comment"># get data</span></span><br><span class="line">    <span class="keyword">add </span> $<span class="built_in">s1</span>, $<span class="built_in">s1</span>, $<span class="built_in">t1</span></span><br><span class="line"><span class="symbol">if:</span></span><br><span class="line">    <span class="comment"># no need to update, jump to &#x27;else&#x27; label </span></span><br><span class="line">    <span class="keyword">move </span>$<span class="built_in">s2</span>, $<span class="built_in">s1</span> <span class="comment">#update</span></span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line">    <span class="keyword">addi </span>$<span class="built_in">t0</span>, $<span class="built_in">t0</span>, <span class="number">1</span> <span class="comment"># DONT FORGET TO INCREMENT LOOP VAR</span></span><br><span class="line">    <span class="keyword">bne </span> $<span class="built_in">t0</span>, $<span class="built_in">s0</span>, for_loop</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">loop_end:</span></span><br><span class="line">    <span class="comment"># DONT FORGET TO PRINT</span></span><br></pre></td></tr></table></figure>
<p>此外建议大家在编写汇编代码时多用伪指令，能显著加快编程速度（毕竟这就是伪指令的使命）</p>
<p>如 <code>blt</code> 省去了 <code>slt</code> 和 <code>beq</code>
的使用，将两条指令合为一条；<code>move</code> 比 <code>add</code>
指令少一个操作数；<code>li</code> 比 <code>addi</code>
少两个操作数等等</p>
<h2 id="nodescendsequence">2.noDescendSequence</h2>
<p>识别16bit输入从高位到低位每4bit组成的4位序列是否为不下降序列</p>
<table>
<thead>
<tr class="header">
<th>信号</th>
<th>方向</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>data[15:0]</td>
<td>input</td>
<td>代表4位4bit输入</td>
</tr>
<tr class="even">
<td>result</td>
<td>out</td>
<td>输出结果：是否为不下降序列</td>
</tr>
</tbody>
</table>
<p>思路：本题<strong>不涉及时序逻辑</strong>，直接取 <code>data</code>
的对应位进行比较即可。一行代码我就不贴出来了（</p>
<h2 id="tetris">3.tetris</h2>
<p>模拟8位俄罗斯方块游戏设计 Mealy 状态机</p>
<table>
<thead>
<tr class="header">
<th>信号</th>
<th>方向</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>input[7:0]</td>
<td>I</td>
<td>八位独热码，模拟掉落一个俄罗斯方块</td>
</tr>
<tr class="even">
<td>reset</td>
<td>I</td>
<td><strong>异步复位</strong></td>
</tr>
<tr class="odd">
<td>clk</td>
<td>I</td>
<td>时钟信号</td>
</tr>
<tr class="even">
<td>output[1:0]</td>
<td>O</td>
<td>输出状态</td>
</tr>
</tbody>
</table>
<p>reset为<strong>异步复位</strong>，当reset为高电平时，状态恢复到一开始状态</p>
<p>状态：输出01表示输入位置已有方块，放置无效，保持原状态</p>
<p>输出10表示有效放置</p>
<p>输出11表示消去一行</p>
<h3 id="思路">思路</h3>
<p><strong>第一步也是最重要的一步，确定状态机类型。一时不慎，满盘皆输！！！</strong></p>
<p>方块的摆放情况数为 8 位二进制数的数量 <span
class="math inline">\(2^8\)</span>，再考虑每次独热码输入有 8
种，<strong>有效的</strong>状态转移真值表共约 <span
class="math inline">\(8 \times 2^8\)</span>
行，再考虑到无效的状态转移行，故采用真值表刻画状态转移的方式应该不是题目意图<del>（当然如果你毅力超群，我致以崇高敬意）</del>。我采取的方案是用当前的方块摆放情况表示状态，在
Mealy 状态机的输出模块再转换成 <code>output[1:0]</code></p>
<p>放置方块的行为让我联想到二进制的按位运算。判断某位是否已有方块，只需将输入和当前方块<strong>按位与</strong>，结果非
0
即为无效放置。而更新状态，只需将输入和当前方块放置状态<strong>按位或</strong>，注意<strong>特判</strong>放满后清空即可。</p>
<h3 id="tips">Tips</h3>
<p>注意到 logisim 中寄存器初值为 0，所以不用进行寄存器的初始化。</p>
<p>注意判断<strong>复位方式</strong>是同步复位还是异步复位。异步复位在
logisim 中的实现较为简单。</p>
<p>此外，注意判断<strong>时钟</strong>是输入还是自带信号。</p>
<p>还有一件事<del>（成龙历险记老爹音）</del>，题目要求的电路外观似乎不同于三输入一输出的默认外观，只需将左边三输入向下移动一格即可，外观的线不是很重要。</p>
<p>电路外观如图（已隐去部分内容）</p>
<p>最后，祝大家上机顺利，学有所获！</p>
]]></content>
      <categories>
        <category>CO</category>
        <category>S5</category>
      </categories>
      <tags>
        <tag>CO</tag>
        <tag>Replay</tag>
      </tags>
  </entry>
  <entry>
    <title>OO Pre Review</title>
    <url>/OO-Pre-Review/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="写在前面">写在前面</h2>
<blockquote>
<p>OO Pre 的学期总结，痛并快乐着</p>
</blockquote>
<span id="more"></span>
<p>[TOC]</p>
<p>也记得找jsgg debug的时候，他说：你push到仓库里，我明天帮你看看</p>
<p>可惜我当时甚至还没学会用idea进行版本管理</p>
<h2 id="pre0_task1">Pre0_task1</h2>
<blockquote>
<p>本次目标：完成git和idea的安装，学习其基本用法</p>
</blockquote>
<p>题外话，Git 这东西真的魔力很大，但是确实也有点难学</p>
<p>课程组推荐给大家的我也推荐给大家（</p>
<h3 id="git-相关">Git 相关：</h3>
<ol type="1">
<li><p><a href="https://juejin.cn/post/6844904191203213326">Git 使用心得
&amp; 常见问题整理</a></p></li>
<li><p><a
href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰老师的 Git
教程</a></p></li>
<li><p><a href="https://learngitbranching.js.org/">Git
基础可视化教程</a> 与 <a
href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1">Git
进阶可视化教程</a></p></li>
<li><p><a href="https://www.progit.cn/">Git Pro</a></p></li>
</ol>
<h3 id="java相关">Java相关：</h3>
<p><a href="https://docs.oracle.com/en/java/javase/18/docs/api/">JDK
Document</a></p>
<h3 id="commit-message">Commit message</h3>
<p>可以采用插件规范自己的 <code>commit message</code>
，摘录一些如下：（来源于<a
href="https://blog.csdn.net/m0_46636892/article/details/122093889">陈大大的期待的CSDN博客</a>）</p>
<p>Git Commit Template插件在使用时选择的git提交类型解释：</p>
<blockquote>
<p>feat
功能feature的意思，也是最常用的。当你的功能有变更的时候，都可以采用这种类型的type</p>
<p>fix 当然指的是bug修复</p>
<p>docs 更新了文档，或者更新了注释</p>
<p>style 代码格式调整，比如执行了format、更改了tab显示等</p>
<p>refactor
重构代码。指的是代码结构的调整，比如使用了一些设计模式重新组织了代码</p>
<p>perf
对项目或者模块进行了性能优化。比如一些jvm的参数改动，把stringbuffer改为stringbuilder等</p>
<p>test 这个简单，就是增加了单元测试和自动化相关的代码</p>
<p>build 影响编译的一些更改，比如更改了maven插件、增加了npm的过程等</p>
<p>ci
持续集成方面的更改。现在有些build系统喜欢把ci功能使用yml描述。如有这种更改，建议使用ci</p>
<p>chore
其他改动。比如一些注释修改或者文件清理。不影响src和test代码文件的，都可以放在这里</p>
<p>revert 回滚了一些前面的代码</p>
</blockquote>
<h2 id="pre1_task1">Pre1_task1</h2>
<blockquote>
<p>本次目标：初识Java，实现一系列基础的类，并且熟悉类、属性和方法的使用</p>
</blockquote>
<p>本次作业只需要使用Java基础语法、容器和简单的getter、setter，以及对大数类
<code>BigInteger</code> 用法有基本了解即可完成</p>
<h3 id="关于容器">关于容器：</h3>
<p>容器是好用的，容器是需要学习的</p>
<p><strong>容器是现代程序设计非常基础而重要的手段</strong></p>
<p>如果采用类似C语言结构体数组的写法，通过遍历数组查找所需要的信息，就不太符合Java的感觉，更好的做法是采用HashMap。概括起来就是下面这句话：</p>
<blockquote>
<p>不要重复造轮子！不要重复造轮子！不要重复造轮子！</p>
</blockquote>
<h3 id="关于面向对象">关于面向对象：</h3>
<blockquote>
<p>面向对象是一种主流的软件开发方法，也是一种思维方式，其核心是识别类，并在类之间建立层次式的协作关系。</p>
</blockquote>
<p>有兴趣的同学也可以看这篇读书笔记——《面向对象是如何工作的（第2版）》读书笔记</p>
<p><del>啊当然也是还在紧锣密鼓地筹备当中辣</del></p>
<h3 id="关于构造函数constructor">关于构造函数Constructor</h3>
<p>一个压行的方法是将参数传入constuctor，省去了多次调用set方法</p>
<blockquote>
<p>关于构造函数的理解：</p>
<p>构造函数的用途是在你需要创建一个对象的时候完成一些初始化工作，并给对象的所有属性赋予初始值。</p>
<p>也就是这两步：①创建这个对象 ②给这个对象部分初始化</p>
</blockquote>
<p>一个愚蠢的压行方法：不用中间变量存储读入，直接将读入传入</p>
<p>详细说明如下<del>，但是貌似不符合软工要求</del></p>
<p>有条理的写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line">    </span><br><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> in.next();</span><br><span class="line"><span class="type">String</span> <span class="variable">bottleId</span> <span class="operator">=</span> in.next();</span><br><span class="line">function(userId, bottleId);</span><br></pre></td></tr></table></figure>
<p>不太好的压行写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line">    </span><br><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">function(in.next(), in.next());</span><br></pre></td></tr></table></figure>
<h3 id="多说一嘴">多说一嘴</h3>
<p>为什么 ArrayList
可以存不同的对象呢？（这会在本单元第2、3次作业中有所体现），记住Java中一句非常重要的话：<code>Everything is reference</code>
，这会帮助你理解很多问题</p>
<p>什么、不太明白，请耐心看下去哦~</p>
<p>toString() 方法</p>
<p>操作10要求输出特定的<code>Bottle</code>类型实例的属性，建议在
<code>Bottle</code> 类中重写<code>toString</code> 方法，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bottle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The bottle&#x27;s id is &quot;</span> + id + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">        <span class="type">Bottle</span> <span class="variable">bottle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bottle</span>();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(bottle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 : The bottle&#x27;s id is 1.</span></span><br></pre></td></tr></table></figure>
<p><code>java.io.PrintStream.println(Object x)</code>函数将调用<code>String.valueOf(x)</code>以获得实例<code>x</code>的字符串描述，而<code>java.lang.String.valueOf(Object x)</code>函数将在<code>x</code>不为<code>null</code>时返回<code>x.toString()</code>，因此我们可以通过重写<code>toString</code>方法使<code>println</code>函数输出自定义格式的“实例属性”。详见
<a
href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/PrintStream.html#println()">println()
- JDK Documentation</a> 和 <a
href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/String.html#valueOf(java.lang.Object)">valueOf()
- JDK Documentation</a> 。</p>
<blockquote>
<p>简而言之这个 toString() 就是对象的字符串描述，println() 会打印它</p>
</blockquote>
<h2 id="pre1_task2">Pre1_task2</h2>
<blockquote>
<p>本次目标：多态和继承的练习，以及了解工厂模式</p>
</blockquote>
<p><del>虽然我没写出来工厂模式，但是我觉得这很漂亮，很符合我对设计模式的想象</del></p>
<p><del>工厂模式可以看我的另一篇博客（啊写好了会post上来的，问就是还在紧锣密鼓地筹备当中）</del></p>
<h3 id="一继承">一、继承</h3>
<blockquote>
<p>继承就是定义子类继承父类的特征和行为，使得子类可以拥有父类的属性和方法，从而起到代码复用的目的。</p>
<p><strong>从语义上来说，在 <code>A</code> 和 <code>B</code> 类型满足
<em>is-a</em> 关系（A is a B），即<code>A</code> 类型是 <code>B</code>
类型的一种时，可以使用继承来在程序表述。</strong></p>
</blockquote>
<h3 id="二向上转型upcasting">二、向上转型（Upcasting）</h3>
<blockquote>
<p>在建立了继承关系之后，可以使用<strong>父类型</strong>去引用通过<strong>子类型</strong>创建的对象。</p>
</blockquote>
<p>在调用构造函数的时候会涉及先后问题，这里要注意，是先调用父类的构造函数，再调用子类的构造函数，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Equipment</span><span class="params">(<span class="type">int</span> tmpId, String tmpName, <span class="type">long</span> tmpPrice)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = tmpId;</span><br><span class="line">    <span class="built_in">this</span>.name = tmpName;</span><br><span class="line">    <span class="built_in">this</span>.price = tmpPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类构造函数</span></span><br><span class="line"><span class="comment">// public class Bottle extends Equipment</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Bottle</span><span class="params">(<span class="type">int</span> tmpId, String tmpName, <span class="type">long</span> tmpPrice,</span></span><br><span class="line"><span class="params">                  <span class="type">double</span> tmpCapacity, <span class="type">boolean</span> tmpFilled)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(tmpId, tmpName, tmpPrice);</span><br><span class="line">    <span class="built_in">this</span>.capacity = tmpCapacity;</span><br><span class="line">    <span class="built_in">this</span>.filled = tmpFilled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public class HealingPotion extends Bottle</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HealingPotion</span><span class="params">(<span class="type">int</span> tmpId, String tmpName, <span class="type">long</span> tmpPrice,</span></span><br><span class="line"><span class="params">                         <span class="type">double</span> tmpCap, <span class="type">boolean</span> tmpFilled, <span class="type">double</span> tmpEff)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(tmpId, tmpName, tmpPrice, tmpCap, tmpFilled);</span><br><span class="line">    <span class="built_in">this</span>.efficiency = tmpEff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三向下转型downcasting">三、向下转型（Downcasting）</h3>
<blockquote>
<p>一种比较危险的行为，需要搭配 instanceof 来使用</p>
</blockquote>
<p>Java 语言提供了一个特殊的关键词 <code>instanceof</code>
用来判断一个对象引用所指向的对象的创建类型是否为特定的某个类，一般写为
<code>obj instanceof A</code>，其中 obj 为一个对象引用，A
为一个类型（类或接口），这个表达式的取值结果为布尔型，如果 obj
的创建类型为 A，则结果为 true，否则为 false。在这个表达式取值为 true
的情况下，可以使用<strong>向下转型</strong> (down cast) 来使用一个 A
类型的对象来引用obj： <code>A ao = (A)obj</code> 。注意，实际上 obj
所指向对象的创建类型永远不会发生变化，转型的只是对象引用类型。</p>
<p>本次作业中的应用为：哦好像没有应用，在下一个 task 里有应用</p>
<h3 id="四对象方法的重写和复用">四、对象方法的重写和复用</h3>
<blockquote>
<p>有时候，具有继承关系的类的某些行为具有递进关系，但又有自己特定的行为。</p>
<p>我们期望这两个类中实现的特定方法同名。<strong>这种让子类重新实现一个在父类中已经实现的方法是面向对象的一个重要机制，称为方法重写。</strong>方法重写获得的直接好处是让子类与父类在相应方法的调用上保持了一致性。</p>
<p>更通俗的说，重写方法与父类方法在行为上具有相似功能，但子类重写的方法一般额外增加一些行为。</p>
<p>在程序编写方面，一般会为重写方法标上一个@Override标签。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Course</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Course(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">displayInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这门课很难&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OOCourse</span> <span class="keyword">extends</span> <span class="title class_">Course</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">displayInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这门课很难&quot;</span>); <span class="comment">// 这里出现了代码拷贝，是低质量的代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;上面那句是放p&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议更换为下面的代码：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OOCourse</span> <span class="keyword">extends</span> <span class="title class_">Course</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">displayInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.displayInfo(); <span class="comment">// 调用了类Course中定义的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;上面那句是放p&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java语言提供了一个重要的关键词<strong>super</strong>，它实际指代的是当前对象从父类继承得到的内容</p>
<blockquote>
<p>联想上面构造函数里的super，你甚至可以理解为，这个super会替换为这个类的父类名称，这里使用
<code>Course.displayInfo()</code> 也是一样的效果，同理，构造函数
<code>super(argument)</code> 也可以替换为
<code>Course(argument)</code></p>
</blockquote>
<h3 id="五多态">五、多态</h3>
<p>实际调用的方法与对象<strong>引用的类型</strong>无关，取决于被引用对象的<strong>创建类型</strong>。请看下面的代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Course</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Course</span>();</span><br><span class="line"><span class="type">Course</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OOCourse</span>();</span><br><span class="line">c1.displayInfo();</span><br><span class="line">c2.displayInfo();</span><br></pre></td></tr></table></figure>
<p>其中通过c1调用的实际是Course类实现的displayInfo方法，而通过c2调用的则是OOCourse类重写的displayInfo方法，但实际上c1和c2的引用类型都是Course。上面我们提到的这个特性，就叫做多态。</p>
<p><strong>参差多态，乃是幸福本源</strong>（逃）</p>
<h3 id="六异常处理">六、异常处理</h3>
<blockquote>
<p>异常：程序运行时发生了意外的事件，阻止了程序按照程序员的预期正常执行</p>
</blockquote>
<p>运行出错后，Java
提供了一种优秀的解决办法：异常处理机制，它采取显式的方式处理异常，包括两个方面：</p>
<ul>
<li>引入了专门的表达和处理方式，代码上一目了然就能看出是异常处理；</li>
<li>一旦发生异常，会强迫程序执行进入异常处理分支。</li>
</ul>
<p>在Java语言中，每个异常都被封装为Exception，异常有抛出和捕捉两种处理方式。所谓抛出，就是使用Java提供的throw关键词来产生一个Exception或者其某个子类的对象；而捕捉则是通过catch关键词来捕捉在一段代码的执行过程中所抛出的相关异常对象。</p>
<p>课程推荐使用异常处理机制来区分处理显著不同于一般情况下的数据状态。使用异常处理可以让你的代码更加清晰易于理解，降低出现
bug 的可能性。</p>
<p>👆上面内容来自指导书<del>，相信我不说你也看出来了</del></p>
<p>前面代码出现异常后，后面的代码不会执行，程序会抛出异常并结束（×）</p>
<p>异常发生并不意味着程序终止，找到地方可以处理这个异常即可</p>
<p>当然，当前作用域，异常后面的部分不会执行</p>
<p>具体运行过程为：</p>
<p><img src="..\images\exception-execution.png" /></p>
<p>一个很全面覆盖上面流程图的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIndex</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        a[<span class="number">10</span>] = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">h</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            g();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">k</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            h();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;k()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            k();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;caught&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>解释：</p>
<p>f产生异常，所处不是try，所处是函数g，返回调用者g</p>
<p>g与f同理，返回调用者h</p>
<p>h产生异常，所处不是try，所处是if语句，不是函数，退出到if大括号的外层，此时所处是函数，返回调用者k</p>
<p>k产生异常，产生异常的代码块所处是try，catch异常不匹配（因为是AIOOBE），退出到外层</p>
<p>能不能把所有代码放到一个try块里，这样啥异常都能输出啊（逃）</p>
<p>《Core Java》的第七章相关内容请见：<del>紧锣密鼓筹备中</del></p>
<h2 id="pre1_task3">Pre1_task3</h2>
<h3 id="前言-碎碎念">前言 &amp; 碎碎念</h3>
<blockquote>
<p>这次作业真的有点难度，我也是借助了 bygg <span class="citation"
data-cites="一个虚空的blog地址">@一个虚空的blog地址</span> 的力量才勉强
AK 了</p>
</blockquote>
<p>难点主要在 deep clone 和 所属关系的复制</p>
<p>deep clone 这里呼应了前面说的向下转型 downcasting，具体来说，需要根据
Commodity 的类型创建对应的 Commodity 副本，此时需要用到 instanceof
运算符</p>
<p>具体的实现可以见代码，代码我放到 GitHub仓库 里了</p>
<p>这里的版本控制的实现，和 Git
的好像不大一样，先挖个坑，有空思考了回来填上</p>
<p>一个细的点在于，不能对 Adventurer 所拥有的 Adventurer 直接 deep
clone</p>
<p>举个例子，A 雇佣了 B，如果 deep clone，B 使用道具后的后果不能同步给 A
雇佣的这个 B，所以两个 B 就不一样了。这里直接 shallow
copy即可（其实也节省了代码量）</p>
<h2 id="pre2_task1">Pre2_task1</h2>
<p>挺好做的，可以用捕获组，也可以用字符串类的方法，不过后面迭代比较痛苦</p>
<p>另外，关于 substring()
方法，建议大家多试试下标的选择。不要怕麻烦，这个地方很可能背刺你</p>
<h2 id="pre2_task2">Pre2_task2</h2>
<p>这次也很简单。我感觉正则的题目比第一次的大模拟还是友好不少的</p>
<h2 id="pre2_task3">Pre2_task3</h2>
<p>注意跨年日期的判断（可以参考我的狼人样例，能过了强测基本没问题）</p>
<h2 id="pre3_task1">Pre3_task1</h2>
<p>想起pre1_task3那周，我在图书馆坐了整整一周，最后还是de不出bug，果然肉眼debug的形式是不行的。</p>
<p>建议大家自己捏一些数据</p>
<p>我的数据也放在 GitHub仓库 里了</p>
<p>正则表达式的题目，就建议大家多试多练多学习。我个人感觉没什么好说的，大家比我聪明，看一看就能学会</p>
<p>我一直没学先验后验什么的，挖个坑，下学期学，下学期一定学，嗯</p>
<h2 id="最后的最后">最后的最后</h2>
<p>看过很多博客，还是觉得qsgg的“<strong>只有</strong>一个曲别针的小男孩”的故事最入我心</p>
<p>小男孩经过一系列的交换，把手里的曲别针换成了别墅</p>
<p>可我觉得这故事没什么意思，我更想看到小男孩用别墅继续交换继续交换，最后虽然损失了别墅，但是收获了远比别墅珍贵更多的东西，最后云淡风轻：“嗯，不过损失一个曲别针而已，我得到的是更大的世界”</p>
<p>我来的时候连一个曲别针也没有，我走的时候却收获了很多故事，认识了很多朋友，收获了比别墅价值大得多的东西</p>
<p>很多很多年以后，可能我还会想起那个新主楼的夜晚和风景，和五教二楼的美丽对拍</p>
<p>或许要问有什么遗憾，那就是最后一次的作业赶时间没用递归下降完成。以及这门课确实有点耽误我计组的时间了，不过这都过去了</p>
<p>他给我的最大的宝藏就是，如果方法得当，愿意多做调试愿意自己多捏数据，你能够对自己的成绩有十足的把握，每次强测之前我都有信心这次再拿100。以及，他让我知道小白也有从零开始成为金刚的权利，真的让我尝到了取得小成就的满足</p>
<p>后面的文字写的有些仓促，主要是计组进度压上来，顶不住了，对不住各位认真读到这里的看官</p>
<p>以及正则的题目确实不难，希望大家认真学认真练</p>
<p>希望诸位看官能从我这堆毫无章法的文字中读出些东西</p>
<p>如果看完什么也没看明白，那是怪我水平粗浅，与诸位无关</p>
<p>一路顺风</p>
]]></content>
      <categories>
        <category>OO</category>
        <category>S3</category>
      </categories>
      <tags>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora数学公式</title>
    <url>/MarkDown-Grammar/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>MarkDown 比较全的数学公式语法集合</p>
</blockquote>
<span id="more"></span>
<p>[TOC] &gt; 其实本质是对 Tex 语法的支持</p>
<h3 id="一打开typora选择数学模块">一、打开Typora选择数学模块</h3>
<p>三种打开方式： * 点击“段落” --&gt; “公式块” * 快捷键ctrl + shift +m *
“$$” + 回车</p>
<h3 id="二添加数学公式">二、添加数学公式</h3>
<p>输出美观的数学公式，需要知道他们的格式和代码！
ps:Typora有时出现公式块无法删除，可能是软件bug，Ctrl + /
打开源代码模式，在这里面可以进行删除 <span class="math display">\[
e^{i\pi + 1} = 2
\]</span> ### 三、常用的公式格式代码练习</p>
<ol type="1">
<li>公式块内换行</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">\\ 公式块内换行</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>常用基本函数：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">1、x^2 //上下标</span><br><span class="line">2、1/2 //分式1</span><br><span class="line">3、\frac&#123;1&#125;&#123;2&#125; //分式2</span><br><span class="line">4、\cdots //省略号</span><br><span class="line">5、\sqrt&#123;4&#125; //开根号</span><br><span class="line">6、\vec&#123;a&#125; //矢量</span><br><span class="line">7、\int&#123;x&#125;dx //积分1</span><br><span class="line">8、\int_&#123;1&#125;^&#123;2&#125;dx //积分2</span><br><span class="line">9、\lim&#123;a + b&#125; //极限1</span><br><span class="line">10、\lim_&#123;n\rightarrow + \infty&#125; //极限2</span><br><span class="line">11、\sum_&#123;n=1&#125;^&#123;100&#125;&#123;a_n&#125; //累加</span><br><span class="line">12、\prod_&#123;n=1&#125;^&#123;199&#125;&#123;x_n&#125; //累乘</span><br><span class="line">13、\sin&#123;(x + y)&#125; //三角函数</span><br><span class="line">14、\ln2 //对数函数1</span><br><span class="line">15、\log_28 //对数函数2</span><br><span class="line">16、a&#x27; //导数</span><br><span class="line">17、\partial&#123;F&#125; //偏微分</span><br><span class="line">18、\iint&#123;xy&#125;dxdy //二重积分</span><br><span class="line">19、\oiint&#123;x + y&#125;dxdy //二重环路积分</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
1、x^2\\
2、1/2\\
3、\frac{1}{2}\\
4、\cdots\\
5、\sqrt{4}\\
6、\vec{a}\\
7、\int{x}dx\\
8、\int_{1}^{2}dx\\
9、\lim{a + b}\\
10、\lim_{n\rightarrow + \infty}\\
11、\sum_{n=1}^{100}{a_n}\\
12、\prod_{n=1}^{199}{x_n}\\
13、\sin{(x + y)}\\
14、\ln2\\
15、\log_28\\
16、a&#39;\\
17、\partial{F}\\
18、\iint{xy}dxdy\\
19、\oiint{(x + y)}dxdy\\
\]</span></p>
<ol start="3" type="1">
<li>公式块内左对齐：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;aligned&#125; //</span><br><span class="line">&amp;1、y = \sin(x) \\&amp;为对齐格式符</span><br><span class="line">&amp;2、</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{aligned}
&amp;1、y = \sin(x) \\
&amp;2、
\end{aligned}
\]</span></p>
<ol start="4" type="1">
<li>下标</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">v_1\\</span><br><span class="line">v_&#123;体积&#125; 下标为多个英文字母时，使用&#123;&#125;包起来：</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
v_1\\
v_{体积}
\]</span></p>
<ol start="5" type="1">
<li>关系运算符：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">\pm // ± plus&amp;minor</span><br><span class="line">\times // ×</span><br><span class="line">\div // ÷ divide</span><br><span class="line">\equiv // == equal</span><br><span class="line">\le // &lt;= lower&amp;equal</span><br><span class="line">\ge // &gt;= greater&amp;equal</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\pm\\
\times \\
\div\\
\equiv\\
\leq\\
\geq
\]</span></p>
<ol start="6" type="1">
<li>花括号公式组合：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">c(u) =</span><br><span class="line">\begin&#123;cases&#125; </span><br><span class="line">\sqrt\frac&#123;1&#125;&#123;N&#125;, u = 0 \\ </span><br><span class="line">\sum_&#123;n=1&#125;^&#123;100&#125;&#123;a_n&#125;, n \neq0  neq:not equal</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
c(u) =
\begin{cases}
\sqrt\frac{1}{N}, u = 0 \\
\sum_{n=1}^{100}{a_n}, n \neq0
\end{cases}
\]</span></p>
<ol start="7" type="1">
<li>空格：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">a \quad b</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
a \quad b
\]</span></p>
<ol start="8" type="1">
<li>矩阵：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">0&amp;1&amp;1\\</span><br><span class="line">1&amp;1&amp;0\\</span><br><span class="line">1&amp;0&amp;1\\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{matrix}
0&amp;1&amp;1\\
1&amp;1&amp;0\\
1&amp;0&amp;1\\
\end{matrix}
\]</span></p>
<blockquote>
<p>在起始、结束标记用下列词替换 matrix：</p>
<p>pmatrix：小括号边框 bmatrix：中括号边框 ` Bmatrix：大括号边框
vmatrix：单竖线边框 Vmatrix：双竖线边框</p>
</blockquote>
<p><span class="math display">\[
\begin{pmatrix}
0&amp;1&amp;1\\
1&amp;1&amp;0\\
1&amp;0&amp;1\\
\end{pmatrix}
\]</span></p>
<p><span class="math display">\[
\begin{vmatrix}
0&amp;1&amp;1\\
1&amp;1&amp;0\\
1&amp;0&amp;1\\
\end{vmatrix}
\]</span></p>
<ol start="9" type="1">
<li>特殊字符及希腊字母表：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\infty //无穷</span><br><span class="line">\emptyset //空集</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\infty \\
\emptyset
\]</span></p>
<ol start="10" type="1">
<li>更多字符 更多特殊字符及希腊字母代码见wps中LaTex公式符号</li>
</ol>
<p>① 常用字母字符</p>
<figure>
<img
src="https://i0.hdslb.com/bfs/article/a76a8e35df7722e6b3d02b70f579380bc768afbf.png@921w_459h_progressive.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>② 特殊符号</p>
<figure>
<img
src="https://i0.hdslb.com/bfs/article/5f471724c265c39e6c832a9a3212f67aa094791e.png@942w_387h_progressive.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="https://i0.hdslb.com/bfs/article/a750d31bd5a69f8dd8b58c6b2d690988025d323c.png@942w_1500h_progressive.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
]]></content>
      <categories>
        <category>Tools</category>
        <category>S2</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code配置LaTeX</title>
    <url>/vscode-configure-latex/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>记录在 Windows10 中采用 <span class="math inline">\(MixTEX\)</span>
在 VS Code 搭建 <span class="math inline">\(\LaTeX\)</span>
环境的过程</p>
</blockquote>
<span id="more"></span>
<h2 id="安装编译器">安装编译器</h2>
<p>原 <code>TexLive</code> 体积过大，采用包管理器进行安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 MikTeX</span></span><br><span class="line">scoop install miktex</span><br></pre></td></tr></table></figure>
<h2 id="配置-vs-code">配置 VS Code</h2>
<p>安装 <code>LaTeX Workshop</code> 扩展</p>
<p>加入如下配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;latex-workshop.latex.tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-shell-escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;%DOCFILE%&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;xelatex&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="解决报错">解决报错</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">major issue: So far, you have not checked for MiKTeX updates.</span><br></pre></td></tr></table></figure>
<p>找到 <code>MikTex Console</code>
这个程序，右键点击“以管理员身份运行”，然后点击“检查更新”</p>
<blockquote>
<p><em>Ref:</em></p>
<p><em><a href="https://zhuanlan.zhihu.com/p/139210056">搭建 LaTeX
舒适写作环境（VSCode） - 知乎 (zhihu.com)</a></em></p>
</blockquote>
]]></content>
      <categories>
        <category>Tools</category>
        <category>S5</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
        <tag>Path</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Group Theory</title>
    <url>/visual-group-theory-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="总述">总述</h2>
<blockquote>
<p>Lectures of Visual Group Theory</p>
</blockquote>
<span id="more"></span>
<h1 id="visual-group-theory">Visual Group Theory</h1>
<h2 id="overview">Overview</h2>
<p>Three nonstandard aspect of nonstandard approach in the book:</p>
<ul>
<li><strong>images and visual examples</strong>-the heart</li>
<li>focuses more on finite groups than infinite ones-easier to diagram
and give a solid foundation of intuition</li>
<li>approaches groups from the opposite direction of traditional
textbooks-groups are defined to be collections of actions and later
proved to be sets with binary operations</li>
<li><strong>linear order</strong>, to be read in order</li>
<li>exceptions: Chapter 5 and Chapter 10, you can skip most of them
without understanding other chapters. But the definition of abelian in
Section 5.2 and the Cauchy's Theorem in Section 9.2 are important</li>
</ul>
<h2 id="what-is-a-group">What is a group?</h2>
<blockquote>
<p>Group theory is not primarily about numbers, but rather about
<strong>patterns</strong> and <strong>symmetry</strong></p>
</blockquote>
<h4 id="four-key-observations">Four key observations</h4>
<p>Observation 1</p>
<ul>
<li>There is a predefined list of moves that never changes.</li>
</ul>
<p>Observation 2</p>
<ul>
<li>Every move is reversible.</li>
</ul>
<p>Observation 3</p>
<ul>
<li>Every move is deterministic.</li>
</ul>
<p>Observation 4</p>
<ul>
<li>Moves can be combined in any sequence.</li>
</ul>
<p>A move is a twist of one of the six faces.</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507155405607.png"
alt="image-20230507155405607" />
<figcaption aria-hidden="true">image-20230507155405607</figcaption>
</figure>
<p>Let's rephrase the 4 observations as rules (axioms) that will define
the boundaries of our objects of study.</p>
<h4 id="rules-of-groups">Rules of groups</h4>
<p>Rule 1</p>
<ul>
<li>There is a predefined of <strong>actions</strong> that never
changes.</li>
</ul>
<p>Rule 2</p>
<ul>
<li>Every action is reversible.</li>
</ul>
<p>Rule 3</p>
<ul>
<li>Every action is deterministic.</li>
</ul>
<p>Rule 4</p>
<ul>
<li>Any sequence of consecutive actions is also an action.</li>
</ul>
<blockquote>
<p>We swapped the word "move" for "action"</p>
<p>The (usually short) list of actions required by Rule 1 is our set of
building blocks; called the <strong>generators</strong>.</p>
<p><strong>Not</strong> all actions are generators. Generators are the
subset of all possible actions in a group.</p>
<p>Rule 4 tells us that any sequence of the generators is also an
action.</p>
</blockquote>
<p>Our unofficial definition of a group (We'll make things a bit
rigorous later.)</p>
<h4 id="definition-informal">Definition (informal)</h4>
<blockquote>
<p>A group is a set of actions satisfying Rules 1-4.</p>
</blockquote>
<p>Let's call these generators a, b, c, d, e, and f. Every word over the
alphabet <span class="math inline">\(\{a, b, c, d, e, f\}\)</span>
describes a unique configuration of the cube (starting from the solved
position)</p>
<blockquote>
<p>Obviously, I don't care which is which.</p>
</blockquote>
<h4 id="summary-of-the-big-ideas">Summary of the big ideas</h4>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507160953096.png"
alt="image-20230507160953096" />
<figcaption aria-hidden="true">image-20230507160953096</figcaption>
</figure>
<h2 id="cayley-graphs">Cayley graphs</h2>
<h3 id="a-road-map-for-the-rubiks-cube">A road map for the Rubik's
Cube</h3>
<p>Let's pretend for a moment that we were interested in writing a
complete solutions manual for the Rubik's Cube. And let me be more
specific</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507161729491.png"
alt="image-20230507161729491" />
<figcaption aria-hidden="true">image-20230507161729491</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507161902686.png"
alt="image-20230507161902686" />
<figcaption aria-hidden="true">image-20230507161902686</figcaption>
</figure>
<blockquote>
<p>We can think of the <em>Big Book</em> as a road map for the Rubik's
Cube. Each page says "you are here" and “if you follow this road, you'll
end up over there."</p>
</blockquote>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507162334393.png"
alt="image-20230507162334393" />
<figcaption aria-hidden="true">image-20230507162334393</figcaption>
</figure>
<blockquote>
<p>Despite the Big Book's apparent shortcomings, it made for a good
thought experiment. The Big Book is a map of a group. The Big Book
introduced the mapmaking ideas, although the map is too large. We can
use the same ideas to map out any group. In fact, we shall frequently do
exactly that.</p>
<p>And Let's try something simpler....</p>
</blockquote>
<h3 id="the-rectangle-puzzle">The Rectangle Puzzle</h3>
<blockquote>
<p>How can we check the moves of the Rectangle Puzzle form a group?</p>
</blockquote>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507165129308.png"
alt="image-20230507165129308" />
<figcaption aria-hidden="true">image-20230507165129308</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507170457691.png"
alt="image-20230507170457691" />
<figcaption aria-hidden="true">image-20230507170457691</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507170733456.png"
alt="image-20230507170733456" />
<figcaption aria-hidden="true">image-20230507170733456</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507171547441.png"
alt="image-20230507171547441" />
<figcaption aria-hidden="true">image-20230507171547441</figcaption>
</figure>
<h3 id="more-on-arrows">More on arrows</h3>
<ul>
<li><p>node <span class="math inline">\(y\)</span> is the result of
applying the action $ g G $ to node $x $.</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507173327983.png"
alt="image-20230507173327983" />
<figcaption aria-hidden="true">image-20230507173327983</figcaption>
</figure></li>
<li><p>if an action <span class="math inline">\(h \in G\)</span> is its
own inverse (that is, <span class="math inline">\(h ^ 2 = e\)</span>),
then we have a 2-way arrow. For clarity, our convention is to drop the
tips on all 2-way arrows like that</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507173338448.png"
alt="image-20230507173338448" />
<figcaption aria-hidden="true">image-20230507173338448</figcaption>
</figure></li>
<li><p>When we focus on a group's structure, we frequently omit the
labels at the nodes</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507173356200.png"
alt="image-20230507173356200" />
<figcaption aria-hidden="true">image-20230507173356200</figcaption>
</figure></li>
</ul>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507185713813.png"
alt="image-20230507185713813" />
<figcaption aria-hidden="true">image-20230507185713813</figcaption>
</figure>
<blockquote>
<p>isomorphic: corresponding or similar in form and relations.</p>
</blockquote>
<h3 id="the-klein-4-group">The Klein 4-group</h3>
<p>Any group with the same Cayley diagram as the Rectangle Puzzle and
the 2-Light Switch Group is called the Klein 4-group, denoted by <span
class="math inline">\(V_4\)</span> for <em>vierergruppe</em>,
“four-group" in German. It is named after the mathematician Felix
Klein.</p>
<h3 id="the-triangle-puzzle">The triangle puzzle</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507190725806.png"
alt="image-20230507190725806" />
<figcaption aria-hidden="true">image-20230507190725806</figcaption>
</figure>
<h3 id="properties-of-cayley-graphs">Properties of Cayley graphs</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507191305245.png"
alt="image-20230507191305245" />
<figcaption aria-hidden="true">image-20230507191305245</figcaption>
</figure>
<h3 id="a-theorem-and-proof">A Theorem and Proof!</h3>
<p>Theorem Suppose an action <span class="math inline">\(g\)</span> has
the property that <span class="math inline">\(gx = x\)</span> for some
other action <span class="math inline">\(x\)</span>. Then g is the
<em>identity action</em>, i.e., <span class="math inline">\(gh = h =
hg\)</span> for all other actions <span
class="math inline">\(h\)</span>.</p>
<blockquote>
<p><span class="math inline">\(g\)</span> apply to <em>anything
else</em> !</p>
</blockquote>
<p>Proof:</p>
<blockquote>
<p>The identity action (we'll denote by 1) is simply the action <span
class="math inline">\(hh^{-1}\)</span>, for any action <span
class="math inline">\(h\)</span>. If <span class="math inline">\(gx =
x\)</span>, then multiplying by <span
class="math inline">\(x^{-1}\)</span> <em>on the right</em> yields:</p>
<p><span class="math display">\[g = gxx^{-1} = xx^{-1} = 1\]</span>.</p>
<p>Thus <span class="math inline">\(g\)</span> is the identity
action.</p>
</blockquote>
<h2 id="groups-in-science-art-and-mathematics">Groups in science, art,
and mathematics</h2>
<h3 id="group-of-symmetries">Group of symmetries</h3>
<h3 id="how-to-make-a-group-out-of-symmetries">How to make a group out
of symmetries</h3>
<p>Groups relate to symmetry because an object's symmetries can be
described using arrangements of the object's parts.</p>
<p>Algorithm 1. Identify all the parts of the object that are similar
(e.g., the corners of an n-gon), and give each such part a different
number. 2. Consider the actions that may rearrange the numbered parts,
but leave the object it the same physical space. (This collection of
actions forms a group. 3. (Optional) If you want to visualize the group,
explore and map it as we did in the previous lecture with the rectangle
puzzle, etc.</p>
<p><strong>Footprint</strong>: the physical space that an object
occupies</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507193006888.png"
alt="image-20230507193006888" />
<figcaption aria-hidden="true">image-20230507193006888</figcaption>
</figure>
<blockquote>
<p>This section seems to be useless. So if I have time later, let's
continue to see at 9:37.</p>
</blockquote>
<h2 id="group-presentations">Group presentations</h2>
<blockquote>
<p>Our definition of groups before (a collection of actions that obeyed
Rules 1-4) is not the ordinary definition of a group. We'll be working
toward introducing the standard (and more formal) definition of a group.
Along the way, we will learn some helpful <strong>tools</strong> to get
us there.</p>
<p>Group presentations, an algebraic device to concisely describe groups
by their <strong>generators</strong> and <strong>relations</strong>.</p>
</blockquote>
<h3 id="more-on-cayley-diagrams">More on Cayley diagrams</h3>
<p>All arrows of a fixed color correspond to the same generator.</p>
<p>Two things with the node:</p>
<ul>
<li><p>Labeling the nodes with configurations of a thing we are acting
on</p></li>
<li><p>Leaving the nodes unlabeled (this is the "abstract Cayley
diagram”)</p></li>
<li><p>Label the nodes with actions (this is called a “diagram of
actions").</p>
<blockquote>
<p>motivated by the fact that every <strong>path</strong> in the Cayley
diagram represents an <strong>action</strong> of the group</p>
</blockquote></li>
</ul>
<p>Motivating idea If we distinguish one node as the “unscrambled”
configuration and label that with the identity action, then we can label
each remaining node with the action that it takes to reach it from the
unscrambled state.</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507210640251.png"
alt="image-20230507210640251" />
<figcaption aria-hidden="true">image-20230507210640251</figcaption>
</figure>
<h3 id="a-group-calculator">A "group calculator"</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230510215301253.png"
alt="image-20230510215301253" />
<figcaption aria-hidden="true">image-20230510215301253</figcaption>
</figure>
<p>A concise way to describe <span class="math inline">\(V_4\)</span> is
the following group representation: <span class="math display">\[
V_4 = &lt;v, h | v^2 = e, h^2 = e, vh = hv &gt;
\]</span> The following is one (of many!) presentations for this group:
<span class="math display">\[
D_3 = &lt;r, f | r^3 = e, f^2 = e, r^2f = fr&gt;
\]</span></p>
<blockquote>
<p>To be more precise</p>
</blockquote>
<p>If we want to be more precise, we use a <strong>group
presentation</strong> of the following form: <span
class="math display">\[
G = &lt;generators | relations&gt;
\]</span> The vertical bar here can be thought of as meaning "subject
to".<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230510220205721.png"
alt="image-20230510220205721" /></p>
<blockquote>
<p>The famous "halting problem" is unsolvable</p>
</blockquote>
<h2 id="multiplication-tables">Multiplication tables</h2>
<blockquote>
<p>We are almost ready to introduce the formal definition of a group In
this lecture, we will introduce one more useful algebraic tool for
better understanding groups: multiplication tables. We will also look
more closely at inverses of the actions in a group. Finally, we will
introduce a new group of size 8 called the quaternions which frequently
arise in theoretical physics.</p>
</blockquote>
<h3 id="inverses">Inverses</h3>
<p>denoted by <span class="math inline">\(g^{-1}\)</span></p>
<h3 id="multiplication-tables-1">Multiplication tables</h3>
<p>follow the convention that write row <span
class="math inline">\(g\)</span> before column <span
class="math inline">\(h\)</span></p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230510221817825.png"
alt="image-20230510221817825" />
<figcaption aria-hidden="true">image-20230510221817825</figcaption>
</figure>
<h3 id="some-remarks">Some remarks</h3>
<p>A group is abelian <span class="math inline">\(iff\)</span> its
multiplication table is symmetric about the “main diagonal."</p>
<p>In each row and each column, each group action occurs exactly
once.</p>
<blockquote>
<p>The following theorem will explain that</p>
</blockquote>
<p><strong>Theorem:</strong> An element cannot appear twice in the same
row or column of a multiplication table.</p>
<p><strong>Proof:</strong></p>
<p>Suppose that in row <span class="math inline">\(a\)</span>, the
element <span class="math inline">\(g\)</span> appears in columns <span
class="math inline">\(b\)</span> and <span
class="math inline">\(c\)</span>. Algebraically, this means <span
class="math display">\[
ab=g=ac
\]</span> Multiplying everything on the left by <span
class="math inline">\(a^{-1}\)</span> yields <span
class="math display">\[
a^{-l}ab=a^{-1}g=a^{-1}ac \Rightarrow b = c
\]</span> Thus, <span class="math inline">\(g\)</span> (or any element)
element cannot appear twice in the same row.</p>
<p>Similarly, we can finish the proof for column.</p>
<h3 id="the-quaternion-group">The quaternion group</h3>
<h2 id="the-formal-definition-of-a-group">The formal definition of a
group</h2>
<p><span class="math inline">\(S\)</span> is closed on the operation
*</p>
<h3 id="associativity">Associativity</h3>
<p>交换律</p>
<p>An operation is associative if parentheses are permitted anywhere,
but required nowhere.</p>
<h3 id="formal-definitions">Formal definitions</h3>
<p>Viewing groups from these two different paradigms:</p>
<ul>
<li>a group as a collection of actions</li>
<li>a group as a set with a binary operation</li>
</ul>
<h3 id="properties">Properties</h3>
<p><strong>Theorem: </strong>Every element of a group has a
<em>unique</em> inverse</p>
<p><strong>Proof:</strong></p>
<p><strong>Theorem:</strong> Every group has a <em>unique</em> identity
element</p>
<h2 id="cyclic-and-abelian-groups">Cyclic and abelian groups</h2>
<h3 id="overview-1">Overview</h3>
<p><span class="math inline">\(5\)</span> families of groups:</p>
<ul>
<li>cyclic groups</li>
<li>abelian groups</li>
<li>dihedral groups</li>
<li>symmetric groups</li>
<li>alternating groups</li>
</ul>
<p>Informally, a group is cyclic if it is generated by a single element,
and is abelian if multiplication commutes. (Like <span
class="math inline">\(a * b = b * a, \forall a, b \in G\)</span>)</p>
<h3 id="cyclic-groups-additively">Cyclic groups, additively</h3>
<p><strong>Definition:</strong> A group is cyclic if it can be generated
by a single element.</p>
<blockquote>
<p>Finite cyclic groups describe the symmetry of objects that have
<em>only</em> rotational symmetry.</p>
</blockquote>
<p><span class="math display">\[
C_n = &lt;r| r^n = e&gt;
\]</span></p>
<p><strong>Remark:</strong> This is a natural generator, but not the
only one. For instance, <span class="math inline">\(r^3\)</span> is also
a generator.</p>
<p><strong>Definition:</strong> The order of a group <span
class="math inline">\(G\)</span> is the number of distinct elements in
<span class="math inline">\(G\)</span>, denoted by <span
class="math inline">\(|G|\)</span>.</p>
<p>The cyclic group of order <span class="math inline">\(n\)</span>
(i.e., <span class="math inline">\(n\)</span> rotations) is denoted
<span class="math inline">\(C_n\)</span> (or sometimes by <span
class="math inline">\(\mathbb{Z}_n\)</span>). In fact, the alternative
notation <span class="math inline">\(\mathbb{Z}_n\)</span> comes from
the fact that the binary operation in <span
class="math inline">\(C_n\)</span> is just modular addition. To add two
numbers in <span class="math inline">\(\mathbb{Z}_n\)</span>, add them
as integers, divide by <span class="math inline">\(n\)</span>, and take
the remainder.</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230512195612827.png"
alt="image-20230512195612827" />
<figcaption aria-hidden="true">image-20230512195612827</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230512195732611.png"
alt="image-20230512195732611" />
<figcaption aria-hidden="true">image-20230512195732611</figcaption>
</figure>
<h3 id="cyclic-groups-multiplicatively">Cyclic groups,
multiplicatively</h3>
<p>If <span class="math inline">\(r\)</span> is a generator (e.g., a
rotation by <span class="math inline">\(2 \pi /n\)</span>), then we can
denote the <span class="math inline">\(n\)</span> elements by <span
class="math display">\[
1, r, r^2, \dots , r^{n-1}
\]</span> Think of <span class="math inline">\(r\)</span> as the complex
number <span class="math inline">\(e^{2\pi i/n}\)</span>, with the group
operation being <em>multiplication!</em></p>
<blockquote>
<p>复数相乘，模相乘，辐角相加</p>
</blockquote>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230512202225352.png"
alt="image-20230512202225352" />
<figcaption aria-hidden="true">image-20230512202225352</figcaption>
</figure>
<h3 id="more-on-cyclic-groups">More on cyclic groups</h3>
<p>The (unique) infinite cyclic group (additively) is (<span
class="math inline">\(\mathbb{Z}, +\)</span>), the integers under
addition. Using multiplicative notation, the infinite cyclic group is
<span class="math display">\[
G=&lt;r\quad|\quad&gt;=\{r^k : k \in \mathbb{Z}\}
\]</span> For the infinite group <span
class="math inline">\((\mathbb{Z}, +)\)</span>, only <span
class="math inline">\(1\)</span> or <span
class="math inline">\(-1\)</span> can be generators. (Considering
multiple generators are pointless.)</p>
<p><strong>Proposition:</strong> Any number from <span
class="math inline">\(\{0, 1, \dots, n-1\}\)</span> that is relatively
prime to <span class="math inline">\(n\)</span> will generate <span
class="math inline">\(\mathbb{Z}_n\)</span>.</p>
<p>For example, <span class="math inline">\(1, 2, 3, 4\)</span> all
generate <span class="math inline">\(\mathbb{Z}_5\)</span>. i.e., <span
class="math display">\[
\mathbb{Z}_5 = &lt;1&gt; = &lt;2&gt; = &lt;3&gt; = &lt;4&gt;.
\]</span></p>
<blockquote>
<p>The above notation just means "generated by" instead of a
presentation.</p>
</blockquote>
<p><strong>Observation:</strong> One of the most important properties of
the multiplication tables is that, if the headings on the multiplication
table are arranged in the "natural" order <span
class="math inline">\((0, 1, 2, \dots , n-1)\)</span> or <span
class="math inline">\((e, r, r^2, \dots, r^{n-1})\)</span>, then each
row is a cyclic shift to the left of the row above it.</p>
<h3 id="orbits">Orbits</h3>
<p>Orbits are usually written with braces. In the case, the orbit of
<span class="math inline">\(r\)</span> is <span
class="math inline">\(\{e, r, r^2\}\)</span>, and the orbit of <span
class="math inline">\(f\)</span> is <span class="math inline">\(\{e,
f\}\)</span></p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230514201107827.png"
alt="image-20230514201107827" />
<figcaption aria-hidden="true">image-20230514201107827</figcaption>
</figure>
<p><strong>Definition:</strong> The order of an element</p>
<blockquote>
<p>Anything you can get by the path, following or backwards</p>
</blockquote>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230514230616848.png"
alt="image-20230514230616848" />
<figcaption aria-hidden="true">image-20230514230616848</figcaption>
</figure>
]]></content>
      <tags>
        <tag>Notes</tag>
        <tag>Group Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>《满江红》观影感受</title>
    <url>/MJH-talks/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>说说我个人对《满江红》的一点看法</p>
</blockquote>
<span id="more"></span>
<p>首先要肯定，这部贺岁大戏确实花了心思在里面。取景比较考究，一众演员演技在线，用配乐演进和人物穿巷串联情节。</p>
<p>不过作为张艺谋执导的电影，似乎还有不少地方做的不尽人意。</p>
<p>剧情发展不合理。先说何立之死，何立心狠手辣，城府颇深，称得上有勇有谋。他既能知道刘喜和桃姑娘的关系，能猜出瑶琴是半路加入，便也不至于在临门一脚时匆匆靠近瑶琴打坏了一手稳赢的牌。瑶琴和张大都有枷锁，一把长刀在侧，到手的鸭子怎么看怎么不会飞，这里的发展更像是匆忙草草收尾了事，好让观众挨住隐隐的如厕之意。再者，于情于理没有让张大死的必要。于情，瑶琴守护大义守护真爱半路加入行动，张大本不必死，本可代岳将军见秦桧剐见山河收见国耻平，孙均性情中人，坐视侄儿死在眼前死不瞑目，坐视瑶琴让张大活下去的奉献化为乌有，更太过冷血乖戾，孙均一向鲁莽，喜好速战速决，甚至为秦桧挡下一刀，转变之大让人匪夷所思；于理，只有蓝玉一人在秦桧之侧，短刃也插在张大身上，枷锁解开身上亦无伤，孙均反手便可手刃秦桧昭告天下，退一万步来看，至少挟秦桧背满江红的夙愿可轻松实现，似乎也不必等待蓝绿二人均在时冒险逼迫，彼时二人利刃在手风险数倍，战场出生入死的将军更懂这个道理。最后，孙均一身伤痕，哪有力气纵马远去？不怕一身老伤皮开肉绽吗？</p>
<p>剧情设定本就荒诞。以我对南宋将军的粗浅了解，似乎岳将军并不太在乎遗言是否能流传万古，他应该更在乎百姓的平安和故土的平复，就像辛稼轩本意也不在写词不在种树，“却将万字平戎策，换得东家种树书”，谁他妈要种树，老子要平戎定虏。能有人手刃秦桧厉兵秣马率军出征，岳将军九泉之下也可安息；放秦桧狗贼一条狗命，让他遗臭万年，who
cares？谁他妈在乎秦桧是谁，老子只想看故国收复。确实有比生死重要百倍千倍的东西，但是这东西应该不只是岳将军的一首遗言。不得不说这里对岳将军的理解有些以己度人了，这里有种《1874》里“与你畅游战地”一般扯淡的浪漫。以及替身这件事，至少我个人感觉有些荒谬。</p>
<p>总之，作为贺岁片，导演来分一杯羹，观众看个乐呵看个感动，能想起这位千年前的故人想起这首无人不知无人不晓的不朽词篇，便也还算，说得过去吧。</p>
]]></content>
      <categories>
        <category>生活记录</category>
        <category>S3 Winter</category>
      </categories>
      <tags>
        <tag>观后感</tag>
      </tags>
  </entry>
  <entry>
    <title>如何阅读一本书</title>
    <url>/reading-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>经典教育学读书教程《如何阅读一本书》读书笔记</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>希望在一个月内读完——23.6.9</p>
<p>6——23.9.15</p>
</blockquote>
<h2 id="第一篇-阅读的层次">第一篇 阅读的层次</h2>
<h3 id="第一章-阅读的活力与艺术">第一章 阅读的活力与艺术</h3>
<blockquote>
<p>目标读者：把阅读当作获取知识，增进理解的途径的人</p>
</blockquote>
<ul>
<li>Too much information 和 too little
information都是对理解力的阻碍，很不幸，media在做这件事</li>
<li>media 提供给你一种精细包装的information</li>
</ul>
<h4 id="主动的阅读">主动的阅读</h4>
<ul>
<li>读书是一件主动的事，并且越主动效果越好</li>
<li>听众的”接收“更应该像是棒球赛中的catcher，作者和读者的交流是相互的</li>
</ul>
<h4 id="阅读的目标">阅读的目标</h4>
<ul>
<li>真正的阅读：不借助外力，借助内心的力量玩味书中字句慢慢提升自己</li>
</ul>
<blockquote>
<p>本书主要关注提升理解力的阅读，关注完全依赖书本身的学习</p>
</blockquote>
<h3 id="第二章-阅读的层次">第二章 阅读的层次</h3>
<blockquote>
<p>阅读的层次是渐进的，低层次阅读包含于高层次阅读</p>
</blockquote>
<ul>
<li><p><strong>基础阅读 (Elementary Reading)</strong></p>
<blockquote>
<p>这个句子在说什么</p>
</blockquote>
<ul>
<li>弄懂文字的含义</li>
<li>速读课程的层次</li>
</ul></li>
<li><p><strong>检视阅读 (Inspectional Reading)</strong></p>
<blockquote>
<p>这本书在谈什么、这本书的架构如何、这本书包含哪些部分</p>
</blockquote>
<ul>
<li>系统化略读</li>
<li>在规定时间内完成阅读任务</li>
<li>时间<strong>过短</strong>，难以掌握一本书所有重点</li>
<li><strong>有限时间内</strong>最好最完整的阅读</li>
</ul></li>
<li><p><strong>分析阅读 (Analytical Reading)</strong></p>
<ul>
<li><strong>无限时间内</strong>最好最完整的阅读</li>
<li><strong>追寻理解</strong></li>
</ul></li>
<li><p><strong>主题阅读 (Syntopical Reading or Comparative
Reading)</strong></p>
<ul>
<li>阅读多本书，列举相关处，提出共同主题</li>
<li>也许会架构一个从未提出的主题分析</li>
</ul></li>
</ul>
<h3 id="第三章-基础阅读">第三章 基础阅读</h3>
<p>无</p>
<h3 id="第四章-检视阅读">第四章 检视阅读</h3>
<h4 id="有系统的略读或粗读">有系统的略读或粗读</h4>
<blockquote>
<p>发现这本书值不值得多花时间仔细阅读，就算决定不再多花时间，略读也能告诉你许多与这本书有关的事</p>
</blockquote>
<ul>
<li>先看书名页，然后，有序先看序
<ul>
<li>特别注意副标题</li>
<li>注意相关说明、本书的特殊角度</li>
<li>与先前的书归类</li>
</ul></li>
<li>研究目录页</li>
<li>检阅索引
<ul>
<li>评估本书涵盖的议题范围</li>
<li>所提到的书籍种类与作者</li>
<li><strong>提取重要词汇</strong>并根据此翻阅内文</li>
</ul></li>
<li>出版者的介绍
<ul>
<li>一般是作者亲自写的</li>
</ul></li>
<li>挑几个和主题息息相关的篇章看看</li>
<li>随便翻翻看看
<ul>
<li>翻过全书，留意主要论点和主题脉动</li>
<li><strong>不要忽略最后的两三页</strong></li>
</ul></li>
</ul>
<h4 id="粗浅的阅读">粗浅的阅读</h4>
<p><strong>重要的阅读规则：头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不要停下来查询或思索</strong></p>
<p>即，只注意你能理解的部分，不要为一些没法立即了解的东西而停顿</p>
<p>就算不重读，对一本难度很高的书了解了一半，也比什么都不了解要好。如果一碰到困难就停住，最后可能就真的对这本书一无所知了</p>
<h4 id="阅读的速度">阅读的速度</h4>
<p>检视阅读的两个方式都需要快速的阅读</p>
<p>当然，理想的阅读速度应该是能够用<strong>恰当的速度读对应的书</strong></p>
<h4 id="逗留与倒退">逗留与倒退</h4>
<p>眼部的逗留和倒退是坏习惯，但是很容易矫正</p>
<h3 id="第五章-如何做一个自我要求的读者">第五章
如何做一个自我要求的读者</h3>
<h4
id="主动的阅读基础一个阅读者要提出的四个基本问题">主动的阅读基础：一个阅读者要提出的四个基本问题</h4>
<ul>
<li>这本书整体上在谈些什么</li>
<li>作者细处说了什么，怎么说的</li>
<li>这本书说的有道理吗？是全部有道理还是部分有道理</li>
<li>这本书跟你有什么关系
<ul>
<li>本书给你的资讯有什么意义</li>
<li>为什么作者认为这件事重要</li>
<li>你真的有必要了解这些资讯吗</li>
</ul></li>
</ul>
<h4 id="如何让一本书真正属于你自己">如何让一本书真正属于你自己</h4>
<p><strong>读出言外之意，写出言外之意</strong></p>
<p>做笔记的重要性</p>
<ul>
<li>保持清醒</li>
<li>用言语理顺自己的思考</li>
<li>帮你记住作者的思想</li>
</ul>
<p>做笔记的方法</p>
<ul>
<li>画底线</li>
<li>双下划线，或其他记号加重整个段落</li>
<li>慎用星号，仅用于本书最重要的十几个声明或段落</li>
<li>顺序编号</li>
<li>空白处记下其他的页码，集中全书的想法
<ul>
<li>Cf，表示比较或参照</li>
</ul></li>
<li>圈出关键字或句子</li>
<li>在书的空白处做笔记
<ul>
<li>记录问题或答案</li>
<li>简化复杂的论点</li>
<li>最后一页可以用于做索引页，标注重要观点</li>
<li>在书的前空白页写下书的大纲</li>
</ul></li>
</ul>
<h4 id="三种做笔记的方法">三种做笔记的方法</h4>
<ul>
<li>检视阅读——<strong>结构笔记 (structural note-making)</strong>
<ul>
<li>这是怎么样的一本书？</li>
<li>整本书在谈的是什么？</li>
<li>作者是借着怎样的整体架构，来发展他的观点或陈述他对这个主题的理解？</li>
<li>目录页或书名页</li>
<li>重点是全书的架构而非内容（至少不是细节）</li>
</ul></li>
<li>主题阅读——<strong>概念笔记 (conceptual note-making)</strong>
<ul>
<li>与作者的观点有关</li>
</ul></li>
<li>主题阅读——<strong>辩证笔记 (dialectical note-making)</strong></li>
</ul>
<h4 id="培养阅读的习惯">培养阅读的习惯</h4>
<blockquote>
<p>习惯是第二天性</p>
</blockquote>
<p><strong>艺术或技巧只属于养成习惯并且能按照规则运作的人</strong></p>
<h4 id="由许多规则中养成一个习惯">由许多规则中养成一个习惯</h4>
<p><strong>为了忘掉单一的动作，一开始必须学会每一个单一的动作</strong>，这是学习复杂技巧的基本知识</p>
<h2 id="第二篇-阅读的第三个层次分析阅读">第二篇
阅读的第三个层次：分析阅读</h2>
<p><strong>规则一</strong>：一定要知道自己在读的是哪一类书，越早越好，最好在开始阅读之前就知道</p>
<h3 id="第六章-一本书的分类">第六章 一本书的分类</h3>
<h4 id="从一本书的书名中你能学到什么">从一本书的书名中你能学到什么</h4>
<p>将书籍分到某一个种类，并且知道这个种类的书在谈什么</p>
<h4 id="实用性-vs.-理论性作品">实用性 vs. 理论性作品</h4>
<p>分别教授知与行</p>
<p>实用性的书常常出现“应该应当”“好坏”“结果意义”之类的字眼</p>
<p>理论性的书常常说“是”</p>
<h4 id="理论性作品的分类">理论性作品的分类</h4>
<p>历史：发生在过去的事</p>
<p>科学：在意定律或通则，<strong>会超越一般人的生活经验</strong></p>
<p>哲学：追求一般真理，但是提出的问题和解决问题的方法和科学不同，<strong>不会超过一般人的生活经验</strong></p>
<h3 id="第七章-透视一本书">第七章 透视一本书</h3>
<p><strong>规则二</strong>：使用一个单一的句子或最多几句话（一小段文字）来叙述整本书的内容</p>
<p>唯一的检验标准：用几句话告诉自己或者别人这本书的内容。不要满足于“感觉上的整体”而说不出口</p>
<p><strong>规则三</strong>：将书中重要篇章列举出来，说明它们如何按照顺序组成整体架构</p>
<h4 id="结构与规划叙述整本书的大意">结构与规划：叙述整本书的大意</h4>
<p>如果作者提供帮助，不要太骄傲而拒绝；但是也不要完全相信</p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>S5</category>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>「Toolkit」 Everything</title>
    <url>/everything/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>Everything 的使用小技巧</p>
</blockquote>
<span id="more"></span>
<h2 id="多关键字">多关键字</h2>
<p>用空格分开</p>
<blockquote>
<p>表示真正的空格和 Shell 中的常用方法一样，用英文半角引号包裹，如
<code>"Program Files"</code></p>
</blockquote>
<h2 id="相或关键字">相或关键字</h2>
<p><code>免费|freeware</code>，可以连续使用</p>
<h2 id="取反关键字">取反关键字</h2>
<p>搜索所有包含 abc 但不包含 123 的文件：<code>abc !123</code></p>
<h2 id="文件大小">文件大小</h2>
<p>大于 300MB 的 rar 压缩文件：<code>*.rar size:&gt;300MB</code></p>
<p>大小 1M 至 5M 的文件：<code>size:1MB-5MB</code></p>
<p>大小为 1024 字节：<code>size:1024</code></p>
<h2 id="指定目录">指定目录</h2>
<p><code>Path target</code></p>
<h2 id="指定盘符">指定盘符</h2>
<h2 id="文件内容">文件内容</h2>
<p><code>content:tips</code></p>
<h2 id="指定目录-1">指定目录</h2>
<p><code>D:\我的文件夹名\ *.p??</code>，在D:pdf 文件，ppt 文件等，但不含
pptx 文件。</p>
<h2 id="指定文件">指定文件</h2>
<p><code>file:*.png</code></p>
<h2 id="扩展名">扩展名</h2>
<p><code>C: ext:png;gif;jpg</code></p>
<h2 id="最近更改">最近更改</h2>
<p><code>rc:2021/09/03 rc:today rc:yesterday rc:last2hours rc:last10mins</code></p>
<h2 id="日期">日期</h2>
<p><code>dateaccessed:&lt;date&gt;</code> 或
<code>da:&lt;date&gt;</code></p>
<p><code>dateaccessed:&lt;date&gt;</code> 或
<code>da:&lt;date&gt;</code></p>
<p><code>datemodified:&lt;date&gt;</code> 或
<code>dm:&lt;date&gt;</code></p>
<p><code>daterun:&lt;date&gt;</code> 或 <code>dr:&lt;date&gt;</code></p>
<h2 id="重复文件">重复文件</h2>
<p><code>ext:jpg dupe: sizedupe: size:&gt;300kb</code></p>
<h2 id="反向搜索">反向搜索</h2>
<p><code>D:\我的文件 *.xls !\生活文件夹 !~</code></p>
]]></content>
      <categories>
        <category>Toolkit</category>
        <category>Everything</category>
        <category>S6</category>
      </categories>
      <tags>
        <tag>Toolkit</tag>
        <tag>Everything</tag>
      </tags>
  </entry>
  <entry>
    <title>时钟参与组合逻辑的心得</title>
    <url>/combinational-logic-concerning-clock/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="写在前面">写在前面</h2>
<blockquote>
<p>计组组合逻辑的一点小小的思考与整理</p>
</blockquote>
<span id="more"></span>
<p>关于clock参与逻辑运算的问题，黑书英文版第二版（《Degital design and
computer architecture》(2nd Edition) ）中 P116
已有对此问题的阐释，摘录如下：</p>
<blockquote>
<p>Generally, performing logic on the clock is a <strong>BAD
IDEA</strong>. Clock gating delays the clock and can cause timing
errors, as we will see in Section 3.5.3, so do it only if you are sure
you know what you are doing.</p>
</blockquote>
<p>这种时钟偏移 <code>timing error</code>
简言之是<strong>时钟不同时到达各个寄存器</strong>。时钟偏移也显著地增加了建立时间
<span class="math display">\[t_{setup}\]</span> 和保持时间 <span
class="math display">\[t_{hold}\]</span>
及时序总开销，减少了组合逻辑的有效工作时间，增加了通过组合逻辑所需要的最小延迟。（证明可参见黑书中文版
P87 或黑书英文版
P148）从而，部分器件在一定条件下会不满足时钟约束。太多的时钟偏移还会导致严重的保持时间错误，有时还需要将触发器设置为特别慢来防止相关问题。这会使得时序分析的最坏情况变糟，<strong>影响电路的适用性</strong>。</p>
<p>那么怎么叫<code>you are sure you know what you are doing?</code></p>
<p>我个人认为比如在普通的D触发器的实现中，需要用反相时钟组，<strong>确实没有其他好的办法时</strong>才会使时钟参与逻辑运算。实现带使能的D触发器时确实有两种方法，但是<strong>有时钟不参与逻辑运算的方法，就没必要采用另一种</strong>。甚至高老板的PPT里没有提到这一种内部电路。</p>
<figure>
<img src="C:\Users\Lee\Desktop\internal-copy.png" alt="internal" />
<figcaption aria-hidden="true">internal</figcaption>
</figure>
<p><del>更优质的解答：我也没法保证</del></p>
<p>所以能有严谨的方法，就不必冒险而产生可能的冒险（）</p>
<hr />
<p><strong>省流</strong>：clock参与运算会使电路变差，<strong>尽量避免时钟参与逻辑运算</strong>。</p>
<hr />
<p>最后，希望大家能从讨论区中相互借鉴，相互帮助，共同学习~</p>
]]></content>
      <categories>
        <category>CO</category>
        <category>S3</category>
      </categories>
      <tags>
        <tag>CO</tag>
      </tags>
  </entry>
  <entry>
    <title>科目三实战技巧</title>
    <url>/subject3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言">前言</h2>
<blockquote>
<p>笔者与科三的爱恨情仇</p>
</blockquote>
<span id="more"></span>
<p>笔者去年没有练完的科三拖到了今年来练...在模拟了两次破费一百大洋后终于掌握要诀，肉疼的笔者心里那个不服，用键盘<del>讨伐</del>记录如下</p>
<h3 id="上车准备">上车准备</h3>
<blockquote>
<p>先上车进行身份验证，直到听到“请进行下车准备”时，观察左后视镜，扭头观察左后方无车后打开车门下车。逆时针绕车，在距离每个感应点20-30cm处交叉手臂几次，隐约听到车内“正在经过车尾”。绕车结束后上车，检查远光灯复位，挡位处在空挡，手刹拉起。调整座椅，系好安全带。</p>
</blockquote>
<h3 id="灯光">灯光</h3>
<blockquote>
<p>听到“请启动发动机”口令后，踩住离合器一次性把火打着，（随机考五个灯光）</p>
</blockquote>
<h3 id="起步">起步</h3>
<blockquote>
<p>听到“关闭灯光请起步”语音，打左转向灯，按喇叭两次，挂一档松手刹，左右观察驶入第二车道。加油门挂二档</p>
</blockquote>
<h3 id="行驶中">行驶中</h3>
<blockquote>
<p>行驶中第一个项目<strong>通过学校</strong>，无语音播报。观察左内右后视镜轻点刹车，需要注意，轻点刹车要使车有<strong>顿挫感</strong>。</p>
<p>第二个项目<strong>通过公交车站</strong>，无语音播报。观察左内右后视镜轻点刹车。</p>
<p>第三个项目<strong>直线行驶</strong>，听到“直线行驶”语音后，车在车道中间正负15cm，方向盘角度不超过15度，行驶一百米。</p>
<p>第四个项目<strong>前方路口左转</strong>，听到“前方路口左转”语音后，踩一次<strong>刹车</strong>，打<strong>左转向灯</strong>，观察左内右后视镜<strong>轻点刹车</strong>，注意观察路口情况，注意避让对侧直行社会车辆，<strong>避免斑马线停车</strong>。保险起见在路口斑马线前再踩一次<strong>刹车</strong>。</p>
<p>第五个项目<strong>加减挡</strong>，无语音播报。车速15迈左右挂二挡，25迈左右挂三挡，35迈左右挂四挡，踩油门保持车速35迈，默念6-7个数（5s）。松开油门回三挡，轻踩刹车，25迈以下回二挡。注意<strong>不要越级挂挡</strong>。</p>
<p>第六个项目<strong>前方路口直行</strong>，听到“前方路口直行”语音后，观察左内右后视镜<strong>轻点刹车</strong>。</p>
<p>第七个项目<strong>会车</strong>，听到前方会车语音以后，观察左内右后视镜<strong>轻点刹车。</strong></p>
<p>第八个项目<strong>掉头</strong>，听到“前方请找合适地点掉头”语音后，变更至最左侧车道，<strong>打左转向灯</strong>，快掉头时换一挡，在掉头前刹车一次，刷新一挡行驶距离（一挡连续行驶不能超过50m）。左打死观察左右情况掉头。</p>
<p>第九个项目<strong>变更车道</strong>，听到“变更车道”语音后，打右转向灯，看右后视镜并扭头观察右后方，往右打方向盘变道。</p>
<p>第十个项目<strong>前方路口右转</strong>，听到“前方路口右转”语音后，踩一次<strong>刹车</strong>，打<strong>右转向灯</strong>，观察左内右后视镜<strong>轻点刹车</strong>，注意观察路口情况，<strong>避免斑马线停车</strong>。保险起见在路口斑马线前再踩一次<strong>刹车</strong>。</p>
<p>第十一个项目<strong>超越前方车辆</strong>，听到“超越前方车辆语音”后，<strong>打左转向灯</strong>，看左后视镜并扭头观察左后方，往左变道，行驶四十米（约7-8条白线），看右后视镜并扭头观察右后方，变道驶回原车道。</p>
<p>第十二个项目<strong>通过人行横道</strong>，观察左内右观察后视镜<strong>轻点刹车</strong>。</p>
<p>第十三个项目<strong>靠边停车</strong>，听到“前方请找合适路段靠边停车”语音后，<strong>打右转向灯</strong>，看右后视镜并扭头观察右后方变道。挂一档靠边慢溜，车身与边线不能超过30cm（约一条半白线宽）。注意看前方将车顺正再看后视镜确认距离。如需调整应先顺正再微调。即使已发出“操作完毕请下车”语音仍可继续微调。确认可以以后，拉起手刹，摘空挡，熄火。踩住离合和刹车，确认上述三项复位。松安全带，松离合，松脚刹，观察左内右后视镜和左扭头观察左后方，确认安全后开关车门但不下车，开关车门的时间不能超过15秒。听到语音播报成绩，考试结束。</p>
</blockquote>
]]></content>
      <categories>
        <category>生活记录</category>
        <category>S3 Winter</category>
      </categories>
      <tags>
        <tag>科目三</tag>
      </tags>
  </entry>
  <entry>
    <title>浙大翁恺OO</title>
    <url>/WK-OO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言">前言</h2>
<blockquote>
<p><em>Not finished</em></p>
<p>浙大翁恺老师的 OO 入门课</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p><em>Refs</em>：翁恺 &amp; 黑马程序员</p>
</blockquote>
<h2 id="第一周-类与对象">第一周 类与对象</h2>
<h3 id="用类制造对象">用类制造对象</h3>
<p>前置知识：对象变量是对象的管理者而非所有者，所以涉及到赋值、函数参数传递和比较（如果两个对象变量相等说明管理的是同一内容，判断管理内容是否相同应用<code>equal</code>判断）都与普通变量有所不同。</p>
<p>现在，我们要来尝试自己定义类，然后用自己定义的类来创建对象</p>
<h3 id="定义类">定义类</h3>
<p>观察这类事物的特点，用一些成员和函数表示这个类</p>
<ul>
<li>private是对类而非对象，所以同一类的不同对象之间可以访问彼此的成员</li>
<li>如果不声明默认friendly，可以在同一个包的文件下共用</li>
<li>protected见继承中的project</li>
</ul>
<h3 id="成员变量和成员函数">成员变量和成员函数</h3>
<p><code>this</code> 这个特殊的本地变量起着至关重要的作用</p>
<ul>
<li>注意：如果成员函数的参数与成员变量同名，那么会取作用域更小的，也即取参数作为这个变量名对应的变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">New</span> &#123;</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">int</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员函数内部调用其他成员函数也可不加<code>this.</code></p>
<p>区别于定义在函数内部的本地变量，成员变量的生存期是对象的生存期，作用域是类内部的成员函数（也即类内的成员函数可以使用成员变量，成员变量初始化...）</p>
<h3 id="对象初始化">对象初始化</h3>
<p>成员变量在对象初始化时，如果未赋值，会安排一个初始值，当然也可以手动初始化（手动直接赋值、调用函数赋值）</p>
<table>
<thead>
<tr class="header">
<th>变量类型</th>
<th>初始值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>boolean</td>
<td>false</td>
</tr>
<tr class="even">
<td>int</td>
<td>0</td>
</tr>
<tr class="odd">
<td>object（某个对象）</td>
<td>null</td>
</tr>
</tbody>
</table>
<p>构造函数（课上讲过不少了，我摸了（bushi））</p>
<h2 id="第二周-对象交互">第二周 对象交互</h2>
<h3 id="对象的识别">对象的识别</h3>
<p>感觉和定义类是一回事，两件事情可以在定义类的时候同时完成。</p>
<h3 id="对象的交互">对象的交互</h3>
<p>课上讲过一嘴，说到可以用static修饰的“类全局变量”</p>
<p>也可以通过将一个类的成员变量设置为其他类的对象来达到目的</p>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220913223756886.png"
alt="image-20220913223756886" />
<figcaption aria-hidden="true">image-20220913223756886</figcaption>
</figure>
<p><strong>图1 以钟表为例来看对象的交互</strong></p>
<h3 id="访问属性">访问属性</h3>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220913223824851.png" alt="image-20220913223824851" style="zoom: 33%;" /></p>
<p>图2 用鸡蛋图表示封装思想</p>
<p><strong>封装思想</strong>：把数据和对数据的操作放在一起</p>
<p>public：同一个编译单元（一个java文件）里只能有一个class为public，且public
class的名字必须与编译单元同名</p>
<p>如果不加public，则不能在这个package外面访问</p>
<p>一个编译单元最多有一个public class，但也可以一个都没有</p>
<p>文件结构：clock(project)-&gt;src-&gt;clock(package)-&gt;clock.java</p>
<p><strong>import</strong>：用到的类不在同一个package里，就需要import</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> display.Display</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure>
<p>包的名字.包的类</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20220911164023484.png"
alt="image-20220911164023484" />
<figcaption aria-hidden="true">image-20220911164023484</figcaption>
</figure>
<p>如果不用import，也可以像这样给出全名</p>
<p>也可以万能import（引用display所有内容，但是可能冲突，推荐import具体的类）</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20220911164335992.png"
alt="image-20220911164335992" />
<figcaption aria-hidden="true">image-20220911164335992</figcaption>
</figure>
<p>包的名字里面的点实际上表达文件夹层次</p>
<p>Java通过这样的手段管理文件系统（</p>
<p><strong>static：类变量</strong>，不属于任何一个对象，属于这个类，任何一个对象都拥有这个变量，但是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrong usage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        value++; <span class="comment">// cannot compile</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static函数只能调用static函数，只能访问static成员变量（这回理解了）</p>
<p>static函数和变量可以通过类访问，也可以通过对象访问，只是不能获得对象的具体信息</p>
<p>static变量的初始化只执行一次，和对象的创建过程无关</p>
<p>这就不得不提static的四种用法了（课上讲过，我摸了，略记一下）</p>
<h2 id="第三周-对象容器">第三周 对象容器</h2>
<h3 id="记事本的例子">记事本的例子</h3>
<ul>
<li>确定功能</li>
<li>接口设计</li>
</ul>
<p>每一个类都写main，方便做调试</p>
<h3 id="泛型容器">泛型容器</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; notes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">// ArrayList of String，用来存放String的ArrayList</span></span><br></pre></td></tr></table></figure>
<p>ArrayList是一个类，notes本身是对象管理者</p>
<p>容器类型、元素类型</p>
<ul>
<li>对象数组中的每个元素都是对象的管理者而非对象本身</li>
</ul>
<p>set：set相当于数学中的集合，元素不重复，且没有排序的概念</p>
<p>toString函数直接输出这个对象，会输出toString()函数返回的字符串结果</p>
<p>可以先写一个“空”的返回值，比如返回int类型的，先写个return
0，后面再改；</p>
<p>返回String的先写个return "";</p>
<p>HashMap：想写出“聪明”的代码，和具体数据无关</p>
<p>容器里的类型必须是对象，不能是基本元素，所以需要Integer这样的包裹类型</p>
<p>包裹类型的变量可以直接接受所对应的基础类型变量</p>
<p>所以HashMap的返回值也是对象，就是一个管理者</p>
<p>如果存在会返回有效值，不存在返回null</p>
<p>key唯一，后面的会覆盖前面的</p>
<p>遍历没有特别简单的方法，<strong>可以考虑采取for-each遍历entrySet或者valueSet的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integet k : name.keySet()) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> name.get(k);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要写构造器constructor</p>
<h2 id="第四周-继承与多态">第四周 继承与多态</h2>
<blockquote>
<p>一周后看：当时看觉得难是正常的，因为现在也觉得难（）</p>
</blockquote>
<p><strong>继承得到了父类的所有东西</strong>，item里面的所有都得到了，都是<strong>可能</strong>可以用的（至于为什么是可能，会涉及<strong>访问权限</strong>的问题，我们后面说）</p>
<p>如果不在子类里定义title，那么就会报“The field Item.title is not
visible”（此时没有super()）</p>
<p><strong>父类的private成员真的只有父类自己才能用</strong></p>
<p>虽然继承给了子类，但是子类不能直接用</p>
<p>本来我们应该做的事情是让Item给Item的title赋值，所以应该由Item来做初始化</p>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220914222324033.png"
alt="image-20220914222324033" />
<figcaption aria-hidden="true">image-20220914222324033</figcaption>
</figure>
<p>可以看到，虽然CD没有private的title，但是确实产生了title</p>
<ul>
<li>第一个解决方案：把标识符改成protected（自己可以访问，同一个包内的其他类可以访问，子类可以访问）<strong>这是一种没办法的办法</strong></li>
</ul>
<p>对item做一个constructor</p>
<ul>
<li>cd的构造器得拿到title，用<code>super(title);</code>把参数传给父类，父类构造器通过参数构造；</li>
<li>如果用<code>super()</code>，找不到这个没有参数的构造器</li>
<li>如果不通过<code>super()</code>传递参数，父类会用不带参数的构造器进行构造</li>
</ul>
<blockquote>
<p>因为</p>
</blockquote>
<ul>
<li>先做了父类的初始化（定义初始化和构造器），然后才来做子类自己定义的初始化（我理解这样方便覆盖），再进构造函数做其他事情</li>
<li>需要保证父类的成员变量得到恰当的初始化——定义初始化、构造器（原来在二者兼备时优先定义初始化，然后构造器），总体的顺序是父类-&gt;子类，也即父类定义初始化、构造器-&gt;子类初始化、构造器，与是否采用super()传递参数无关</li>
<li>同时存在两个成员，也是可以的，父类的被隐藏
<ul>
<li>计算机的基本原则：优先选择范围小的，也即title应该是DVD自己的title</li>
<li>回到父类对父类成员变量操作时，操作的是父类自己的成员变量</li>
</ul></li>
<li>总结一下
<ul>
<li>父类的所有内容都继承给子类
<ul>
<li>但是如果是private的，子类不能访问</li>
<li>在谁的函数里面，所指的成员变量就是谁的
<ul>
<li>子类父类出现同名成员变量，在子类里面的就是子类自己的，在父类里面的就是父类自己的，之间没有任何联系</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><strong>要用父类的print()，需要加一个super</strong>，比如下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;DVD:&quot;</span>);</span><br><span class="line">    <span class="built_in">super</span>.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类定义了类型</p>
<p>子类定义了子类型</p>
<p>子类的对象可以被当作父类的对象来使用</p>
<ul>
<li>赋值给父类的对象</li>
<li>传递给需要父类对象的函数</li>
<li>放进存放父类对象的容器里</li>
</ul>
<p>成员函数的绑定都是动态绑定</p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912171422963.png" alt="image-20220912171422963" style="zoom:50%;" /></p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912172044907.png" alt="image-20220912172044907" style="zoom:50%;" /></p>
<p>记得这里有一个强制类型转换</p>
<p>以及函数声明必须完全相同（函数名、参数表）</p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912173013633.png" alt="image-20220912173013633" style="zoom:50%;" /></p>
<p>可扩展性：不需要修改就能添加新的内容</p>
<p>可维护性：需要修改才能添加新的内容</p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912173133898.png" alt="image-20220912173133898" style="zoom:50%;" /></p>
<h2 id="第五周-设计原则">第五周 设计原则</h2>
<p>城堡游戏</p>
<p>open declaration：进入对应的声明</p>
<p>String类的操作系统开销大，可以用StringBuffer类</p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912174838925.png" alt="image-20220912174838925" style="zoom:50%;" /></p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912175117169.png" alt="image-20220912175117169" style="zoom:33%;" /></p>
<p>可扩展性：用HashMap避免“硬编码”（即不需要写出每一对对应的具体键值和值，只需要每次扩展时添加新的即可）</p>
<h2 id="第六周-抽象与接口">第六周 抽象与接口</h2>
<h3 id="抽象">6.1 抽象</h3>
<p><strong>抽象就是为了防止被制造实体</strong></p>
<p>抽象类的作用仅仅是表达接口，而不是具体的实现细节。抽象类中可以存在抽象方法。抽象方法也是使用abstract关键字来修饰。抽象的方法是不完全的，它只是一个<strong>方法签名</strong>而完全没有方法体</p>
<p>但是为了表达类之间的关系，还需要这样一个类来表达。如第一章的例子，如果去掉
<code>Shape</code> 类，那么 <code>Circle</code> 和
<code>Rectangle</code> 类就没有关系了</p>
<p>抽象函数<strong>（不能有括号）</strong>：表达概念而无法实现具体代码的函数，目的是为了告诉子类需要写
<code>draw()</code> 方法</p>
<p>只要有一个函数是抽象的，类就是抽象的。（这很容易理解，否则便无法调用这个抽象方法）</p>
<ul>
<li>有抽象类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Graphics g)</span>;</span><br><span class="line"><span class="comment">// 注意不能有大括号，即不能定义函数体</span></span><br></pre></td></tr></table></figure>
<p>抽象类<strong>（不能产生对象，但是可以定义变量）</strong>：表达概念而无法构造出实体的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Shape</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(a, b);</span><br></pre></td></tr></table></figure>
<ul>
<li>任何继承了抽象类的非抽象子类的对象可以赋值给这个变量（也即任何Shape类子类的对象都可以由s来管理）</li>
</ul>
<p>实现抽象函数</p>
<ul>
<li>继承自抽象类的子类必须覆盖父类中的抽象函数，这种覆盖叫做<strong>实现</strong></li>
<li>否则这个类自己就会成为抽象类</li>
</ul>
<p>计算机中的两种抽象</p>
<ul>
<li>与具体相对
<ul>
<li>表达一种概念而非实体</li>
</ul></li>
<li>与细节相对
<ul>
<li>表示在一定程度上忽略细节而着眼大局</li>
</ul></li>
</ul>
<h3 id="数据与表现分离">6.2 数据与表现分离</h3>
<p>两种看程序的方法：</p>
<ul>
<li>看main函数，挨个展开需要看的子类代码（”自顶向下“方法）</li>
<li>看最小的类，追到父类，从看懂小部件开始看懂整个代码（”自底向上“方法，联想HuffmanCode）</li>
</ul>
<p>JFrame、View（窗口）</p>
<p><del>重绘这个图工作量太大了，先摸为敬</del></p>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220912194352676.png"
alt="image-20220912194352676" />
<figcaption aria-hidden="true">image-20220912194352676</figcaption>
</figure>
<p>数据与表现分离</p>
<ul>
<li>程序的业务逻辑与表现无关
<ul>
<li>表现可以是图形的也可以是文本的</li>
<li>表现可以是当地的也可以是远程的</li>
</ul></li>
</ul>
<p>（强调了一种“各司其职”的思想，写业务逻辑的程序员不需要关心表现是怎样的，不需要关心是通过网页输入字符串还是控制台输入还是blabla）</p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912194831143.png" alt="image-20220912194831143" style="zoom:33%;" /></p>
<p>责任驱动设计</p>
<ul>
<li>将程序要实现的功能分配到合适的类/对象中去</li>
</ul>
<p>网格化</p>
<ul>
<li>图形界面本身有更高的清晰度</li>
<li>但是将画面网格化后数据更易处理</li>
</ul>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912195010980.png" alt="image-20220912195010980" style="zoom: 25%;" /></p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912195043598.png" alt="image-20220912195043598" style="zoom:25%;" /></p>
<p>除了C++都不支持多继承<del>（那为啥不用C++）</del></p>
<blockquote>
<p>9.20更新：Java可以通过接口实现多继承</p>
</blockquote>
<p><strong>接口</strong></p>
<ul>
<li><strong>接口是纯抽象类</strong>
<ul>
<li><strong>所有的成员函数都是抽象函数</strong></li>
<li><strong>所有的成员变量都是public static
final（常量）</strong>，static方便调用，接口名.函数名即可调用</li>
<li>无构造方法</li>
<li>成员变量：
<ul>
<li>JDK7：接口中只能有抽象方法</li>
<li>JDK8：接口中可以定义有方法体的方法</li>
<li>JDK9：接口中可以定义私有方法</li>
</ul></li>
</ul></li>
<li>接口规定了长什么样，但是不管里面有什么</li>
</ul>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220912220141030.png"
alt="image-20220912220141030" />
<figcaption aria-hidden="true">image-20220912220141030</figcaption>
</figure>
<p><code>cell o</code>的意思是任何实现了cell接口的都可以交给这个变量</p>
<p>interface是一种特殊的class，<strong>和class的地位是一样的</strong>，原来用class的地方都可以用interface</p>
<p>实现接口</p>
<ul>
<li>类用<code>extends</code>，接口用<code>complements</code></li>
<li>类可以实现很多接口</li>
<li>接口可以继承接口，但不能继承类</li>
<li>接口不能实现接口</li>
</ul>
<p>讲的就是两个东西之间的链接</p>
<p>需要其他服务的时候，不是定义一个类，而是定义一个接口</p>
<p>cell是view和field定义的</p>
<p><strong>面向接口的编程方式</strong></p>
<ul>
<li>设计程序时先定义接口，再实现类</li>
<li>任何需要在函数间传入传出的一定是接口而不是具体的类</li>
<li>是Java成功的关键之一，因为极适合多人同时写一个大程序</li>
<li>也是Java被批评的要点之一，因为代码量膨胀起来很快</li>
</ul>
<blockquote>
<p><em>补充自黑马程序员</em></p>
</blockquote>
<p>抽象类：更多地用作父类，是对事物的抽象</p>
<p>抽取共性方法作为抽象方法，抽象方法所在的类便成为抽象类</p>
<p>接口：更多地侧重于规则，是对行为的抽象（如游泳接口，可由动物和人实现）</p>
<p>接口的子类也称作实现类</p>
<ul>
<li>要么重写接口中所有的抽象方法</li>
<li>要么也是抽象类</li>
</ul>
<p>可以多实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subclass</span> <span class="keyword">implements</span> <span class="title class_">Class1</span>, Class2 &#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以我感觉多接口继承也是用接口的重要原因之一</p>
</blockquote>
<p>接口和类之间的关系</p>
<ul>
<li>类和类的关系
<ul>
<li>继承关系，只能单继承，不能多继承，但是可以多重继承</li>
</ul></li>
<li>类和接口的关系
<ul>
<li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口
<ul>
<li>实现多个接口需要重写<strong>全部的</strong>抽象方法</li>
<li>同名的话就是实现了不同接口的同名函数</li>
</ul></li>
</ul></li>
<li>接口和接口的关系
<ul>
<li>继承关系，可以单继承，也可以多继承
<ul>
<li>实现最下面的子接口的话，需要重写所有的抽象方法</li>
</ul></li>
</ul></li>
</ul>
<h2 id="第七周-控制反转与mvc模式">第七周 控制反转与MVC模式</h2>
<h3 id="布局管理器">7.1 布局管理器</h3>
<p>Swing：所有的东西都叫做部件、另外一种东西叫做容器</p>
<p>容器可以加到容器里，部件也需要加到容器里</p>
<p>容器管部件在哪里，显示多大</p>
<p>布局管理器</p>
<p>layout manager</p>
<p>frame默认的layout manager是border</p>
<p>这章似乎和图形可视化等等关系比较大，所以我摸了（）</p>
<h2 id="第八周-异常处理与输入输出">第八周 异常处理与输入输出</h2>
<h3 id="捕捉异常">8.1.1 捕捉异常</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    idx = in.nextInt();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        a[idx] = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Caught&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入5，输出Hello</span></span><br><span class="line"><span class="comment">// 输入10，输出Caught</span></span><br><span class="line"><span class="comment">// 说明第6行没做，从第6行跳到了第9行</span></span><br></pre></td></tr></table></figure>
<h3 id="异常处理机制">8.1.2 异常处理机制</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIndex</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        a[<span class="number">10</span>] = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            k();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;caught&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>a[10] = 10</code>
出了异常，之后的hello不会执行，离开f回到调用的地方<img
src="D:\Working\MarkDownFiles\exception-execution.png" /></p>
<h3 id="捕捉到的异常">8.1.3 捕捉到的异常</h3>
<p>捉到了做什么</p>
<p><code>String getMessage()</code></p>
<p><code>String toString()</code></p>
<p><code>void printStackTrace</code></p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">caught</span><br><span class="line">10</span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: 10</span><br></pre></td></tr></table></figure>
<p>再度抛出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">catch (Exception e) &#123;</span><br><span class="line">     System.err.println(&quot;An exception with thrown&quot;);</span><br><span class="line">     throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在这个层面上需要处理，但是不能做最终的决定</p>
<h3 id="异常">8.2.1 异常</h3>
<p>读文件的例子</p>
<p>bussiness logic业务逻辑</p>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220913194007073.png"
alt="image-20220913194007073" />
<figcaption aria-hidden="true">image-20220913194007073</figcaption>
</figure>
<p>如果某一步出了问题，就用catch解决问题</p>
<p>异常：不寻常的事情发生之时，需要终止预期的任务，让另一段代码处理</p>
<p>异常机制最大的好处就是清晰地分开了业务逻辑代码和遇到情况时的处理代码</p>
<p>异常声明</p>
<ul>
<li>如果你的函数可能抛出异常，就必须在函数头部加以声明<code>void f() throws TooBig, TooSmall, DivZero &#123; //... &#125;</code></li>
<li>可以声明并不会真正抛出的异常</li>
</ul>
<p>什么能扔？</p>
<ul>
<li>任何继承了Throwable类的对象</li>
<li>Exception类继承了Throwable</li>
<li>throw new Exception;</li>
<li>throw new Exception("Help");</li>
</ul>
<p>catch怎么匹配的异常</p>
<h3 id="流">8.3.1 流</h3>
<p>流是输入输出的方式</p>
<ul>
<li>流是一维单向的
<ul>
<li>一维：用一个数字就可以表达位置</li>
<li>单向：读 or 写</li>
</ul></li>
</ul>
<p>所有的IO操作都是有风险的</p>
<h2 id="tips">Tips</h2>
<h3 id="printf格式化输出">printf()格式化输出</h3>
<p>Java也支持<code>printf</code>格式化输出，格式与C语言相同</p>
<p>两个类里的<code>main函数</code>可以同时运行，当然还要看评测要求</p>
]]></content>
      <categories>
        <category>OO</category>
        <category>Notes</category>
        <category>S3</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>「Badminton」</title>
    <url>/badminton/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="羽毛球练习技巧">羽毛球练习技巧</h1>
<blockquote>
<p>记录一些一对一课程和网课的内容</p>
</blockquote>
<span id="more"></span>
<p>整体思路：单打练习一致性，双打求快</p>
<p>平时练习：跳绳是最练协调的，1min一组，练十组，隔天练</p>
<h2 id="正手后场动作">正手后场动作</h2>
<p>高远球、吊球、杀球的击球点依次向下</p>
<p>杀球需要打球头和球的靠近球头羽毛部分</p>
<p>发力的关键：手腕</p>
<p>手腕灵活可以用更小的动作打出更大的鞭打效果，方便做出更隐蔽的动作</p>
<h2 id="反手后场动作">反手后场动作</h2>
<p>相较于正手的高位击球点，反手的发力不能顺利传达，需要降低击球点获得引拍空间</p>
<p>步伐</p>
<p>具体的引拍方式为内收</p>
<h2 id="前场动作">前场动作</h2>
<p>记得弓步放着，脚的方向和前进方向一致</p>
<h2 id="接杀">接杀</h2>
<p>主要反手握拍动作，因为防守范围更大</p>
<p>球拍横在自己的身体面前，减少引拍时间，处于居中的位置</p>
<p>弹后场需要更靠前的位置，更快的挥速</p>
<p>手腕要立腕，抬大臂内收小臂手腕</p>
<p>重心随着身体顶起的动作做起伏</p>
<p>腋下反拍正打大概率只能抽到后场</p>
]]></content>
      <categories>
        <category>Play</category>
        <category>Badminton</category>
        <category>S6</category>
      </categories>
      <tags>
        <tag>Physical Training</tag>
        <tag>Badminton</tag>
      </tags>
  </entry>
  <entry>
    <title>《编译技术》笔记</title>
    <url>/compiling-technique-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="总述">总述</h2>
<blockquote>
<p>北航张莉《编译技术》笔记，看着玩玩</p>
</blockquote>
<span id="more"></span>
<h1 id="第一章-编译概述">第一章 编译概述</h1>
<h2 id="什么是程序设计语言">1.1 什么是程序设计语言</h2>
<p>人与计算机之间的中介，充当通信工具</p>
<h3 id="程序设计语言的定义方法">1.1.1 程序设计语言的定义方法</h3>
<p>对语言结构形式的描述：文法(grammar)或语法(syntax)</p>
<p>语言所表达内容的含义：语义</p>
<p><strong>本书采用属性文法。</strong>属性文法是一种半形式化的语义描述方法</p>
<h3 id="程序设计语言的处理系统">1.1.2 程序设计语言的处理系统</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428170824268.png"
alt="image-20230428170824268" />
<figcaption aria-hidden="true">image-20230428170824268</figcaption>
</figure>
<p>源程序(source program)、源语言(source language)、目标程序(object
program)或目标代码(object code)、目标语言(object language)</p>
<h3 id="编译程序和解释程序">1.1.3 编译程序和解释程序</h3>
<p>编译程序也可以输出介于低级语言和高级语言之间的某种中间语言(intermediate)</p>
<blockquote>
<p>中间程序可以理解为某种虚拟计算机的机器语言</p>
</blockquote>
<p>解释程序(interpreter)：能对编译得到的中间语言（甚至是源语言）进行解释执行的程序</p>
<blockquote>
<p>解释程序可以理解为这种虚拟计算机的模拟软件</p>
</blockquote>
<p>编译型语言运行时不需要重新翻译，执行效率高；但是依赖编译器，跨平台性差</p>
<p>常常用于开发操作系统、大型应用程序、数据库系统等</p>
<p>常见的编译型语言有 C/C++、Pascal/Object Pascal(Delphi)等</p>
<p>解释执行程序：需要对中间代码甚至源代码逐行解释，速度较慢，优点为：</p>
<ol type="1">
<li>可以运行时动态确定数据</li>
<li>中间代码的信息可以辅助调试</li>
<li>可以边修改边解释执行，缩短再次编译运行的时间</li>
<li>处理系统易开发</li>
<li>中间代码占用内存少</li>
<li>易于移植（中间语言的机器无关性）</li>
</ol>
<p><strong>T型图</strong></p>
<h2 id="与编译程序相关的处理系统">1.2 与编译程序相关的处理系统</h2>
<p><strong>1.各种翻译程序</strong></p>
<blockquote>
<p>翻译是广义的翻译，开阔下思路</p>
</blockquote>
<p><strong>2.预处理器</strong></p>
<p>把源程序变换为<strong>其它语言程序</strong>再进行编译。当然，与源程序的不对应性会导致程序调试困难</p>
<p><strong>3.宏处理器</strong></p>
<h2 id="编译程序和程序设计环境">1.3 编译程序和程序设计环境</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428171210972.png"
alt="image-20230428171210972" />
<figcaption aria-hidden="true">image-20230428171210972</figcaption>
</figure>
<h2 id="编译程序的构造">1.4 编译程序的构造</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428171300901.png"
alt="image-20230428171300901" />
<figcaption aria-hidden="true">image-20230428171300901</figcaption>
</figure>
<p><strong>1.词法分析</strong></p>
<p>是以识别单词为目标的简单的语法分析程序</p>
<p><code>token</code> 的种类：</p>
<ul>
<li>保留字或关键词，如
<code>begin</code>、<code>if</code>、<code>for</code></li>
<li>标识符</li>
<li>常量，包括浮点数、整数、各进制数、字符常量、字符串常量等</li>
<li>分界符和运算符</li>
</ul>
<p>空格和注释会被过滤</p>
<blockquote>
<p>可以用枚举类具体实现</p>
</blockquote>
<p><strong>2.语法分析</strong></p>
<p>根据语法规则将token组合成大的语法类或语法成分，如变量声明、表达式、语句、函数和过程等</p>
<p>输出：一棵语法分析树（简称语法树）</p>
<ul>
<li><p>叶结点：token</p></li>
<li><p>非叶结点：语法成分</p></li>
</ul>
<p><strong>3.语义分析</strong></p>
<p>确定源程序的意义</p>
<p>事实上还要同时进行语义检查，比如赋值类型不匹配等</p>
<p>语义动作还包括生成中间代码</p>
<p><strong>4.代码生成</strong></p>
<p>通常是将源程序的中间形式转换为汇编语言或者机器语言，可通过代码优化进一步优化</p>
<p><strong>5.代码优化</strong></p>
<p>机器无关的优化</p>
<ul>
<li><p>常数表达式的计算、应用操作符的性质（结合性、可交换性、分配性等）</p></li>
<li><p>多次出现的相同子表达式一次性计算、将循环内不变的语句移到循环外等</p></li>
</ul>
<p>机器有关的优化</p>
<ul>
<li>寄存器分配等</li>
</ul>
<p><strong>6.符号表管理</strong></p>
<p><strong>7.错误检测与处理</strong></p>
<p>以上是逻辑结构，实现时常常结合实现</p>
<p><strong>8.前端和后端(front end and back end)</strong></p>
<p>前端：与源语言有关而与目标机无关的部分（即分析部分）</p>
<ul>
<li>词法分析、语法分析</li>
<li>符号表建立</li>
<li>语义分析、中间代码生成</li>
<li>相应部分的错误处理和符号表操作</li>
<li>与机器无关的代码优化</li>
</ul>
<p>后端：与目标机有关的部分（即综合部分），与源语言无关而仅仅依赖于中间语言</p>
<ul>
<li>目标代码生成</li>
<li>相应部分的错误处理和符号表操作</li>
<li>与机器有关的代码优化</li>
</ul>
<p><strong>9.遍(pass)</strong></p>
<h2 id="编译技术在软件工程中的应用">1.5 编译技术在软件工程中的应用</h2>
<p>略，用处不大</p>
<h2 id="练习-1">练习 1</h2>
<p>基本是概念复述</p>
<h1 id="第二章-文法和语言的概念和表示">第二章
文法和语言的概念和表示</h1>
<h2 id="文法的非形式讨论">2.1 文法的非形式讨论</h2>
<p><strong>文法</strong>：形式上描述和规定语言结构的规则，也称语法</p>
<h3 id="语法树">2.1.1 语法树</h3>
<table>
<thead>
<tr class="header">
<th>语法树结点</th>
<th>语法</th>
<th>形式语言</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>带尖括号的结点</td>
<td>语法成分</td>
<td>非终结符号</td>
</tr>
<tr class="even">
<td>不带尖括号的结点</td>
<td>单词符号</td>
<td>终结符号</td>
</tr>
</tbody>
</table>
<h3 id="规则">2.1.2 规则</h3>
<h3 id="推导">2.1.3 推导</h3>
<p>通常把规则称为<strong>产生式</strong>，用符号 <code>:==</code> 或
<span class="math inline">\(\rightarrow\)</span> 表示</p>
<p>用符号 <span class="math inline">\(\Rightarrow\)</span> 表示推导</p>
<p>两个以上的语法成分同时存在时可任选其中之一并根据规则重复上述推导，直到推出句子</p>
<h3 id="练习-2-1">练习 2-1</h3>
<h2 id="符号符号串及其集合的运算">2.2 符号、符号串及其集合的运算</h2>
<p>任何一种语言都是由该语言的<strong>基本符号</strong>所组成的<strong>符号串集合</strong></p>
<h3 id="字母表和符号串">2.2.1 字母表和符号串</h3>
<p><strong>字母表</strong>：元素的<strong>非空有穷</strong>集合</p>
<p><strong>符号</strong>：字母表中的元素</p>
<p><strong>符号串</strong>：由字母表中的符号所组成的任何<strong>有穷</strong>序列</p>
<p><strong>空符号串 <span
class="math inline">\(\varepsilon\)</span></strong>
：不包含任何符号的符号串</p>
<p><strong>符号串的递归定义</strong>：</p>
<ul>
<li>$ $ 是 <span class="math inline">\(\Sigma\)</span> 上的符号串</li>
<li>若 $ x$ 是 <span class="math inline">\(\Sigma\)</span>
上的符号串，且 <span class="math inline">\(a \in \Sigma\)</span> ，则 $
xa $ 或 $ ax $ 是 <span class="math inline">\(\Sigma\)</span>
上的符号串</li>
<li>$ y $ 是 <span class="math inline">\(\Sigma\)</span>
上的符号串，当且仅当 <span class="math inline">\(y\)</span> 可由 ① 和 ②
产生</li>
</ul>
<blockquote>
<p>前后拼接</p>
</blockquote>
<p>通常用 <span class="math inline">\(a、b \dots\)</span> 和 <span
class="math inline">\(S、T、U \dots\)</span> 表示符号，用 <span
class="math inline">\(s、t、u\)</span> 表示符号串，用 <span
class="math inline">\(A、B、C、 \dots 、 R\)</span> 表示符号串集合</p>
<h3 id="符号串及其集合的运算">2.2.2 符号串及其集合的运算</h3>
<p><strong>符号串相等</strong>：各个符号依次相等</p>
<blockquote>
<p>符号串中符号的顺序很重要</p>
</blockquote>
<p><strong>符号串的运算</strong>：</p>
<ul>
<li><p>符号串长度：$ |x| $，数值上等于组成该符号串的符号个数</p></li>
<li><p>符号串连接：若 <span class="math inline">\(x\)</span> 和 $ y $
是两个符号串，其连接为 $ xy $ ，特殊地，有 $ x = x = x $</p></li>
<li><p>集合的乘积运算：符号串集合 $ A $ 和 $ B $ 的乘积 <span
class="math inline">\(AB = \{xy | x \in A, y \in B\}\)</span>
，特殊地，有 $ {} A = A {} = A $</p></li>
<li><p>符号串的幂运算：<img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428181309643.png" alt="image-20230428181309643" style="zoom:50%;" /></p></li>
<li><p>集合的幂运算：</p>
<p><img src="D:\Programing\Compilers\Notes\WolfBook\Images\集合幂运算.png" alt="集合幂运算" style="zoom:50%;" /></p></li>
<li><p>集合 <span class="math inline">\(A\)</span> 的闭包 <span
class="math inline">\(A^*\)</span> 和 集合 $ A $ 的正闭包 <span
class="math inline">\(A^+\)</span> ：$ A^+ = A^1 A^2  A^n \ A ^* = A^0
A^*$，有 <span class="math inline">\(A^+ = AA^* = A^*A\)</span></p></li>
</ul>
<h2 id="文法和语言的形式定义">2.3 文法和语言的形式定义</h2>
<h3 id="文法的形式定义">2.3.1 文法的形式定义</h3>
<p><strong>产生式或规则</strong>：有序对 $(U, x) $ ，通常写作 <span
class="math inline">\(U::=x\)</span> 或 <span class="math inline">\(U
\rightarrow x\)</span>，其中 <span class="math inline">\(U\)</span>
是符号，是产生式的左部，<span class="math inline">\(x\)</span>
是有穷符号串，是产生式的右部</p>
<p><strong>字汇表</strong>：所有的规则左部和右部中的所有符号组成的集合</p>
<p><strong>非终结符号</strong>：文法 <span
class="math inline">\(G\)</span>
中作为规则左部出现的符号，也称语法成分，形成了非终结符号集 <span
class="math inline">\(V_n\)</span></p>
<p><strong>终结符号</strong>：规则中不属于 <span
class="math inline">\(V_n\)</span> 的符号，形成了终结符号集合 <span
class="math inline">\(V_t\)</span></p>
<p><strong>识别符号或开始符号</strong>：符号 <span
class="math inline">\(Z\)</span> 至少是一条规则的左部</p>
<p><strong>BNF 表示法</strong>：</p>
<blockquote>
<p>合并具有相同左部的规则</p>
</blockquote>
<p><strong>文法</strong>：一个四元组 <span class="math inline">\(G =
&lt;V_n, V_i, P, Z&gt;\)</span></p>
<p><span class="math inline">\(P\)</span>：产生式或规则的集合，<span
class="math inline">\(Z\)</span>：文法的识别符号</p>
<h3 id="推导的形式定义">2.3.2 推导的形式定义</h3>
<p><strong>直接推导</strong>：<img
src="D:\Programing\Compilers\Notes\WolfBook\Images\直接推导.png"
alt="直接推导" /></p>
<p>间接推导：</p>
<figure>
<img src="D:\Programing\Compilers\Notes\WolfBook\Images\间接推导.png"
alt="简介推导" />
<figcaption aria-hidden="true">简介推导</figcaption>
</figure>
<h3 id="语言的形式定义">2.3.3 语言的形式定义</h3>
<p>设 $G[Z] $ 是定义在字汇表 <span class="math inline">\(V\)</span>
上的一个文法，其中 <span class="math inline">\(Z\)</span>
是识别符号，在此省去了尖括号</p>
<p><strong>句型</strong>：如果 <span class="math inline">\(Z
\stackrel{*} \Rightarrow x\)</span>，且 <span class="math inline">\(x
\in V^*\)</span>，则称 $x $ 是文法 <span
class="math inline">\(G\)</span> 的一个句型</p>
<p><strong>句子</strong>：如果 <span class="math inline">\(Z
\stackrel{+} \Rightarrow x\)</span>，且 <span class="math inline">\(x
\in V^*_t\)</span>，则称 $x $ 是文法 <span
class="math inline">\(G\)</span> 的一个句子</p>
<ul>
<li>句子是语言的最小单位</li>
<li>句子是从文法的识别符号推导出来的由终结符号所组成的符号串</li>
<li>定义式是充要条件</li>
<li>若用 <span class="math inline">\(Z \stackrel{*} \Rightarrow
x\)</span>，有可能 <span class="math inline">\(Z = x\)</span>，与 <span
class="math inline">\(x \in V^*_t\)</span> 矛盾</li>
</ul>
<p><strong>语言</strong>：文法 <span class="math inline">\(G[Z]\)</span>
产生的所有句子的集合，记为 <span
class="math inline">\(L(G[Z])\)</span>，称为文法 <span
class="math inline">\(G[Z]\)</span> 所定义的语言，即 <span
class="math inline">\(L(G[Z]) = \{x | x \in V^*_t，且Z \stackrel{*}
\Rightarrow x \}\)</span></p>
<ul>
<li>语言是所有终结符号串所组成的集合的一个子集，即 <span
class="math inline">\(L(G[Z]) \subseteq V^*_t\)</span></li>
</ul>
<p><strong>规范推导</strong>：最右推导</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428232155349.png"
alt="image-20230428232155349" />
<figcaption aria-hidden="true">image-20230428232155349</figcaption>
</figure>
<ul>
<li>每个句子都有一个规范推导，但并非每个句型都有规范推导</li>
<li>可规范推导出的句型称为“规范句型”</li>
</ul>
<p><strong>等价文法</strong>：<span class="math inline">\(G\)</span> 和
<span class="math inline">\(G \prime\)</span> 是两个不同的文法，如果
<span class="math inline">\(L(G) = L(G\prime)\)</span>
，称二者为等价文法。</p>
<ul>
<li>定义的语言相同即等价</li>
<li>为了某种目的改写文法</li>
</ul>
<h3 id="递归规则与递归文法">2.3.4 递归规则与递归文法</h3>
<p><strong>递归规则</strong>：<span
class="math inline">\(U::=xUy\)</span></p>
<ul>
<li>若 <span class="math inline">\(x = \varepsilon\)</span>，则 <span
class="math inline">\(U::=Uy\)</span> 称为左递归规则</li>
<li>若 <span class="math inline">\(y = \varepsilon\)</span>，则 <span
class="math inline">\(U::=xU\)</span> 称为右递归规则</li>
<li>若 <span class="math inline">\(x, y \neq \varepsilon\)</span>，则
<span class="math inline">\(U::=xUy\)</span> 称为自嵌入的规则</li>
</ul>
<p><strong>文法的递归性质</strong>：</p>
<ul>
<li>直接递归：文法中至少包含一条递归规则，则称文法是直接递归的</li>
<li>间接递归</li>
<li>对文法中任一非终结符号，若能建立一个推导过程，在推导所得的符号串中又出现了该终结符本身，则文法是递归性的；反之是非递归性的</li>
</ul>
<blockquote>
<p>含义很容易理解，只是用形式语言描述似乎看起来啰嗦些</p>
</blockquote>
<ul>
<li>可以由有穷的规则刻画无穷的语言</li>
<li>左递归文法无法采用自顶向下的分析算法</li>
</ul>
<h3 id="短语简单短语和句柄">2.3.5 短语、简单短语和句柄</h3>
<p><strong>短语</strong>：设 <span class="math inline">\(G[Z]\)</span>
是一文法，<span class="math inline">\(w = uxy\)</span> 是一句型，如果有
<span class="math inline">\(Z \stackrel{*} \Rightarrow xUy\)</span> 且
<span class="math inline">\(U \stackrel{+} \Rightarrow u\)</span> ，称
<span class="math inline">\(u\)</span> 是一个相对于非终结符号 <span
class="math inline">\(U\)</span> 的句型 <span
class="math inline">\(w\)</span> 的短语</p>
<ul>
<li>若有 <span class="math inline">\(Z \stackrel{*} \Rightarrow
xUy\)</span> 且 <span class="math inline">\(U \Rightarrow u\)</span>
，称 <span class="math inline">\(u\)</span> 是一个相对于非终结符号 <span
class="math inline">\(U\)</span> 的句型 <span
class="math inline">\(w\)</span> 的简单短语</li>
<li>$ U V_n, u V^+, x, y V$</li>
<li>短语是针对句型和非终结符号的</li>
</ul>
<p><strong>句柄</strong>：任一句型的最左简单短语称为句型的句柄</p>
<blockquote>
<p>通过画出句型的语法树可以直观方便地找到句型的短语、简单短语和句柄</p>
</blockquote>
<h3 id="练习-2-3">练习 2-3</h3>
<h2 id="语法树和二义性">2.4 语法树和二义性</h2>
<h3 id="推导与语法树">2.4.1 推导与语法树</h3>
<ol type="1">
<li>推导过程与语法树的生成
<ul>
<li>推导过程不同，但是最终生成的语法树是完全相同的</li>
<li>推导过程仅反应推导顺序</li>
<li>当然，并非所有文法都具有语法树唯一性</li>
</ul></li>
<li>子树与短语
<ul>
<li>摆了</li>
</ul></li>
<li>由树构造推导
<ul>
<li>摆了</li>
</ul></li>
</ol>
<h3 id="文法与二义性">2.4.2 文法与二义性</h3>
<p><strong>文法的二义性</strong>：</p>
<ul>
<li>文法中的某个句子存在不同的语法树</li>
<li>有两个不同的最右（最左）推导</li>
<li>有两个不同的最左归约（规范归约），即归约中某些规范句型的句柄不唯一</li>
</ul>
<p><strong>消除二义性</strong>：</p>
<ul>
<li>根据条件修改编译算法，如定义优先级</li>
<li>根据条件直接修改文法</li>
</ul>
<h3 id="练习-2-4">练习 2-4</h3>
<h2 id="符号串的分析">2.5 符号串的分析</h2>
<blockquote>
<p>前面讨论了用已知文法推导和产生句子，下面讨论确定给定符号串是否是文法的句子</p>
<p>即已知文法 <span class="math inline">\(G[Z], s \in V^*_t\)</span>
，判定 <span class="math inline">\(s \in L(G[Z])\)</span>？</p>
<p>主要分为自顶向下和自底向上分析</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th></th>
<th>自顶向下分析</th>
<th>自底向上分析</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="有关文法的实用限制">2.6 有关文法的实用限制</h2>
<p>不能有有害规则、多余规则</p>
<p><strong>压缩文法</strong>：每一个终结符都满足条件一和条件二</p>
<h2 id="扩充的-bnf-表示和语法图">2.7 扩充的 BNF 表示和语法图</h2>
<ol type="1">
<li>扩充的 BNF 表示</li>
</ol>
<p>优点：</p>
<ul>
<li>表示方便</li>
<li>消除左递归，便于自顶向下分析</li>
</ul>
<p>具体规则：</p>
<ul>
<li>花括号 <code>&#123;&#125;</code>：<span class="math inline">\(\{t\} ^m
_n\)</span>，表示符号串 <span class="math inline">\(t\)</span>
可以重复连接 <span class="math inline">\(n\)</span> 到 $ m$ 次，若省略
<span class="math inline">\(n、m\)</span> 表示可连接 <span
class="math inline">\(0\)</span> 次到任意多次</li>
<li>方括号 <code>[]</code>：<span
class="math inline">\(\[t\]\)</span>，表示符号串 <span
class="math inline">\(t\)</span> 可有可无，<span
class="math inline">\([t] = \{t\} ^1 _0\)</span></li>
<li>圆括号 <code>()</code>：在规则中提取因子</li>
</ul>
<ol start="2" type="1">
<li>语法图</li>
</ol>
<h2 id="文法和语言分类">2.8 文法和语言分类</h2>
<ol type="1">
<li><p>乔姆斯基对文法的定义</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230429143851835.png"
alt="image-20230429143851835" />
<figcaption aria-hidden="true">image-20230429143851835</figcaption>
</figure>
<ol start="2" type="1">
<li><p>文法和语言分类</p>
<ol type="1">
<li><span class="math inline">\(0\)</span> 型文法（短语结构文法）</li>
<li><span class="math inline">\(1\)</span>
型文法（上下文敏感文法、上下文有关文法）</li>
<li><span class="math inline">\(2\)</span> 型文法（上下文无关文法）</li>
<li><span class="math inline">\(3\)</span> 型文法（正则文法）
<ul>
<li>与能为有穷状态自动机接受等价</li>
</ul></li>
</ol>
<p>文法的限制性依次增强</p></li>
</ol></li>
</ol>
<h1 id="第三章-词法分析程序的设计">第三章 词法分析程序的设计</h1>
<p>词法分析程序又称词法分析器或扫描器</p>
<p>大多数程序语言的词法规则属于乔姆斯基 <span
class="math inline">\(3\)</span> 型文法</p>
<p>通过状态图方便地设计词法分析程序</p>
<h2 id="词法分析器的功能及实现方案">3.1 词法分析器的功能及实现方案</h2>
<ol type="1">
<li>识别输出单词，并检查错误</li>
<li>转换数字</li>
<li>删去空格、换行、制表、注释等空白符</li>
</ol>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230429144433494.png"
alt="image-20230429144433494" />
<figcaption aria-hidden="true">image-20230429144433494</figcaption>
</figure>
<blockquote>
<p>将字符串表示的源程序转化为以单词表示的源程序</p>
</blockquote>
<h2 id="单词的种类及词法分析程序的输出形式">3.2
单词的种类及词法分析程序的输出形式</h2>
<ol type="1">
<li><p>单词的种类：见前</p></li>
<li><p>词法分析程序的输出形式 一般采用二元式，如</p>
<table>
<thead>
<tr class="header">
<th>单词类别</th>
<th>单词值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>整型</td>
<td>58</td>
</tr>
<tr class="even">
<td>保留字</td>
<td>for</td>
</tr>
</tbody>
</table></li>
<li><p>按单词种类分类或一符一类</p></li>
</ol>
<h2 id="正则文法及其状态图">3.3 正则文法及其状态图</h2>
<blockquote>
<p>画状态图并以之构造词法分析器</p>
</blockquote>
<h3 id="状态图">3.3.1 状态图</h3>
<p><strong>一个有向图</strong>，其中</p>
<ul>
<li><p>圆圈标识的结点表示状态，状态之间用有向弧连接，弧上的标记（字符）代表有向弧的射出结点状态下可能出现的输入字符。</p></li>
<li><p>包含有限个结点，包含初态和终态，终态用双圈表示</p></li>
</ul>
<h3 id="使用状态图分析字符串x">3.3.2 使用状态图分析字符串x</h3>
<blockquote>
<p>自底向上</p>
</blockquote>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428155920181.png"
alt="image-20230428155920181" />
<figcaption aria-hidden="true">image-20230428155920181</figcaption>
</figure>
<h2 id="词法分析程序的设计与实现">3.4 词法分析程序的设计与实现</h2>
<h3 id="文法及其状态图">3.4.1 文法及其状态图</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428160047564.png"
alt="image-20230428160047564" />
<figcaption aria-hidden="true">image-20230428160047564</figcaption>
</figure>
<h3 id="词法分析程序的构造">3.4.2 词法分析程序的构造</h3>
<p>将语义动作添加到状态图中，并使每一个状态都对应一小段程序</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428161120196.png"
alt="image-20230428161120196" />
<figcaption aria-hidden="true">image-20230428161120196</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428161251494.png"
alt="image-20230428161251494" />
<figcaption aria-hidden="true">image-20230428161251494</figcaption>
</figure>
<h3 id="词法分析程序的实现">3.4.3 词法分析程序的实现</h3>
<p>先确定具体输出形式</p>
<ol type="1">
<li><p>输出形式</p>
<p>采用二元式</p></li>
</ol>
<figure>
<img src="D:\Programing\Compilers\Notes\WolfBook\Images\3.4.png"
alt="3.4" />
<figcaption aria-hidden="true">3.4</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsym</span><span class="params">()</span> &#123; <span class="comment">// 返回类别码</span></span><br><span class="line">    clearToken();</span><br><span class="line">    <span class="keyword">while</span> (isSpace() || isNewline() || isTab()) &#123;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isLetter()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isLetter() || isDigit()) &#123;</span><br><span class="line">            catToken();</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        retract();</span><br><span class="line">        <span class="type">int</span> result = reserver();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) </span><br><span class="line">            symbol = IDSY;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            symbol = result;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDigit()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isDigit()) &#123;</span><br><span class="line">            catToken();</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        retract();</span><br><span class="line">        num = transNum(token);</span><br><span class="line">        symbol = INTSY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isColon()) &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span> (isEqu()) </span><br><span class="line">            symbol = ASSIGNSY;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            retract();</span><br><span class="line">            symbol = COLONSY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlus()) &#123;</span><br><span class="line">            symbol = PLUSSY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isMinus()) &#123;</span><br><span class="line">            symbol = MINUSSY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isStar()) &#123;</span><br><span class="line">            symbol = STARSY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLpar()) &#123;</span><br><span class="line">            symbol = LPARSY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRpar()) &#123;</span><br><span class="line">            symbol = RPARSY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSemi()) &#123;</span><br><span class="line">            symbol = SEMISY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDivi()) &#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">if</span> (isStar()) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        getchar();</span><br><span class="line">                    &#125; <span class="keyword">while</span> (!isStar());</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        getchar();</span><br><span class="line">                        <span class="keyword">if</span> (isDivi())</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (isStar());</span><br><span class="line">                &#125; <span class="keyword">while</span> (!isStar());</span><br><span class="line">            &#125;</span><br><span class="line">            retract();</span><br><span class="line">            symbol = DIVISY;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            erro();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第4章-语法分析">第4章 语法分析</h1>
<blockquote>
<p>主要介绍自顶向下手工实现递归下降</p>
</blockquote>
<h2 id="自顶向下分析方法">4.1 自顶向下分析方法</h2>
<p>一般方法：带回溯的自顶向下分析方法</p>
<blockquote>
<p>本质上是一种试探方法，反复使用不同规则匹配输入串</p>
</blockquote>
<p>存在的问题：</p>
<ul>
<li><p>左递归问题——用扩充 BNF 文法改写</p>
<ul>
<li><p>提因子规则：消除左递归，压缩文法长度</p></li>
<li><p>替换规则：<span class="math inline">\(U::=x|y|\dots|z|Uv
\rightarrow U::=(x|y|\dots|z)\{v\}\)</span></p></li>
<li><p>改写为右递归：<span class="math inline">\(P::=Pa|b \rightarrow
P::=bP ^{\prime}\)</span> 和 <span class="math inline">\(P \prime
::=aP^{\prime} | \varepsilon\)</span></p></li>
<li><p>一般的改写算法：<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230429151541958.png"
alt="image-20230429151541958" /></p>
<blockquote>
<p>事实上就是先递归代入，再消除左递归，最后化简</p>
</blockquote></li>
</ul></li>
<li><p>回溯问题</p>
<ul>
<li><figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230429152458251.png"
alt="image-20230429152458251" />
<figcaption aria-hidden="true">image-20230429152458251</figcaption>
</figure></li>
</ul></li>
</ul>
<h2 id="递归下降分析法">4.2 递归下降分析法</h2>
<p><strong>主要做法</strong>：对文法中每一个非终结符号 <span
class="math inline">\(U\)</span>
都编写一个子程序完成其所对应的语法成分的分析和识别任务。子程序用该非终结符号的规则的右部符号串去匹配输入串</p>
<h2 id="基于递归下降分析法的语法分析程序构造">4.3
基于递归下降分析法的语法分析程序构造</h2>
<p><code>nextsym</code> ：扫描下一个符号并将类别码储存在
<code>sym</code> 中</p>
<p><code>error</code>
：调用出错处理程序打印错误信息，跳过分析过程中有错误的一段源程序</p>
<h1 id="第五章-符号表管理技术">第五章 符号表管理技术</h1>
<p>分析阶段：维护符号表</p>
<p>综合阶段：利用符号表生成目标代码</p>
<h2 id="概述">5.1 概述</h2>
<p><strong>符号表</strong>：记录<strong>源程序</strong>中各种标识符的特性信息的表格</p>
<p><strong>与遍数的关系</strong>：</p>
<ul>
<li>多遍扫描中在词法分析阶段填写，其他属性在语义分析和代码生成阶段填入</li>
<li>一遍：语义分析和代码生成</li>
</ul>
<p>标识符在源程序中的每一次出现都要与符号表打一次交道</p>
<p>若允许隐式声明，必须按首次引用处理</p>
<h2 id="符号表的组织和内容">5.2 符号表的组织和内容</h2>
<h3 id="符号表的结构和内容">5.2.1 符号表的结构和内容</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230429160114282.png"
alt="image-20230429160114282" />
<figcaption aria-hidden="true">image-20230429160114282</figcaption>
</figure>
<ul>
<li><p>标识符的种类：如简单变量、函数、过程、数组、标号、参数等。</p></li>
<li><p>类型：如整型、实型、字符型、指针等（一般用编码表示）</p></li>
<li><p>性质：变量形参、值形参等</p></li>
<li><p>值：标识符所代表的数值。</p></li>
<li><p>地址：标识符所分配单元的首地址或地址位移。</p></li>
<li><p>大小：所占的字节数。</p></li>
<li><p>作用域的嵌套层次：分程序结构语言中，标识符声明所在的分程序的层次。</p></li>
<li><p>标识符声明的源程序行号</p></li>
<li><p>标识符引用的源程序行号</p></li>
<li><p>以字母顺序排列的链域</p>
<blockquote>
<p>链域指向按字母排序的下一个标识符在符号表中的位置，便于产生按字母顺序排列的标识符交叉引用表</p>
<p>故如果不产生交叉引用表可以删去</p>
</blockquote></li>
</ul>
<p>对于一些特殊的名字，还要考虑较多的信息，如:</p>
<ul>
<li>对于数组，要考虑维数、上下界值、计算下标变量地址所用的信息以及数组元素类型等</li>
<li>对于记录（结构、联合），要考虑域的个数,每个域名、地址位移类型等</li>
<li>对于过程或函数，要考虑形参个数、所在层次、函数返回值类型、局部变量所占空间大小等</li>
<li>对于指针，要考虑所指对象类型等</li>
</ul>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230429160551515.png"
alt="image-20230429160551515" />
<figcaption aria-hidden="true">image-20230429160551515</figcaption>
</figure>
<h3 id="符号表的组织方式">5.2.2 符号表的组织方式</h3>
<ul>
<li><strong>统一符号表</strong>：按各种信息的并集设计表项
<ul>
<li>方便插入、查找</li>
<li>浪费空间</li>
</ul></li>
<li><strong>按标识符建立符号表</strong>：分别设计表项
<ul>
<li>节约空间</li>
<li>插入、查找开销大</li>
</ul></li>
<li><strong>折中</strong>：存储大部分共同信息，特殊信息另附表，二者用指针连接
<ul>
<li><figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230429160924281.png"
alt="image-20230429160924281" />
<figcaption aria-hidden="true">image-20230429160924281</figcaption>
</figure></li>
</ul></li>
</ul>
<blockquote>
<p>经典的时间和空间的 tradeoff</p>
</blockquote>
<p><strong>符号名的存储方法</strong>：</p>
<ul>
<li>预设长度
<ul>
<li>速度快，空间利用率低</li>
</ul></li>
<li>放置描述符
<ul>
<li>速度慢，节约空间</li>
</ul></li>
</ul>
<blockquote>
<p>就是数组实现方式和链表实现方式的区别</p>
</blockquote>
<h2 id="非分程序结构语言的符号表组织">5.3
非分程序结构语言的符号表组织</h2>
<p>主要介绍了散列技术，摆了</p>
<h2 id="分程序结构语言的符号表组织">5.4 分程序结构语言的符号表组织</h2>
<h3 id="标识符的作用域及基本处理方法">5.4.1
标识符的作用域及基本处理方法</h3>
<p>作用域局限在所定义的<strong>最小模块</strong>中</p>
<p>建表和查表的基本处理方法：</p>
<ul>
<li>在声明部分读到标识符时
<ul>
<li>查询所在程序单元符号表
<ul>
<li>已存在同名标识符——报错</li>
<li>不存在同名标识符——插入</li>
</ul></li>
</ul></li>
<li>在可执行部分读到标识符时
<ul>
<li>查询所在程序单元符号表
<ul>
<li>已存在同名标识符——已声明</li>
<li>不存在同名标识符
<ul>
<li>逐层查找外层符号表
<ul>
<li>已存在同名标识符——已声明，读取信息供使用</li>
<li>未存在同名标识符——使用了未声明的标识符</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li>语言预定义的标识符
<ul>
<li>放在最外层符号表</li>
</ul></li>
<li>分程序开始
<ul>
<li>定位</li>
</ul></li>
<li>分程序结束
<ul>
<li>重定位</li>
</ul></li>
</ul>
<h3 id="定位和重定位">5.4.2 定位和重定位</h3>
<blockquote>
<p>其嵌套方式显然对应着栈结构</p>
</blockquote>
<h3 id="符号表的组织方式-1">5.4.3 符号表的组织方式</h3>
<ol type="1">
<li>栈式符号表
<ul>
<li>遇到标识符声明——压栈</li>
<li>分程序结尾——仅弹栈而不彻底删除</li>
<li>性能较差，仅用于符号表较小时</li>
</ul></li>
<li>散列符号表的栈式实现</li>
</ol>
<h1 id="第六章-运行时的存储组织及管理">第六章
运行时的存储组织及管理</h1>
<h2 id="静态存储分配">6.1 静态存储分配</h2>
<p>对于编译时可以确定其存储空间大小的数据，可以在编译时就给它们分配固定的存储空间</p>
<p>其余数据则将分配存储过程留待目标程序运行时动态地进行</p>
<h2 id="动态内存分配">6.2 动态内存分配</h2>
<h3 id="活动记录">6.2.1 活动记录</h3>
<p>运行栈上的动作和普通栈上的动作相同。当进入一个模块时，就在运行栈的栈顶创建一个专用数据区，通常称为活动记录(Activation
Record)。活动记录的开始位置称为基</p>
<p><strong>注意栈的增长方向</strong></p>
<h3 id="参数区">6.2.2 参数区</h3>
<h3 id="display-区">6.2.3 display 区</h3>
<h3 id="运行时的地址计算">6.2.4 运行时的地址计算</h3>
<h3 id="递归过程的处理">6.2.5 递归过程的处理</h3>
<h2 id="内存垃圾回收器">6.3 内存垃圾回收器</h2>
<p>需要从编译器、操作系统甚至处理器芯片中获得信息</p>
<p>分析当前程序运行时产生的变量根集（root set）进行可达性分析</p>
<p>变量根集指在程序运行的某一时刻运行栈上所有变量或对象的集合，再加上当前程序的全局变量、静态变量等变量或对象</p>
<h3 id="引用计数">6.3.1 引用计数</h3>
<p>reference counting</p>
<p>指向该对象的引用被创建——count+1</p>
<p>已经存在的指向某对象的引用被删除或重写——count-1</p>
<p>e.g. <span class="math inline">\(P = Q\)</span> ，Q
指向对象的计数值-1，P 指向对象的计数值+1</p>
<p>回收一个对象可能会传递性地对其他对象的计数器进行-1操作，最后回收那些计数器变成0的对象</p>
<p>对于大部分高性能系统，引用计数已经被跟踪型垃圾回收器替代</p>
<h3 id="标记和清除垃圾回收器">6.3.2 标记和清除垃圾回收器</h3>
<p>两阶段回收垃圾：</p>
<ul>
<li>从对象根集开始遍历整个指针关系图，通过标识位区分死对象和活对象</li>
<li>垃圾回收，不移动内存堆中的对象。故主要弊端是<strong>内存碎片</strong></li>
</ul>
<h3 id="标记紧缩算法">6.3.3 标记紧缩算法</h3>
<p>在标记清除回收器的基础上引入紧缩技术</p>
<h3 id="拷贝回收算法">6.3.4 拷贝回收算法</h3>
<ul>
<li>空间利用率低</li>
</ul>
<h3 id="分代垃圾回收器">6.3.5 分代垃圾回收器</h3>
<h1 id="第七章-源程序的中间形式">第七章 源程序的中间形式</h1>
<blockquote>
<p>也即中间代码</p>
</blockquote>
<h2 id="波兰表示">7.1 波兰表示</h2>
<p>中缀转后缀算法：</p>
<ul>
<li>扫描到操作数，直接输出</li>
<li>遇到操作符，与栈顶元素比较优先级
<ul>
<li>栈顶 &gt; 栈外，输出栈顶</li>
<li>反之，操作符入栈</li>
</ul></li>
</ul>
<p>波兰表示<strong>不便优化</strong></p>
<h2 id="n-元表示">7.2 N-元表示</h2>
<p>三元式：<操作符1>,<操作数1>,<操作数2></p>
<p>一组三元式，前面三元式的计算结果可用该三元式的编号表示</p>
<p>四元式：<操作符1>,<操作数1>,<操作数2>,<结果></p>
<h2 id="抽象语法树">7.3 抽象语法树</h2>
<p>非叶结点：操作符</p>
<p>叶结点：操作数</p>
<p><strong>与前两种表示的联系</strong>：后续遍历可以得到后缀表达式，</p>
<h2 id="抽象机代码">7.4 抽象机代码</h2>
<p>摆了</p>
<h1 id="第八章-错误处理">第八章 错误处理</h1>
<h2 id="概述-1">8.1 概述</h2>
<p>编译程序的错误处理能力包括：</p>
<ul>
<li>检查出各类错误的能力</li>
<li>准确地指出出错位置及错误性质的能力</li>
<li>通过一次编译能将源程序中的错误尽可能都找出来的能力</li>
<li>具有一定的错误改正的能力</li>
<li>遏止重复错误信息的能力</li>
</ul>
<h2 id="错误的分类">8.2 错误的分类</h2>
<ul>
<li>语法错误：不符合语法（词法）规则
<ul>
<li>如漏掉一半括号等</li>
</ul></li>
<li>语义错误：不符合语义或超越具体计算机的限制
<ul>
<li>如标识符先声明才能引用，形参实参个数匹配</li>
<li>溢出错误，如计算结果太大；符号表、数据存储区等溢出</li>
</ul></li>
</ul>
<h2 id="错误的检查与报告">8.3 错误的检查与报告</h2>
<p>一些语义错误要由目标程序检查出来</p>
<ul>
<li>如下标越界</li>
<li>处理方法一般是编译时生成有关检验指令</li>
</ul>
<p>报告错误的两种方式</p>
<ul>
<li>分析完再打印，需要单独开辟空间</li>
<li>边分析边打印，有可能检测不出来</li>
</ul>
<h2 id="错误处理技术">8.4 错误处理技术</h2>
<p>两种错误处理办法</p>
<ul>
<li>错误改正
<ul>
<li>太难了没有编译器做到</li>
</ul></li>
<li>错误局部化处理
<ul>
<li>暂停并跳过对出错部分的分析</li>
<li>实现：在编译程序中设置专用变量存放指定的右界符</li>
</ul></li>
</ul>
<p>遏制重复的错误信息</p>
<ul>
<li><p>建立出错名字表，类似如下代码段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.java</span></span><br><span class="line"><span class="keyword">if</span> (errorMap.containsKey(unDefinedModifier)) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    put(unDefinedModifier, errorMessage);</span><br><span class="line">    <span class="comment">// print something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设置标志位，类似 <code>isVisited</code></p></li>
</ul>
<h1 id="第九章-语法制导翻译技术">第九章 语法制导翻译技术</h1>
<blockquote>
<p>翻译文法、属性文法、自顶向下语法制导翻译技术</p>
</blockquote>
<h2 id="翻译文法">9.1 翻译文法</h2>
<figure>
<img
src="D:\Programing\Compilers\Notes\WolfBook\Images\活动序列动作符号.png"
alt="活动序列动作符号" />
<figcaption aria-hidden="true">活动序列动作符号</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230430222848882.png"
alt="image-20230430222848882" />
<figcaption aria-hidden="true">image-20230430222848882</figcaption>
</figure>
<p><strong>翻译文法</strong>：终结符号集由输入符号和动作符号组成的上下文无关文法。</p>
<p><strong>活动序列</strong>：翻译文法确定的语言中的符号串</p>
<h2 id="语法制导翻译">9.2 语法制导翻译</h2>
<blockquote>
<p>形式上，将翻译看成偶对的集合，第一个元素是输入语言中的符号串，第二个元素是翻译该符号串时的动作序列或执行动作序列所规定的操作后生成的新符号串</p>
<p>即 符号串 <span class="math inline">\(\rightarrow\)</span>
动作序列</p>
<p>或 符号串 <span class="math inline">\(\rightarrow\)</span>
动作序列生成的新符号串</p>
<p>在翻译文法是符号串翻译文法的时候可以认为二者同义</p>
</blockquote>
<p><strong>语法制导翻译</strong>：给定一输入符号串，根据输入文法获得翻译该符号串的动作序列，并执行该动作序列所规定的动作的过程</p>
<blockquote>
<p>翻译文法定义的翻译</p>
</blockquote>
<p><strong>输入序列</strong>：表示从活动序列中删掉所有<strong>动作符号</strong>而得到的符号序列
<strong>动作序列</strong>：表示从活动序列中删掉所有<strong>输入符号</strong>而得到的符号序列</p>
<blockquote>
<p>你俩在这玩相爱相杀是吧</p>
</blockquote>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230430224236885.png"
alt="image-20230430224236885" />
<figcaption aria-hidden="true">image-20230430224236885</figcaption>
</figure>
<h2 id="属性翻译文法">9.3 属性翻译文法</h2>
<h3 id="综合属性">9.3.1 综合属性</h3>
<p>将翻译文法中无值的符号扩充为有值的，值部分称为符号的属性</p>
<blockquote>
<p>产生式中左部符号的属性值是通过计算右部符号的属性值得来的</p>
</blockquote>
<h3 id="继承属性">9.3.2 继承属性</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230501102809077.png"
alt="image-20230501102809077" />
<figcaption aria-hidden="true">image-20230501102809077</figcaption>
</figure>
<h2 id="自顶向下语法制导翻译">9.4 自顶向下语法制导翻译</h2>
<p>// to be continued</p>
<blockquote>
<p>这章好抽象啊，不知道对于实验需要的内容有多大帮助，反正连滚带爬读完了，理论内容先放一放</p>
</blockquote>
<h1 id="第十章-语义分析和代码生成">第十章 语义分析和代码生成</h1>
<h2 id="语义分析的概念">10.1 语义分析的概念</h2>
<p>处理上下文有关文法的方式：用专门的语义动作来补充上下文无关分析器的动作，即<strong>借助语义分析</strong></p>
<p>语义分析要处理的问题</p>
<ul>
<li>我没读出来作者的意思，所以这条鸽了</li>
<li>表达式和赋值语句操作数的类型一致性检查</li>
<li>分析语义并做相应的语义处理</li>
</ul>
<h2 id="栈式抽象机及其汇编指令">10.2 栈式抽象机及其汇编指令</h2>
<p>table</p>
<h2 id="声明语句的处理">10.3 声明语句的处理</h2>
<p>编译器分离出每个实体，并填符号表</p>
<p>声明后，可以使用符号表中信息</p>
<ul>
<li>检查对所声明的实体引用是否正确</li>
<li>利用已声明实体的特性信息，为给定源程序生成特定的目标代码</li>
</ul>
<h3 id="常量类型">10.3.1 常量类型</h3>
<h3 id="简单变量">10.3.2 简单变量</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">staticvardef</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> i, <span class="type">char</span> *n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = tableinsert(n, t, i);</span><br><span class="line">    <span class="comment">/*给定一简单变量n的类型,所需的数据空间大小i。tableinsert将n和属性i及t一起填入符号表。</span></span><br><span class="line"><span class="comment">    i用作临时变量,记录函数返回值。*/</span></span><br><span class="line">    <span class="keyword">if</span> (j == DUPLICATION) &#123;</span><br><span class="line">        errmsg(duplident, statmtno);<span class="comment">/*输出相关的错误信息*/</span> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == OVERFLOW) &#123;</span><br><span class="line">        errmsg(tableoverflow, staticnumber);</span><br><span class="line">        <span class="built_in">abort</span>();        <span class="comment">/*符号表溢出,编译失败,终止编译程序*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">allocsv</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">/*存储分配*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*设简单变量所要求的数据空间大小为i,由此可更新指针 codeptr 的内容*/</span></span><br><span class="line">    codeptr = codeptr + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组变量">10.3.3 数组变量</h3>
<p>编译程序在处理数组声明时将建立一个模板，以便在执行期间能够间接引用该数组的元素。</p>
<ul>
<li>静态数组——在编译期间建立</li>
<li>动态数组——在编译时仅为模板的建立分配一个空间，而模板本身将在运行时建立</li>
</ul>
<p><strong>数组绝对地址的计算</strong></p>
<h3 id="记录变量">10.3.4 记录变量</h3>
<p>用来引用几个不同名字所组成的实体</p>
<h3 id="过程声明">10.3.5 过程声明</h3>
<h2 id="表达式语句">10.4 表达式语句</h2>
<p>将表达式的操作数装载到操作数栈栈顶或寄存器，执行操作后将结果保留在操作数栈栈顶或寄存器</p>
<h2 id="赋值语句">10.5 赋值语句</h2>
<p>如果支持对数组的赋值，需要先找到数组的地址，继而使用内部计数器增值的方法产生对所有数组元素的引用</p>
<h2 id="控制语句">10.6 控制语句</h2>
<h3 id="if-语句">10.6.1 <code>if</code> 语句</h3>
<h3 id="case-语句">10.6.2 <code>case</code> 语句</h3>
<h3 id="while-语句">10.6.3 <code>while</code> 语句</h3>
<h3 id="for-语句">10.6.4 <code>for</code> 语句</h3>
<h2 id="过程调用和返回语句">10.7 过程调用和返回语句</h2>
<p>// to be continued</p>
<h2 id="输入输出语句">10.8 输入/输出语句</h2>
<p>// to be continued</p>
<h2 id="编译程序的辅助功能">10.9 编译程序的辅助功能</h2>
]]></content>
      <categories>
        <category>Notes</category>
        <category>S5</category>
        <category>编译</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>诗经小作业之文本配乐</title>
    <url>/set-music/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>2024 诗经小作业之文本配乐，给《汝坟》配《1874》的胡乱涂抹思想过程</p>
</blockquote>
<span id="more"></span>
<h2 id="汝坟">汝坟</h2>
<p>遵彼汝坟，伐其条枚； 未见君子，惄如调饥。 遵彼汝坟，伐其条肄；
既见君子，不我遐弃。 鲂鱼赪尾，王室如燬； 虽则如燬，父母孔迩。</p>
<h2 id="配乐及联系">配乐及联系</h2>
<p>这是高亨在《诗经今注》里面的背景介绍：</p>
<p>西周末年，周幽王无道，犬戎入寇，攻破镐京。周南地区一个在王朝做小官的人逃难回到家中，他的妻很喜欢，作此诗安慰他。</p>
<p>诗的含义很易懂，沿着汝河的河岸砍伐枝条，思念效忠王室的爱人。未见之时惆怅如早上空腹苦捱饥饿，见面后才更想多多挽留。王室的情况非常危急！即使王室情况危急，你能不能也多陪伴我一会，我们的父母就在身边。</p>
<p>我感念于封建时代的真爱，就算在战时这一男人需要效忠封建王室的时刻，女人也是如此钟爱她的男人。有别于君臣父子的礼乐教化，女人反而希望男人能多留在身边陪陪父母和家人。这是人类自然而崇高的情感，王室的需要和女人的需要交织在这个男人身上，这种小爱和大忠的冲突反而折射出小爱的光辉。</p>
<p>想给这首诗作配一首陈奕迅的《1874》，这首歌写歌手本该拥有一个同时代的完美恋人，却因命运的阴差阳错没有遇到，怀疑是爱人早生了
100 年，也即比歌手出生年 1974 更早 100
年，这首歌由此得名。词人另辟蹊径，通过这种方式大胆表达对爱人的呼唤和自身的孤独感。</p>
<p>《汝坟》写一种两人相同时代不同空间的遗憾和孤独，《1874》写一种两人已经不在同一时代，遑论同一空间。空间和时间上的无法厮守相互呼应。时空纠缠交错，爱人各自寂寥”情人若寂寥地出生在
1874，刚好早一百年一个世纪“，最后回归于玫瑰色的略有些浮夸的浪漫——”如果不可相约在和平地方，也与你畅游战地“，想想相约战地又怎么幸福，再想想，能相约还有什么不能幸福。</p>
<p>附两个 live 的版本吧，06 Get A Life 的西洋乐器伴奏，24 Fear and
Dreams
的孤独圆舞。孤独之人对爱的呼唤甚是强烈，战争更加剧了这种孤独，强化了这种呼唤。</p>
]]></content>
      <categories>
        <category>Music</category>
        <category>Poetry</category>
        <category>S6</category>
      </categories>
      <tags>
        <tag>Music</tag>
        <tag>Poetry</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学笔记</title>
    <url>/combinatorics-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>2023 春组合数学笔记，全部资料参见我的 Github <a
href="https://github.com/StrivingLee/Introductory-Combinatorics">Click
here to see the remote repository</a>)</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>总思路：存在 <span class="math inline">\(\rightarrow\)</span> 计数
<span class="math inline">\(\rightarrow\)</span> 算法 <span
class="math inline">\(\rightarrow\)</span> 优化</p>
</blockquote>
<h3 id="timeline">TimeLine</h3>
<p>Created: 2023.05.09</p>
<p>Maximum change: 2023.06.09</p>
<p>Finish: 2023.06.13</p>
<h3 id="第1章-引论">第1章 引论</h3>
<h4 id="例1幻方">例1：幻方</h4>
<p><span class="math inline">\(2\)</span> 阶幻方不存在，对于任意 $n &gt;
3 $ 的整数 <span class="math inline">\(n\)</span>，都存在一个 <span
class="math inline">\(n\)</span> 阶幻方</p>
<h4 id="例236-军官问题">例2：<span class="math inline">\(36\)</span>
军官问题</h4>
<h4 id="例3完美覆盖问题">例3：完美覆盖问题</h4>
<h4 id="一般化">一般化：</h4>
<p>$ m n $ 棋盘被 <span class="math inline">\(b\)</span> -
牌完美覆盖，当且仅当 <span class="math inline">\(b\)</span> 是 <span
class="math inline">\(m\)</span> 或 <span
class="math inline">\(n\)</span> 的一个因子</p>
<h4 id="延伸问题断层线-fault-line">延伸问题：断层线 (Fault Line)</h4>
<p><span class="math inline">\(4 \times 4\)</span> 棋盘用 <span
class="math inline">\(8\)</span>
张多米诺牌完美覆盖，证明：总可以将这个棋盘横向或纵向分成非空两个部分，且没有牌被切断</p>
<p><img src="Images\FaultLine.jpg" alt="FaultLine" style="zoom: 33%;" /></p>
<h4 id="例4相互重叠的圆递推公式">例4：相互重叠的圆（递推公式）</h4>
<p>设这 <span class="math inline">\(h_n\)</span> 个圆将平面分为 <span
class="math inline">\(m\)</span> 个区域，当加入第 <span
class="math inline">\(n\)</span> 个圆时，这个圆与前面 <span
class="math inline">\(n-1\)</span> 个圆交于 <span
class="math inline">\(2(n-1)\)</span> 个点，这 <span
class="math inline">\(2(n-1)\)</span> 个点把第 <span
class="math inline">\(n\)</span> 个圆分成 <span
class="math inline">\(2(n-1)\)</span> 条弧，每条弧将其经过的区域分成
<span class="math inline">\(2\)</span> 个区域（在前面的 <span
class="math inline">\(n-1\)</span> 个圆分成的区域中），故新加入的第
<span class="math inline">\(n\)</span> 个圆使区域数增加了 <span
class="math inline">\(2(n-1)\)</span></p>
<p>建立递推关系如下： <span class="math display">\[
h_n = h_{n-1} + 2(n-1) (n \geq 2) \\ h_1 = 2
\]</span></p>
<blockquote>
<p>解决问题的一般顺序：求通项 <span
class="math inline">\(\rightarrow\)</span> 求递推公式 <span
class="math inline">\(\rightarrow\)</span> 诉诸生成函数</p>
</blockquote>
<h4 id="例5nim-取子游戏">例5：<span class="math inline">\(Nim\)</span>
取子游戏</h4>
<p>有 <span class="math inline">\(k(\geq 1)\)</span> 堆石子，分别含有
<span class="math inline">\(n_1,n_2,\dots, n_k\)</span> 个子</p>
<p>游戏规则:</p>
<ul>
<li>游戏人 <span class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 交替从这些堆里取一定数量石子</li>
<li>取子时，只能选择其中一堆，并且取至少一个石子</li>
<li>最后取完子的人为胜者</li>
</ul>
<p>定义：<span class="math inline">\(n_1, n_2, \dots, n_k\)</span>
是正整数，若它们的二进制数码的<strong>异或值</strong>为 <span
class="math inline">\(0\)</span>，则称它们处于<strong>平衡状态</strong>，否则处于<strong>非平衡状态</strong></p>
<p>结论：<span class="math inline">\(A\)</span> 能在非平衡的 <span
class="math inline">\(Nim\)</span> 取子中获胜，而 <span
class="math inline">\(B\)</span> 能在平衡的 <span
class="math inline">\(Nim\)</span> 取子中获胜</p>
<h3 id="第2章-排列与组合"><strong>第2章 排列与组合</strong></h3>
<h4 id="个基本的计数原理">2.1：4个基本的计数原理</h4>
<ul>
<li>加法原理、乘法原理、减法原理、除法原理
<ul>
<li>例：确定数 <span class="math inline">\(3^4 \times 5^2 \times 11^7
\times 13^8\)</span> 的正整数因子的个数（<strong>注意每个因子取 <span
class="math inline">\(0\)</span> 次！！！</strong>因为 <span
class="math inline">\(1\)</span> 也是因子）</li>
<li>解：由乘法原理，<span class="math inline">\(5 \times 3 \times 8
\times 9\)</span></li>
</ul></li>
</ul>
<h4 id="集合的排列">2.2：集合的排列</h4>
<ul>
<li><p>从 <span class="math inline">\(n\)</span> 个不同元素取出 <span
class="math inline">\(r\)</span> 个元素有序摆放，称 <span
class="math inline">\(n\)</span> 元素集合的 <span
class="math inline">\(r\)</span> - 排列。 用 <span
class="math inline">\(P(n, r)\)</span> 表示 <span
class="math inline">\(n\)</span> 元素集合的全部 <span
class="math inline">\(r\)</span> - 排列数。</p></li>
<li><p>全排列：列出全部元素的排列</p></li>
<li><p><span class="math inline">\(P(n, r) =
\dfrac{n!}{(n-r)!}\)</span></p></li>
<li><p>分步递推：<span class="math inline">\(P(n, r)=n \times
P(n-1,r-1)\)</span></p>
<ul>
<li><p>选择 <span class="math inline">\(1\)</span> 号盒子，放入 <span
class="math inline">\(1\)</span> 个乒乓球</p></li>
<li><p>从 <span class="math inline">\(n-1\)</span> 个球中选出 <span
class="math inline">\(r-1\)</span> 个放入 <span
class="math inline">\(r-1\)</span> 个盒子排列</p></li>
</ul></li>
<li><p>分类递推：<span class="math inline">\(P(n,
r)=P(n-1,r)+rP(n-1,r-1)\)</span></p>
<ul>
<li><p>不选第 <span class="math inline">\(1\)</span> 个球</p></li>
<li><p>选择第 <span class="math inline">\(1\)</span> 个球</p></li>
</ul></li>
<li><p>循环排列：只考虑元素间的相对顺序</p></li>
<li><p><strong>定理2.2.2：</strong> <span
class="math inline">\(n\)</span> 个元素集合的循环 <span
class="math inline">\(r\)</span> 排列个数为： <span
class="math display">\[
\dfrac{P(n, r)}{r}
\]</span></p>
<ul>
<li><p>例：<span class="math inline">\(10\)</span> 个人围坐圆桌，<span
class="math inline">\(2\)</span> 人不彼此相邻，求总排列方法数</p></li>
<li><p><span class="math inline">\((10 - 1)! - 2 \times (9 -
1)!\)</span></p></li>
<li><p>先固定一个人 <span class="math inline">\(P_1\)</span>，然后 <span
class="math inline">\(P_2\)</span> 可选位置为 <span
class="math inline">\(7\)</span>，余下 <span
class="math inline">\(8\)</span> 人任意坐，共 <span
class="math inline">\(7 \times 8!\)</span></p></li>
</ul></li>
<li><p>若是项链排列，为上式除以 <span
class="math inline">\(2\)</span>，考虑正反翻转 <span
class="math inline">\(2\)</span> 种情况</p></li>
</ul>
<h4 id="集合的组合">2.3：集合的组合</h4>
<ul>
<li><p>从 <span class="math inline">\(n\)</span> 个元素中无序地取出
<span class="math inline">\(r\)</span> 个元素，称 <span
class="math inline">\(n\)</span> 元素集合的 <span
class="math inline">\(r\)</span> - 组合。用 <span
class="math inline">\(\left( \begin{matrix} n \\ r
\end{matrix}\right)\)</span> 表示 <span class="math inline">\(n\)</span>
元素集合的全部 <span class="math inline">\(r\)</span> -
组合数。</p></li>
<li><p>约定：</p>
<ul>
<li><p><span class="math inline">\(\left(
\begin{matrix}0\\0\end{matrix}\right)=1\)</span></p></li>
<li><p>当 <span class="math inline">\(r &gt; n\)</span> 时，<span
class="math inline">\(\left(
\begin{matrix}n\\r\end{matrix}\right)=1\)</span></p>
<blockquote>
<p>选择的个数多于总个数时计数为 <span
class="math inline">\(0\)</span></p>
</blockquote></li>
</ul></li>
<li><p>选班委公式：<span class="math inline">\(C(n,r)C(r,k)=C(n,k)C(n-k,
r-k)\)</span>。</p>
<ul>
<li><p>选出 <span class="math inline">\(r\)</span> 个班委、<span
class="math inline">\(k\)</span> 个常委</p></li>
<li><p>先选出 <span class="math inline">\(k\)</span> 个常委，再选出
<span class="math inline">\(r-k\)</span> 个其他班委</p></li>
</ul></li>
<li><p><strong>定理2.3.3（Pascal公式）：</strong>对于满足 <span
class="math inline">\(1 \le k \le n - 1\)</span> 的整数 <span
class="math inline">\(k\)</span> 和 <span
class="math inline">\(n\)</span>，有</p>
<ul>
<li><p><span class="math display">\[
\left( \begin{matrix}n\\k\end{matrix}\right) = \left( \begin{matrix}n -
1\\k\end{matrix}\right) + \left( \begin{matrix}n - 1\\k -
1\end{matrix}\right)
\]</span></p></li>
<li><p>组合证明：</p></li>
<li><p>不包含某个元素 <span class="math inline">\(x\)</span> 的 <span
class="math inline">\(k\)</span> 子集 <span class="math inline">\(\left(
\begin{matrix}n-1\\k\end{matrix}\right)\)</span> 个</p></li>
<li><p>包含这个元素 <span class="math inline">\(x\)</span> 的 <span
class="math inline">\(k\)</span> 子集 <span class="math inline">\(\left(
\begin{matrix}n-1\\k-1\end{matrix}\right)\)</span>​ 个</p></li>
</ul></li>
<li><p>公式：<span class="math inline">\(\left(
\begin{matrix}n\\0\end{matrix}\right)+\left(
\begin{matrix}n\\1\end{matrix}\right)+\left(
\begin{matrix}n\\2\end{matrix}\right)+...+\left(
\begin{matrix}n\\n\end{matrix}\right)=2^n\)</span>
（用子集数量组合计数证明）</p></li>
</ul>
<h4 id="多重集的排列">2.4：多重集的排列</h4>
<blockquote>
<p>主要分无限重复和有限重复</p>
</blockquote>
<ul>
<li><p><strong>定义：</strong><span class="math inline">\(M =
\{a,a,b,c,c,c\} = \{2 \cdot a, 1 \cdot b, 3 \cdot c\}\)</span>，称 <span
class="math inline">\(2, 1, 3\)</span> 是重复集的重数</p>
<ul>
<li>允许元素重复</li>
<li>允许无限重数</li>
</ul></li>
<li><p><strong>定理2.4.2：</strong>令 <span
class="math inline">\(S\)</span> 是多重集，它有 <span
class="math inline">\(k\)</span> 种不同的元素，每种元素的重复数分别为
<span class="math inline">\(n_1，n_2，…，n_k\)</span>，那么，<span
class="math inline">\(S\)</span> 的排列数等于 <span
class="math display">\[
\dfrac{n!}{n_1!n_2!...n_k!}
\]</span></p>
<ul>
<li>证明：依次摆放，约去多余项</li>
<li>例如：数字 <span class="math inline">\(1,1,1, 3, 8\)</span>
可以构造出多少个不同的 <span class="math inline">\(5\)</span>
位数？即</li>
</ul>
<p><span class="math display">\[
\dfrac{5!}{3!1!1!}=20
\]</span></p></li>
<li><p><strong>定理2.4.3：</strong>设 <span class="math inline">\(n =
n_1 + n_2 + \dots + n_k\)</span>，将 <span
class="math inline">\(n\)</span> 个元素集合划分为做了标签的 <span
class="math inline">\(k\)</span> 个盒子 <span class="math inline">\(B_1,
B_2, \dots ,B_k\)</span>，其中 <span class="math inline">\(B_i\)</span>
盒子含有 <span class="math inline">\(n_i\)</span> 个元素，方法数为 <span
class="math display">\[
\dfrac{n!}{n_1!n_2! \dots n_k!}
\]</span> 若盒子无标号且 <span class="math inline">\(n_1 = n_2 = \dots =
n_k\)</span>，则划分数为 <span class="math display">\[
\dfrac{n!}{k!n_1!n_2! \dots n_k!}
\]</span></p>
<blockquote>
<p>多重集的另一种解释：集合划分</p>
<p>如果不是所有的划分数都相等，就需要相同个数的划分去重</p>
</blockquote>
<ul>
<li><p>例：将 <span class="math inline">\(7\)</span> 个不同颜色的球放入
<span class="math inline">\(3\)</span>
个无区别的盒子中，要求每盒球数目不少于 <span
class="math inline">\(2\)</span>，求解放置方案数。</p></li>
<li><p>解：放置方法必为 <span
class="math inline">\(223\)</span>，故方案数为（第一个 <span
class="math inline">\(2!\)</span> 为划分去重） <span
class="math display">\[
\dfrac{7!}{2!2!2!3!} = 105
\]</span></p></li>
</ul></li>
<li><p><strong>定理2.4.4（非攻击性车摆放）：</strong>有 <span
class="math inline">\(n\)</span> 个车共 <span
class="math inline">\(k\)</span> 种颜色，其中第一种颜色的车有 <span
class="math inline">\(n_1\)</span> 个，第二种颜色的车有 <span
class="math inline">\(n_2\)</span> 个，<span
class="math inline">\(\dots\)</span>，第 <span
class="math inline">\(k\)</span> 种颜色的车有 <span
class="math inline">\(n_k\)</span> 个，那么，把这些车放到 <span
class="math inline">\(n \times n\)</span>
的棋盘上，使得没有车能相互攻击的摆放方法数为： <span
class="math display">\[
\dfrac{n!}{n_1!n_2!...n_k!}\cdot n! = \dfrac{(n!)^2}{n_1!n_2!...n_k!}
\]</span></p>
<ul>
<li>例如：当 <span class="math inline">\(8\)</span> 个车，<span
class="math inline">\(1\)</span> 个红车，<span
class="math inline">\(3\)</span> 个蓝车和 <span
class="math inline">\(4\)</span> 个黄车。非攻击车摆放的方法数：</li>
</ul>
<p><span class="math display">\[
8! \times \dfrac{8!}{1!3!4!} = \dfrac{(8!)^2}{3!4!}
\]</span></p>
<blockquote>
<p>先排车，再给车排颜色</p>
</blockquote></li>
</ul>
<h4 id="多重集的组合">2.5：多重集的组合</h4>
<blockquote>
<p>相当于将 <span class="math inline">\(r\)</span> 个相同元素分成 <span
class="math inline">\(k\)</span>
个不同区域，每个区域对应一种元素——隔板法</p>
<p>多重集组合 <span class="math inline">\(\Leftrightarrow\)</span>
不定方程解集 <span class="math inline">\(\Leftrightarrow\)</span>
多重集排列</p>
<p>多重集 <span class="math inline">\(S\)</span> 的 <span
class="math inline">\(r\)</span> - 组合数等于多重集 <span
class="math inline">\(T\)</span> 的排列数</p>
</blockquote>
<ul>
<li><p><strong>定理2.5.1：</strong>令 <span
class="math inline">\(S\)</span> 是多重集，它有 <span
class="math inline">\(k\)</span>
个不同的元素，每个元素都有无限重复次数，那么，<span
class="math inline">\(S\)</span> 的 <span
class="math inline">\(r\)</span> - 组合个数为： <span
class="math display">\[
\left(
\begin{matrix}
r+k-1 \\
r
\end{matrix}
\right)
=
\left(
\begin{matrix}
r+k-1 \\
k-1
\end{matrix}
\right)
\]</span></p>
<ul>
<li><p>例：令 <span class="math inline">\(S＝\{12 \cdot a, 12\cdot b,
12\cdot c\}\)</span>，求 <span class="math inline">\(S\)</span> 的 <span
class="math inline">\(12\)</span> - 组合个数： <span
class="math display">\[
\left(
\begin{matrix}
12+3-1 \\
12
\end{matrix}
\right)=\dfrac{14!}{12!2!}
\]</span></p></li>
<li><p>例：方程 <span class="math inline">\(x_1+x_2+x_3+x_4=20\)</span>
的整数解的个数是多少？其中 <span class="math inline">\(x_1\geq 3,
x_2\geq 1, x_3\geq 0, x_4\geq 5\)</span></p>
<p>作变量代换：<span class="math inline">\(y_1=x_1-3， y_2=x_2-1，
y_3=x_3，y_4=x_4-5\)</span>，那么，得到方程：$ y_1+y_2+y_3+y_4=11$ <span
class="math display">\[
\left(
\begin{matrix}
11+4-1 \\
11
\end{matrix}
\right)=
\left(
\begin{matrix}
14 \\
11
\end{matrix}
\right)
\]</span></p></li>
<li><p>例（出现次数下界约束）：令 <span class="math inline">\(S＝{12
\cdot a, 12 \cdot b, 12 \cdot c }\)</span>。求 <span
class="math inline">\(S\)</span> 的使得 <span
class="math inline">\(3\)</span> 个元素都至少出现一次的 <span
class="math inline">\(12\)</span> - 组合个数。</p>
<ul>
<li>令 <span class="math inline">\(y_i = x_i -
1\)</span>，求非负整数解，套用公式</li>
</ul></li>
<li><p>上界约束：用其他方法做就行，不必拘泥这一章知识</p></li>
</ul></li>
</ul>
<h4 id="x其它一些题目">2.x：其它，一些题目</h4>
<ul>
<li><p>把 <span class="math inline">\(2n\)</span> 个人分成 <span
class="math inline">\(n\)</span> 组，每组 <span
class="math inline">\(2\)</span> 人，有多少分法？</p>
<p>等价为分组问题，相当于将 <span class="math inline">\(2n\)</span>
个不同球投入 $n $ 个相同的盒子中，每个盒子 <span
class="math inline">\(2\)</span> 个。【有点像定理2.4.2除以 <span
class="math inline">\(n!\)</span> 的变体】 <span class="math display">\[
\dfrac{2n!}{(2!)^n \cdot n!}=\dfrac{2n!}{2^n \cdot n!}
\]</span></p></li>
<li><p><strong>不相邻选取问题：</strong>从 <span
class="math inline">\(\{1, 2, \dots, n\}\)</span> 中取出 <span
class="math inline">\(r\)</span> 个不相邻的数，这样的组合有多少种？</p>
<p><span class="math inline">\(\left( \begin{matrix} n-r+1 \\ r
\end{matrix} \right)\)</span> 种，相当于往 $n-r $ 个数的 <span
class="math inline">\(n-r+1\)</span> 个间隔里插入 <span
class="math inline">\(r\)</span>
个<strong>被选取的数</strong>作为“隔板”</p></li>
</ul>
<h3 id="第3章-鸽巢原理"><strong>第3章 鸽巢原理</strong></h3>
<blockquote>
<p>证明存在性的一种主要手段</p>
</blockquote>
<h4 id="鸽巢原理的简单形式">3.1 鸽巢原理的简单形式</h4>
<ul>
<li><p>例：证明，如果从 <span class="math inline">\({1, 2, …,
2n}\)</span> 中任意选择 <span class="math inline">\(n+1\)</span>
个不同的整数，那么一定存在两个整数，它们之间差为 $ 1$。</p>
<p>将集合 <span class="math inline">\(\{1, 2, \dots ,2n\}\)</span>
划分成 <span class="math inline">\(n\)</span> 个子集 <span
class="math inline">\(S_1, S_2, \dots , S_n\)</span>，其中 <span
class="math inline">\(S_n = \{2i-1, 2i\}, i = 1, 2, \dots
,n\)</span></p>
<p>设选择的 <span class="math inline">\(n+1\)</span> 个整数为 $ a_1&lt;
a_2 &lt;…&lt;a_{n+1}$。令 <span class="math inline">\(b_1=a_1+1,
b_2=a_2+1, …, b_{n+1} = a_{n+1} +1\)</span>。此 $ 2n+2$
个数中至少有一对数相等，由于 <span class="math inline">\(a_1, \dots,
a_n\)</span> 互不相等，且 <span class="math inline">\(b_1, \dots
,b_n\)</span> 互不相等。因此存在一对 <span class="math inline">\(b_j =
a_j + 1\)</span> 与 <span class="math inline">\(a_k\)</span> 相等 <span
class="math inline">\((j \ne k)\)</span></p>
<ul>
<li>扩展：从 <span class="math inline">\(1,2, \dots, kn\)</span>
中任意选择 <span class="math inline">\(n+1\)</span> 个，则存在差为 <span
class="math inline">\(k-1\)</span></li>
</ul></li>
<li><p>例：证明，在 <span class="math inline">\(m\)</span> 个正整数
<span class="math inline">\(a_1, a_2, …, a_m\)</span> 中，存在 <span
class="math inline">\(0\leq k&lt; l \leq m\)</span>，使得 <span
class="math inline">\(a_{k+1}+ a_{k+2}+ …+a_l\)</span> 能够被 <span
class="math inline">\(m\)</span> 整除。</p>
<p>证：考虑 <span class="math inline">\(m\)</span> 个和（<span
class="math inline">\(s_m\)</span> 是正整数的前 <span
class="math inline">\(n\)</span> 项和）： <span class="math display">\[
s_1=a_1, s_2=a_1+a_2, s_3=a_1+a_2+a_3, …, s_m=a_1+a_2+…+a_m
\]</span></p>
<ul>
<li><p>若以上和中有一个能被 <span class="math inline">\(m\)</span>
整除，则结论成立；</p>
<blockquote>
<p>这是从头开始的部分和</p>
</blockquote></li>
<li><p>否则设 <span class="math inline">\(r_1, r_2, \dots ,r_n\)</span>
为 <span class="math inline">\(s_1, s_2, \dots ,s_n\)</span> 除以 <span
class="math inline">\(m\)</span> 的非零余数，则 <span
class="math inline">\(1 \leq r_i \leq m-1, i = 1, \dots
,m\)</span>。由鸽巢原理，存在 <span class="math inline">\(r_l = r_k, l
&gt; k\)</span>，则 <span class="math inline">\(a_{k+1} + a_{k+2} +
\dots + a_l\)</span> 能被 <span class="math inline">\(m\)</span>
整除</p>
<blockquote>
<p>这是从中间开始的部分和</p>
</blockquote></li>
</ul></li>
<li><p>例：从整数 <span class="math inline">\(1, 2, …，200\)</span>
中选取 <span class="math inline">\(101\)</span>
个整数。证明所选的数中存在两个整数，使得其中一个是另一个的因子。</p>
<p>证：对于 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(200\)</span> 间的整数 <span
class="math inline">\(n\)</span>，<span class="math inline">\(n\)</span>
可写作以下形式：<span class="math inline">\(n=2^k \times
a\)</span>（其中 <span class="math inline">\(a\)</span> 是 <span
class="math inline">\(1, 2, …, 200\)</span> 内的奇数）</p>
<p>由于要选取 <span class="math inline">\(101\)</span> 个整数，而 <span
class="math inline">\(200\)</span> 内只有 <span
class="math inline">\(100\)</span> 个奇数，由鸽巢原理知必存在两个整数
<span class="math inline">\(n_1\)</span> 与 <span
class="math inline">\(n_2\)</span>
写作上式形式后，两数中的奇数因子相等，均为 <span
class="math inline">\(b\)</span>。 假设 <span
class="math inline">\(n_1=2^{k1} \times b, n_2=2^{k2} \times
b\)</span>，其中 <span class="math inline">\(b\)</span> 是 <span
class="math inline">\(1, 2, …, 200\)</span> 内的奇数。显然，当 <span
class="math inline">\(k_1 \geq k_2\)</span> 时，<span
class="math inline">\(n_2\)</span> 整除 <span
class="math inline">\(n_1\)</span>；否则 <span
class="math inline">\(n_1\)</span> 整除 <span
class="math inline">\(n_2\)</span>。</p></li>
<li><p>例：某厂在五年期间的每一个月里至少试制一种新产品，每年最多试制
<span class="math inline">\(19\)</span>
种新产品。试证明：一定存在连续几个月，恰好试制 <span
class="math inline">\(24\)</span> 种新产品。</p>
<p>证：设五年间每个月新产品数分别为 <span class="math inline">\(a_1,
a_2, \dots , a_{59}, a_{60}\)</span>。构造出数列 <span
class="math inline">\(a_n\)</span> 的前 <span
class="math inline">\(n\)</span> 项和的数列 <span
class="math inline">\(s_1, s_2, \dots , s_{59}, s_{60}\)</span>，则有：
<span class="math display">\[
1≤a_1=s_1&lt;s_2&lt;…&lt;s_{59}&lt;s_{60} \leq 19 \times 5=95
\]</span> 而序列 <span class="math inline">\(s_1+24, s_2+24, \dots ,
s\_{59}+24, s_{60}+24\)</span> 也是一个严格递增序列： <span
class="math display">\[
25≤s_1+24&lt;s_2+24&lt; \dots &lt;s_{59}+24&lt;s-{60}+24 ≤95+24=119
\]</span> 这 <span class="math inline">\(120\)</span> 个数都在区间 <span
class="math inline">\([1,119]\)</span>
内，根据鸽巢原理，必定存在两个数相等</p>
<p>由于 <span class="math inline">\(s_1, s_2, \dots, s_{60}\)</span> 与
<span class="math inline">\(s_1 + 24, s_2 + 24, \dots, s_{60} +
24\)</span> 均为严格单调的，因此必然存在一个 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span>，使得 <span class="math inline">\(s_i =
s_j + 24\)</span> ，因此在第 <span class="math inline">\(j+1\)</span>
个月到第 <span class="math inline">\(i\)</span>
个月的几个月时间里恰好试制了 <span class="math inline">\(24\)</span>
种新产品<strong>（解释含义）</strong></p></li>
</ul>
<p><strong>几何问题：</strong></p>
<ul>
<li><p>例：确定一个整数 <span
class="math inline">\(n_k\)</span>，使得如果在边长为 <span
class="math inline">\(1\)</span> 的等边三角形中任意选择 <span
class="math inline">\(n_k\)</span> 个点，一定存在 <span
class="math inline">\(2\)</span> 个点，其距离至多为 <span
class="math inline">\(\dfrac{1}{k}\)</span></p>
<ul>
<li>解：<span class="math inline">\(n_k = k^2 + 1\)</span></li>
<li>证：将每边均分为 <span class="math inline">\(k\)</span> 份，共有
<span class="math inline">\(k^2\)</span>
个区域，落在任意一个部分中的两点之间的距离至多为 <span
class="math inline">\(\dfrac{1}{k}\)</span>，由鸽巢原理知 <span
class="math inline">\(n_k = k^2 + 1\)</span></li>
</ul></li>
<li><p>例（一道数值计算题，比较暴力，估计不会考）：在直径为 <span
class="math inline">\(5\)</span> 的圆内任意给定 <span
class="math inline">\(10\)</span> 个点，证明存在两点距离小于 <span
class="math inline">\(2\)</span></p>
<ul>
<li>证：<img src="Images\Circle.png" alt="Circle" style="zoom:33%;" /></li>
</ul></li>
<li><p>例：将一个矩形分成 <span class="math inline">\(4\)</span> 行
<span class="math inline">\(19\)</span> 列的网格，每个单元格涂 <span
class="math inline">\(3\)</span> 种颜色当中的 <span
class="math inline">\(1\)</span>
种颜色，证明：无论怎样涂色，必有一个由单元格构成的矩形的 <span
class="math inline">\(4\)</span> 个角上的格子颜色相同</p>
<ul>
<li>思路：两次鸽巢原理</li>
<li>每一列 <span class="math inline">\(4\)</span> 行但只有 <span
class="math inline">\(3\)</span>
个颜色，由鸽巢原理，必有两个单元格颜色相同，其位置组合共 <span
class="math inline">\(\left( \begin{matrix} 4 \\ 2 \end{matrix} \right)
= 6\)</span> 种，<span class="math inline">\(3\)</span> 种颜色下共 <span
class="math inline">\(18\)</span> 种，由鸽巢原理，得证</li>
</ul></li>
<li><p>例：证明在 <span class="math inline">\(n+2\)</span>
个任选的正整数中，存在两个数，或者其差能被 <span
class="math inline">\(2n\)</span> 整除，或者其和能被 <span
class="math inline">\(2n\)</span> 整除。</p>
<p>证明：已知所有正整数除以 <span class="math inline">\(2n\)</span>
的余数只能取值 <span class="math inline">\(0, 1, 2, …,
2n-1\)</span>。</p>
<p>把以上余数构造以下 <span class="math inline">\(n+1\)</span>
个子集：<span class="math inline">\(\{1, 2n-1\}, \{2, 2n-2\}, …, \{n-1,
n+1\}, \{n, n\}, \{0, 0\}\)</span>。</p>
<p>任选 <span class="math inline">\(n+2\)</span>
个正整数，由鸽巢原理知，一定存在两个数，其除以 <span
class="math inline">\(2n\)</span> 的余数来自同一个子集 <span
class="math inline">\(A\)</span>。</p>
<ul>
<li><p>若 <span class="math inline">\(A\)</span> 是前 <span
class="math inline">\(n-2\)</span> 个子集中一个，则这两个数的和能被
<span class="math inline">\(2n\)</span> 整除；</p></li>
<li><p>若 <span class="math inline">\(A\)</span> 是最后 <span
class="math inline">\(2\)</span> 个子集中一个，则这两个数的差能被 <span
class="math inline">\(2n\)</span> 整除。</p></li>
</ul></li>
<li><p>例：一间房屋内有 <span class="math inline">\(10\)</span>
个人，他们当中没有人超过 <span class="math inline">\(60\)</span>
岁（年龄只能以整数给出)，但又至少不低于 <span
class="math inline">\(1\)</span>
岁。证明：总能找出两组人（两组人中不含相同的人 ），使得年龄和相同。</p>
<p>证：<span class="math inline">\(10\)</span> 个人构成的子集一共是
<span class="math inline">\(2^{10}=1024\)</span>
个，去除掉空集与全集，一共 <span class="math inline">\(1022\)</span>
个子集可以是找出的两组人中的一组。由于这些子集的年龄和最小为 <span
class="math inline">\(1\)</span> 岁，且不超过 <span
class="math inline">\(60 \times 9= 540\)</span>
岁。因此，由鸽巢原理知，至少有两组人的年龄和相同，<strong>去除这两组人的相同人后</strong>，所得的两组人满足题目要求</p>
<ul>
<li>如果改成 <span class="math inline">\(9\)</span> 个人，则下面记得改成
<span class="math inline">\(480\)</span></li>
</ul></li>
<li><p>其他问题和作业题整理——todo</p></li>
</ul>
<h4 id="鸽巢原理的加强形式">3.2 鸽巢原理的加强形式</h4>
<ul>
<li><p><strong>定理3.2.1 ：</strong>令 <span class="math inline">\(q_1,
q_2 , \dots, q_n\)</span> 为正整数。若将 <span
class="math inline">\(q_1+q_2+ \dots +q_n - n+1\)</span> 个物体放进
<span class="math inline">\(n\)</span> 个盒子内，那么，</p>
<p>或者第 <span class="math inline">\(1\)</span> 个盒子至少含有 <span
class="math inline">\(q_1\)</span> 个物体，</p>
<p>或者第 <span class="math inline">\(2\)</span> 个盒子至少含有 <span
class="math inline">\(q_2\)</span> 个物体，</p>
<p>…，</p>
<p>或者第 <span class="math inline">\(n\)</span> 个盒子至少含有 <span
class="math inline">\(q_n\)</span> 个物体</p>
<blockquote>
<p>当然，也就是说不会出现每个盒子的物体数少于上述数字的情况</p>
</blockquote>
<blockquote>
<p>令 <span class="math inline">\(q_1 = q_2 = \dots = q_n =
2\)</span>，即为鸽巢原理的简单形式</p>
</blockquote></li>
<li><p><strong>平均原理：</strong>如果 <span
class="math inline">\(m\)</span> 个物体放入 <span
class="math inline">\(n\)</span> 个盒子，则至少有一个盒子含有 <span
class="math inline">\(\lceil m/n\rceil\)</span> 个或更多的物体</p></li>
<li><p>例（判断满足条件的最小物品总数）：一篮水果装有苹果、梨和桔子。为了保证或者至少
<span class="math inline">\(8\)</span> 个苹果，或者至少 <span
class="math inline">\(6\)</span> 个梨或者至少 <span
class="math inline">\(9\)</span>
个桔子，则放入篮子中的水果的最少件数是多少？</p>
<p><span class="math inline">\(8+6+9-3+1=21\)</span> 件</p>
<p><strong>（尽量说明下反面）</strong>：当放入篮子的水果数为 <span
class="math inline">\(20\)</span> 时，可能出现 <span
class="math inline">\(7\)</span> 个苹果，<span
class="math inline">\(5\)</span> 个香蕉和 <span
class="math inline">\(8\)</span> 个桔子的情形，不满足题目要求</p></li>
<li><p>例：证明从任意给出的 <span class="math inline">\(5\)</span>
个正整数中必能选出 <span class="math inline">\(3\)</span>
个数，它们的和能被 <span class="math inline">\(3\)</span> 整除。</p>
<p>任意正整数除以 <span class="math inline">\(3\)</span> 的余数只能为
<span class="math inline">\(0,1,2\)</span>。</p>
<p>设 <span class="math inline">\(A\)</span> 为任意给出的 <span
class="math inline">\(5\)</span> 个正整数的集合。设 <span
class="math inline">\(t_0, t_1, t_2\)</span> 为 <span
class="math inline">\(A\)</span> 中除以 <span
class="math inline">\(3\)</span> 余数分别为 <span
class="math inline">\(0, 1, 2\)</span> 的数的个数。</p>
<ul>
<li><p>若 <span class="math inline">\(t_0, t_1, t_2\)</span> 均不为
<span class="math inline">\(0\)</span>， 则一定有三个数除以 <span
class="math inline">\(3\)</span> 的余数分别为 <span
class="math inline">\(0, 1, 2\)</span>，则这三个数的和能被 <span
class="math inline">\(3\)</span> 整除。</p></li>
<li><p>若 <span class="math inline">\(t_0, t_1, t_2\)</span>
中至少有一个为 <span class="math inline">\(0\)</span>，不妨设 <span
class="math inline">\(t_0=0\)</span>，则 <span
class="math inline">\(t_1+t_2=5\)</span>。由平均原理知，至少有 <span
class="math inline">\(\lceil 5/2\rceil = 3\)</span> 个数除以 <span
class="math inline">\(3\)</span> 的余数相同（全为 <span
class="math inline">\(1\)</span> 或全为 <span
class="math inline">\(2\)</span>），则这三个数的和能被 <span
class="math inline">\(3\)</span> 整除。</p></li>
</ul></li>
<li><p>例：证明每个由<span
class="math inline">\(n^2+1\)</span>个实数构成的序列：<span
class="math inline">\(a_1, a_2, \dots a_{n^2 +
1}\)</span>，或者含有长度为 <span class="math inline">\(n+1\)</span>
的递增子序列，或者含有长度为 <span class="math inline">\(n+1\)</span>
的递减子序列。</p>
<p>证：假设不存在长度为 <span class="math inline">\(n+1\)</span>
的递增子序列，只需构造一个长度为 <span
class="math inline">\(n+1\)</span> 的递减子序列。 设 <span
class="math inline">\(l_k\)</span> 是以 <span
class="math inline">\(a_k\)</span> 为起始的最长递增子序列长度，<span
class="math inline">\(k =1, 2, …，n^2+1\)</span>，则对 <span
class="math inline">\(\forall k\)</span> 有 <span
class="math inline">\(1 \leq l_k \leq n\)</span>。对序列 <span
class="math inline">\(l_1, l_2, …,l_{n^2 + 1}\)</span>
运用鸽巢原理加强形式，一定存在 <span class="math inline">\(\lceil
(n^2+1)/n \rceil =n+1\)</span> 个 <span
class="math inline">\(l_i\)</span> 相等。 设 <span
class="math display">\[
l_{k_1}=l_{k_2}= \dots =l_{k_{n+1}}
\]</span> 其中 <span class="math inline">\(1 \leq k_1&lt; k_2&lt;…&lt;
k_{n+1} \leq n^2+1\)</span></p>
<p>(下面证明 <span class="math inline">\(a_{k_1},a_{k_2}, \dots
,a_{k_{n+1}}\)</span> 是长度为 <span class="math inline">\(n+1\)</span>
的递减序列) 反证：假设存在 <span class="math inline">\(k_i,
k_{i+1}\)</span>，使得 <span
class="math inline">\(a_{k_i}&lt;a_{k_{i+1}}\)</span>，把 <span
class="math inline">\(a_{k_i}\)</span> 加到以 <span
class="math inline">\(a_{k_{i+1}}\)</span>
开始的最长递增子序列，则构成了以 <span
class="math inline">\(a_{k_i}\)</span> 开始的递增子序 列，得 <span
class="math inline">\(l_{k_i}&gt;l_{k_{i+1}}\)</span>，与 <span
class="math inline">\(l_{k_i} = l_{k_{i+1}}\)</span> 矛盾！</p>
<blockquote>
<p>证明不是递增就是递减</p>
</blockquote>
<p>todo 方阵排队问题</p></li>
</ul>
<h4 id="ramsey-定理">3.3 <span class="math inline">\(Ramsey\)</span>
定理</h4>
<ul>
<li><p><strong><span class="math inline">\(Ramsey\)</span>
定理：</strong></p>
<ul>
<li>通俗实例： 在 <span class="math inline">\(6\)</span> 个人中，或者有
$ 3$ 个人，他们中每两个人都互相认识；或者有 <span
class="math inline">\(3\)</span>
个人，他们中的每两个人都彼此不认识。</li>
<li>给图 <span class="math inline">\(K_6\)</span>
的边任意着红色、蓝色后，一定存在一个红色 <span
class="math inline">\(K_3\)</span> 或 蓝色<span
class="math inline">\(K_3\)</span>，记为<span class="math inline">\(K_6
\rightarrow K_3,K_3\)</span></li>
<li><span class="math inline">\(n\)</span> 阶完全图：用 <span
class="math inline">\(K_n\)</span> 表示平面上没有 <span
class="math inline">\(3\)</span> 点共线的 <span
class="math inline">\(n\)</span> 个顶点构成的一个完全图。</li>
</ul></li>
<li><p>证明：给图 <span class="math inline">\(K_6\)</span>
的边任意着红色、蓝色，一定存在一个红色 <span
class="math inline">\(K_3\)</span> 或蓝色 <span
class="math inline">\(K_3\)</span>，记为 <span class="math inline">\(K_6
\rightarrow K_3, K_3\)</span></p>
<p><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611105033290.png" alt="image-20230611105033290" style="zoom:33%;" /></p></li>
<li><p><strong>定理 3.3.1 (<span class="math inline">\(Ramsey\)</span>
定理) ：</strong>如果两个整数 <span class="math inline">\(m ≥ 2, n ≥
2\)</span>，则存在正整数 <span class="math inline">\(p\)</span>，使得
<span class="math inline">\(K_p \rightarrow K_m,K_n\)</span></p></li>
<li><p><strong><span class="math inline">\(Ramsey\)</span>
数：</strong><span class="math inline">\(Ramsey\)</span> 数 <span
class="math inline">\(r(m, n)\)</span> 是使 <span
class="math inline">\(K_p \rightarrow K_m,K_n\)</span> 成立的最小整数
<span class="math inline">\(p\)</span></p>
<ul>
<li><p>一定存在</p></li>
<li><p>对称性：<span class="math inline">\(r(m,n) =
r(n,m)\)</span></p></li>
<li><p>平凡的 <span class="math inline">\(Ramsey\)</span> 数：<span
class="math inline">\(r(2, n)=n, r(m,2)=m\)</span></p>
<blockquote>
<p>或者存在一条边是红色，或者所有边是蓝色</p>
</blockquote></li>
<li><p>推论：<span class="math inline">\(r(m, n) ≤ r(m-1, n) + r(m,
n-1)\)</span>。</p></li>
</ul></li>
<li><p><strong><span class="math inline">\(Ramsey\)</span>
定理推广：</strong>如果<span class="math inline">\(n_1, n_2,\dots,
n_l\)</span> 都是大于或等于 <span class="math inline">\(2\)</span>
的整数，则一定存在正整数 <span class="math inline">\(p\)</span>，使得
<span class="math display">\[
K_p \rightarrow K_{n_1},K_{n_2},\dots,K_{n_l}
\]</span> 满足以上条件的最小整数 <span class="math inline">\(p\)</span>
称为 <span class="math inline">\(Ramsey\)</span> 数。例如：<span
class="math inline">\(K_{17} \rightarrow
K_3,K_3,\dots,K_3\)</span></p></li>
<li><p>例：证明 <span class="math inline">\(r(3, 3, 3) \le 17\)</span>
todo</p></li>
</ul>
<h3 id="第4章-生成排列和组合"><strong>第4章 生成排列和组合</strong></h3>
<blockquote>
<p>排列生成算法：</p>
<ul>
<li>递归生成算法</li>
<li>邻位对换算法</li>
<li>从逆序生成排列算法
<ul>
<li>逆序相关知识</li>
<li>从最大数或最小数</li>
</ul></li>
</ul>
<p>组合生成算法：</p>
<ul>
<li>字典序</li>
<li>反射 <span class="math inline">\(Gray\)</span> 码
<ul>
<li>递归法</li>
<li>逐次法</li>
</ul></li>
<li>基于字典序的 <span class="math inline">\(r\)</span> -
组合生成算法</li>
</ul>
</blockquote>
<h4 id="生成排列">4.1 生成排列</h4>
<ul>
<li>递归生成算法</li>
<li>邻位对换算法：
<ul>
<li>可活动：箭头指向与其相邻但比它小的整数</li>
</ul></li>
<li>两种算法生成的排列顺序一致</li>
</ul>
<h4 id="排序中的逆序">4.2 排序中的逆序</h4>
<ul>
<li><p><strong>逆序：</strong>令 <span
class="math inline">\(i_1,i_2,\dots,i_n\)</span> 是集合 <span
class="math inline">\(\{1, 2,\dots, n\}\)</span> 的一个排列， 如果 <span
class="math inline">\(0\leq k &lt; l \leq n\)</span>， 且 <span
class="math inline">\(i_k &gt; i_l\)</span> , 称数对 <span
class="math inline">\((i_k, i_l)\)</span> 是排列的一个逆序。</p>
<ul>
<li><p>如，排列 <span class="math inline">\(31524\)</span> 的逆序为
<span class="math inline">\((3,1), (3,2), (5,2), (5,4)\)</span></p></li>
<li><p>唯一没有逆序的排列为 <span class="math inline">\(1 2 3 \dots
n\)</span></p></li>
</ul></li>
<li><p><strong>逆序数：</strong>对于 <span class="math inline">\(\{1,
2,\dots, n\}\)</span> 上的一个排列，逆序数 <span
class="math inline">\(a_j\)</span> 是<strong>第二元</strong>是 <span
class="math inline">\(j\)</span> 的逆序的数量，也即排列中先于整数 <span
class="math inline">\(j\)</span> 并大于 <span
class="math inline">\(j\)</span> 的整数的个数，度量 <span
class="math inline">\(j\)</span> 的反序程度。</p></li>
<li><p><strong>逆序列：</strong>令 <span
class="math inline">\(a_j\)</span> 表示排列 <span
class="math inline">\(i_1i_2,\dots,i_n\)</span> 中数 <span
class="math inline">\(j\)</span> 的逆序数， 称<span
class="math inline">\(a_1,a_2,\dots,a_n\)</span>为排列 <span
class="math inline">\(i_1i_2,\dots,i_n\)</span> 的逆序列</p>
<p>例如，排列 <span class="math inline">\(361245\)</span>。</p>
<p>逆序：<span class="math inline">\((3, 1) ,(3, 2), (6, 1),(6, 2), (6,
4) ,(6, 5)\)</span>。</p>
<p>逆序数：<span class="math inline">\(a_1=2, a_2=2, a_3=0, a_4=1,
a_5=1, a_6=0\)</span></p>
<p>逆序列：<span class="math inline">\(2 2 0 1 1 0\)</span></p></li>
<li><p>从逆序生成排列算法：</p>
<ol type="1">
<li><p>从最大数开始。已知 <span class="math inline">\(\{1, 2, …,
8\}\)</span> 的一个排列的逆序列为 <span class="math inline">\(5 3 4 0 2
1 1 0\)</span>，确定此排列。【每个数放在第“逆序数”个位置上】</p>
<ul>
<li>特点：相对位置固定，但是每个整数的位置要到最后才能确定</li>
</ul>
<table>
<thead>
<tr class="header">
<th>当前放置数</th>
<th>当前排列</th>
<th>逆序数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>8：</td>
<td>8</td>
<td>0</td>
</tr>
<tr class="even">
<td>7：</td>
<td>8 7</td>
<td>1</td>
</tr>
<tr class="odd">
<td>6：</td>
<td>8 6 7</td>
<td>1</td>
</tr>
<tr class="even">
<td>5：</td>
<td>8 6 5 7</td>
<td>2</td>
</tr>
<tr class="odd">
<td>4：</td>
<td>4 8 6 5 7</td>
<td>0</td>
</tr>
<tr class="even">
<td>3：</td>
<td>4 8 6 5 3 7</td>
<td>4</td>
</tr>
<tr class="odd">
<td>2：</td>
<td>4 8 6 2 5 3 7</td>
<td>3</td>
</tr>
<tr class="even">
<td>1：</td>
<td>4 8 6 2 5 1 3 7</td>
<td>5</td>
</tr>
</tbody>
</table></li>
<li><p>从最小数开始。仍上例。【每个数放在第“逆序数+1”个<strong>空</strong>位置上】</p>
<table>
<thead>
<tr class="header">
<th>当前放置数</th>
<th>当前排列</th>
<th>逆序数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1：</td>
<td>X X X X X 1 X X</td>
<td>5</td>
</tr>
<tr class="even">
<td>2：</td>
<td>X X X 2 X 1 X X</td>
<td>3</td>
</tr>
<tr class="odd">
<td>3：</td>
<td>X X X 2 X 1 3 X</td>
<td>4</td>
</tr>
<tr class="even">
<td>4：</td>
<td>4 X X 2 X 1 3 X</td>
<td>0</td>
</tr>
<tr class="odd">
<td>5：</td>
<td>4 X X 2 5 1 3 X</td>
<td>2</td>
</tr>
<tr class="even">
<td>6：</td>
<td>4 X 6 2 5 1 3 X</td>
<td>1</td>
</tr>
<tr class="odd">
<td>7：</td>
<td>4 X 6 2 5 1 3 7</td>
<td>1</td>
</tr>
<tr class="even">
<td>8：</td>
<td>4 8 6 2 5 1 3 7</td>
<td>0</td>
</tr>
</tbody>
</table></li>
</ol></li>
<li><p>逆序个数为奇数的排列称为奇排列；
逆序个数为偶数的排列称为偶排列。</p></li>
<li><p><span class="math inline">\(15
Puzzles\)</span>：用逆序数证明无解：左右移动逆序数的和不变，上下移动逆序数的和
<span class="math inline">\(+3\)</span></p></li>
</ul>
<h4 id="生成组合">4.3 生成组合</h4>
<ul>
<li><p><span class="math inline">\(n\)</span> 元集合 <span
class="math inline">\(S=\{x_{n-1},x_{n-2}, \dots, x_0\}\)</span>
的组合与长度为 <span class="math inline">\(n\)</span>
的二进制数一一对应（注意到两者个数均为 <span
class="math inline">\(2^n\)</span>）</p>
<ul>
<li>对应方法：这个整数的二进制表示 <span
class="math inline">\(1\)</span> 所在的位置的元素包含在组合中</li>
<li>如：<span class="math inline">\(29 \in [1, 2^7]\)</span>
的二进制表示 <span class="math inline">\(0011101\)</span>，则 <span
class="math inline">\(29\)</span> 对应的组合为 <span
class="math inline">\(\{x_4, x_3, x_2, x_0\}\)</span></li>
</ul></li>
<li><p>字典序生成算法</p>
<ul>
<li><p>初始：<span class="math inline">\(a_{n-1} \dots a_1a_0 = 0 \dots
00\)</span></p></li>
<li><p>当 <span class="math inline">\(a_{n-1} \dots a_1a_0 \neq 1 \dots
11\)</span> 时，求出使得 <span class="math inline">\(a_j = 0\)</span>
的最小整数 <span class="math inline">\(j\)</span>，用 <span
class="math inline">\(1\)</span> 替换 <span
class="math inline">\(a_j\)</span> 并用 <span
class="math inline">\(0\)</span> 替换每个 <span
class="math inline">\(a_{j-1}, \dots a_1, a_0\)</span></p>
<blockquote>
<p>把最小的 <span class="math inline">\(1\)</span> 找出来，后面的全换成
<span class="math inline">\(0\)</span></p>
</blockquote></li>
<li><p>例1：求组合 <span class="math inline">\(\{x_6, x_4, x_2, x_1,
x_0\}\)</span> 的下一个组合</p>
<ul>
<li><span class="math inline">\(1010111 + 1 =
1011000\)</span>，对应组合为 <span class="math inline">\(\{x_6, x_4,
x_3\}\)</span></li>
</ul></li>
<li><p>例2：<span class="math inline">\(S = \{x_6, x_5, \dots, x_1,
x_0\}\)</span> 的哪个子集是子集列表中的第 <span
class="math inline">\(108\)</span> 个子集？</p>
<ul>
<li>注：位置从 <span class="math inline">\(0\)</span> 开始，第 <span
class="math inline">\(108\)</span> 个子集对应 <span
class="math inline">\(108\)</span>，<span
class="math inline">\(108\)</span> 二进制数为 <span
class="math inline">\(1101100\)</span>，则对应子集为 <span
class="math inline">\(\{x_6, x_5, x_3, x_2\}\)</span></li>
</ul></li>
</ul></li>
<li><p>反射 <span class="math inline">\(Gray\)</span>
码序生成算法：特点为相邻的组合间仅相差一个元素。生成方法：前面补0，1；之后折叠</p>
<blockquote>
<p>对应 <span class="math inline">\(n\)</span> 维空间点坐标</p>
</blockquote>
<ul>
<li>递归生成：见图
<ul>
<li><img src="Images\RecursiveGray.png" alt="RecursiveGray" style="zoom: 33%;" /></li>
</ul></li>
<li>逐次生成：整体思路——每次改变 <span
class="math inline">\(\sigma\)</span> 的奇偶性
<ul>
<li>初始：<span class="math inline">\(a_{n-1} \dots a_1a_0 = 0 \dots
00\)</span></li>
<li>当 <span class="math inline">\(a_{n-1} \dots a_1a_0 \neq 1 \dots
00\)</span> 时，计算 <span class="math inline">\(\sigma(a_{n-1} \dots
a_1 a_0) = a_{n-1} + \dots + a_1 + a_0\)</span>，如果结果为偶数，则改变
<span class="math inline">\(a_0\)</span>；否则确定使得 <span
class="math inline">\(a_j = 1\)</span> 且对于所有 <span
class="math inline">\(i &lt; j\)</span>$， $<span
class="math inline">\(a_i = 0\)</span> 的最小整数 <span
class="math inline">\(j\)</span>，改变 <span
class="math inline">\(a_{j+1}\)</span></li>
</ul></li>
</ul></li>
<li><p>可由归纳法证明二者生成相同顺序的 <span
class="math inline">\(n\)</span> 阶反射 <span
class="math inline">\(Gray\)</span> 码</p></li>
<li><p>确定 <span class="math inline">\(n\)</span> 元组在 <span
class="math inline">\(Gray\)</span>
码序表中的准确位置：<img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230608105305919.png" alt="image-20230608105305919" style="zoom: 33%;" /></p></li>
</ul>
<h4 id="生成-r---组合">4.4 生成 <span class="math inline">\(r\)</span> -
组合</h4>
<ul>
<li><p>先于：若 <span class="math inline">\(A \cup B \setminus A \cap
B\)</span> 中的最小整数属于 <span class="math inline">\(A\)</span>，则称
<span class="math inline">\(A\)</span> 先于 <span
class="math inline">\(B\)</span></p>
<blockquote>
<p>属于 <span class="math inline">\(A \cup B\)</span>， 但不同时属于
<span class="math inline">\(A \cap B\)</span></p>
</blockquote></li>
<li><p>直接后继求解算法：找出满足 <span
class="math inline">\(a_i&lt;n\)</span>，且 <span
class="math inline">\(a_i+1\)</span> 不在 <span
class="math inline">\(\{a_1,…, a_r\}\)</span> 中的最大的 <span
class="math inline">\(i\)</span>，记为 <span
class="math inline">\(k\)</span>，在字典序中 <span
class="math inline">\(a_1a_2…a_r\)</span> 的直接后继是<span
class="math inline">\(a_1a_2…a_{k-1} (a_k+1) (a_k+2)…(a_k+r – k
+1)\)</span></p></li>
<li><p><span class="math inline">\(r\)</span> 子集的生成算法：从 <span
class="math inline">\(12 \dots r\)</span>
开始，逐个列出直接后继，直到得到 <span
class="math inline">\((n-r+1)(n-r+2) \dots n\)</span></p></li>
</ul>
<h3 id="第5章-二项式系数"><strong>第5章 二项式系数</strong></h3>
<blockquote>
<p>讨论二项式系数相关等式和性质</p>
</blockquote>
<h4 id="pascal-三角形">5.1 <span class="math inline">\(Pascal\)</span>
三角形</h4>
<ul>
<li><p><strong>定理5.1.1(<span class="math inline">\(Pascal\)</span>
公式)：</strong>对于满足 <span class="math inline">\(1 \leq k \leq
n\)</span> 的所有整数 <span class="math inline">\(k\)</span> 和 <span
class="math inline">\(n\)</span>，有： <span class="math display">\[
\left(\begin{matrix}
n \\ k
\end{matrix}\right)=
\left(\begin{matrix}
n-1 \\ k
\end{matrix}\right)+
\left(\begin{matrix}
n-1 \\ k-1
\end{matrix}\right)
\]</span></p>
<ul>
<li>组合证明同前，此处从略</li>
<li><span class="math inline">\(Pascal\)</span>
三角形：<img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230608111421566.png" alt="image-20230608111421566" style="zoom:33%;" /></li>
<li>行列套用定义即可，没有很强的几何直观性</li>
<li>另一种解释：路径移动</li>
<li>可以证明若干项求和的等式</li>
</ul></li>
</ul>
<h4 id="二项式定理">5.2 二项式定理</h4>
<ul>
<li><p><strong>定理5.2.1：</strong>令 <span
class="math inline">\(n\)</span> 是一个正整数, 那么对于所有的 <span
class="math inline">\(x, y\)</span> 有： <span class="math display">\[
(x+y)^n=\sum_{k=0}^n \left( \begin{matrix} n \\ k \end{matrix} \right)
x^{n-k} y^k
\]</span></p>
<ul>
<li>可以对换 <span class="math inline">\(x, y\)</span>，对换 <span
class="math inline">\(n\)</span> 和 <span
class="math inline">\(n-k\)</span> 得到等价形式</li>
</ul></li>
<li><p><strong>二项式系数的其它等式：</strong> <span
class="math display">\[
k \left( \begin{matrix} n \\ k \end{matrix} \right) = n \left(
\begin{matrix} n-1 \\ k-1 \end{matrix} \right)
\]</span></p>
<ul>
<li><p><span class="math inline">\(n\)</span> 个人中选 <span
class="math inline">\(k\)</span> 人组成足球队，其中 <span
class="math inline">\(1\)</span> 人为队长，有多少种不同选法？</p>
<p>1、先选足球队，然后从足球队中选队长；</p>
<p>2、先选队长，再在剩下的 <span class="math inline">\(n-1\)</span>
人中选 <span class="math inline">\(k-1\)</span> 个足球队员。</p></li>
</ul>
<p><span class="math display">\[
\sum_{k=0}^n \left( \begin{matrix} n \\ k \end{matrix} \right)^2 =
\left( \begin{matrix} 2n \\ n \end{matrix} \right) (n \geq 0)
\]</span></p>
<ul>
<li><p>设 <span class="math inline">\(A={1, 2, …, n}, B={n+1, n+2, …,
2n}\)</span>，<span class="math inline">\(A \cup B={1, 2, …,
2n}\)</span>。令 <span class="math inline">\(S＝A\cup B\)</span>，<span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 是两个不相交的 <span
class="math inline">\(n\)</span> 个元素集合.</p>
<ul>
<li><p><span class="math inline">\(S\)</span> 的 <span
class="math inline">\(n\)</span> - 组合数是<span
class="math inline">\(\left(\begin{matrix} 2n \\ n
\end{matrix}\right)\)</span></p></li>
<li><p>设 <span class="math inline">\(S\)</span> 的一个 <span
class="math inline">\(n\)</span> - 组合含有 <span
class="math inline">\(A\)</span> 的元素为 <span
class="math inline">\(k\)</span> 个，含有 <span
class="math inline">\(B\)</span> 的元素为 <span
class="math inline">\(n-k\)</span> 个，<span
class="math inline">\(k=0,1,…, n\)</span>。令 <span
class="math inline">\(C_k\)</span> 是含有 <span
class="math inline">\(k\)</span> 个 <span
class="math inline">\(A\)</span> 的元素的 <span
class="math inline">\(n\)</span> - 组合，则 <span
class="math inline">\(S\)</span> 的所有 <span
class="math inline">\(n\)</span> - 组合可划分为：<span
class="math inline">\(C_0, C_1,…, C_n\)</span>。有：</p></li>
</ul>
<p><span class="math display">\[
\left(\begin{matrix} 2n \\ n \end{matrix}\right) =
\left| C_0 \right| + \left| C_1 \right| + \dots + \left| C_n \right|
\]</span></p>
<p><span class="math display">\[
\left| C_k \right| =
\left(\begin{matrix} n \\ k \end{matrix}\right)
\left(\begin{matrix} n \\ n-k \end{matrix}\right) =
\left(\begin{matrix} n \\ k \end{matrix}\right) ^2
\]</span></p>
<p>得证。 <span class="math display">\[
\left(\begin{matrix} n \\ 0 \end{matrix}\right)-
\left(\begin{matrix} n \\ 1 \end{matrix}\right)+
\left(\begin{matrix} n \\ 2 \end{matrix}\right)+ \dots +
(-1)^n\left(\begin{matrix} n \\ n \end{matrix}\right)+ \dots = 0
\]</span></p></li>
<li><p>证明：</p>
<ul>
<li>方法一：令二项式公式中 <span class="math inline">\(x = 1, y =
-1\)</span></li>
<li>方法二：奇偶子集之和之差</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
\left(\begin{matrix} n \\ 0 \end{matrix}\right)+
\left(\begin{matrix} n \\ 2 \end{matrix}\right)+ \dots =
\left(\begin{matrix} n \\ 1 \end{matrix}\right)+
\left(\begin{matrix} n \\ 3 \end{matrix}\right)+ \dots = 2^{n-1}
\]</span></p>
<ul>
<li><p>证明</p>
<ul>
<li>方法一：偶数个元素的子集的个数 = 奇数个元素的子集的个数 = <span
class="math inline">\(\dfrac{1}{2}\)</span>总子集数。</li>
<li>方法二：<span class="math inline">\(x_1,…, x_{n-1}\)</span>
每个有两种选择，但前面的奇偶性决定了 <span
class="math inline">\(x_n\)</span> 只有一种选择（使得总元素个数为 奇数
或 偶数）</li>
</ul></li>
<li><p>例：证明以下等式： <span class="math display">\[
1 \left(\begin{matrix} n \\ 1 \end{matrix}\right)+
2 \left(\begin{matrix} n \\ 2 \end{matrix}\right)+ \dots +
n \left(\begin{matrix} n \\ n \end{matrix}\right) = n 2^{n-1}
\]</span></p>
<ul>
<li><p>利用选队长公式 <span class="math inline">\(k \left(
\begin{matrix} n \\ k \end{matrix} \right) = n \left( \begin{matrix} n-1
\\ k-1 \end{matrix} \right)\)</span> <span class="math display">\[
1 \left(\begin{matrix} n \\ 1 \end{matrix}\right) +
2 \left(\begin{matrix} n \\ 2 \end{matrix}\right) + \dots +
n \left(\begin{matrix} n \\ n \end{matrix}\right) =
n \left(\begin{matrix} n-1 \\ 0 \end{matrix}\right) +
n \left(\begin{matrix} n-1 \\ 1 \end{matrix}\right) + \dots +
n \left(\begin{matrix} n-1 \\ n-1 \end{matrix}\right) = n2^{n-1}
\]</span></p></li>
<li><p>求导法：对 <span class="math inline">\((1+x)^n = 1 +
\left(\begin{matrix} n \\ 1 \end{matrix}\right)x + \left(\begin{matrix}
n \\ 2 \end{matrix}\right)x^2 + \dots + \left(\begin{matrix} n \\ k
\end{matrix}\right)x^k + \dots + \left(\begin{matrix} n \\ n
\end{matrix}\right)x^n\)</span>，左右同求导数，取 <span
class="math inline">\(x = 1\)</span></p></li>
</ul></li>
<li><p>例：<img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611115437992.png" alt="image-20230611115437992" style="zoom:33%;" /></p></li>
<li><p>组合定义扩展</p>
<ul>
<li><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230608114453735.png" alt="image-20230608114453735" style="zoom:33%;" /></li>
</ul></li>
</ul>
<h4 id="二项式系数的单峰性">5.3 二项式系数的单峰性</h4>
<ul>
<li><p><strong>定理5.3.1：</strong>对 <span
class="math inline">\(n\)</span> 是奇数偶数的单峰性讨论</p>
<ul>
<li>证明：考虑相邻两项的商</li>
</ul></li>
<li><p><strong>链与反链：</strong>令 <span
class="math inline">\(S\)</span> 是 <span
class="math inline">\(n\)</span> 个元素的集合，<span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的<strong>子集</strong>的集合</p>
<ul>
<li><p><strong>链：</strong>若 <span class="math inline">\(C\)</span>
中任意两个不同的子集都存在包含关系，则称 <span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的一个链。</p>
<ul>
<li>对 <span class="math inline">\(\forall S_1, S_2 \in C\)</span>，且
<span class="math inline">\(S_1 \ne S_2\)</span>，则 <span
class="math inline">\(S_1 \subset S_2\)</span> 或 <span
class="math inline">\(S_2 \subset S_1\)</span></li>
</ul></li>
<li><p><strong>反链：</strong>若 <span class="math inline">\(C\)</span>
中任意一个子集都不包含在其他子集内，
即任意两个不同的子集都不存在包含关系，则称 <span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的一个反链。</p>
<ul>
<li>一个构造反链的方法：取 <span class="math inline">\(A_k\)</span> 为
<span class="math inline">\(S\)</span> 所有的 <span
class="math inline">\(k\)</span> 子集的集合</li>
</ul></li>
<li><p><strong>链与反链的关系：</strong></p>
<ul>
<li><p><span class="math inline">\(S\)</span> 上的一条链最多只能包含
<span class="math inline">\(S\)</span>
的任意一条反链中的一个子集</p></li>
<li><p><span class="math inline">\(S\)</span> 上的一条反链最多只能包含
<span class="math inline">\(S\)</span> 的任意一条链中的一个子集</p>
<blockquote>
<p>可以有 <span class="math inline">\(0\)</span> 或 <span
class="math inline">\(1\)</span> 个公共元素</p>
</blockquote></li>
<li><p>反证法：设 <span class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的一条链，<span
class="math inline">\(A\)</span> 是 <span
class="math inline">\(S\)</span> 的一条反链。若 <span
class="math inline">\(C\)</span> 包含 <span
class="math inline">\(A\)</span> 中两个子集 <span
class="math inline">\(S_1, S_2\)</span>，则 <span
class="math inline">\(S_1, S_2\)</span> 不存在包含关系，与 <span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的一条链矛盾</p></li>
</ul></li>
<li><p><strong>链与反链的推广：</strong></p>
<ul>
<li>极大元、极小元</li>
</ul></li>
<li><p>一些证明题：todo</p></li>
</ul></li>
<li><p><strong>定理 5.3.3：</strong>设 <span
class="math inline">\(S\)</span> 为 <span
class="math inline">\(n\)</span> 个元素的集合，则 <span
class="math inline">\(S\)</span> 的一个反链最多包含<span
class="math inline">\(\left(\begin{matrix} n \\ \lfloor n/2 \rfloor
\end{matrix}\right)\)</span>个集合。</p></li>
<li><p><strong>最大链：</strong></p>
<ul>
<li><span class="math inline">\(A_0 = \emptyset \subset A_1 \subset A_2
\dots \subset A_n\)</span></li>
<li><span class="math inline">\(|A_i| = i(i = 1, \dots ,
n)\)</span></li>
<li><span class="math inline">\(S\)</span> 的最大链与 <span
class="math inline">\(S\)</span> 的排列一一对应，相应地，最大链的数目为
<span class="math inline">\(n!\)</span></li>
<li>构造方法：
<ul>
<li><span class="math inline">\(A_0 = \emptyset\)</span></li>
<li>从 <span class="math inline">\(S\)</span> 中选择元素 <span
class="math inline">\(i_1\)</span>，<span class="math inline">\(A_1 =
\{i_1\}\)</span></li>
<li>从 <span class="math inline">\(S\)</span> 中选择元素 <span
class="math inline">\(i_2 \ne i_1\)</span>，<span
class="math inline">\(A_2 = \{i_1, i_2\}\)</span></li>
<li><span class="math inline">\(\dots\)</span></li>
<li>从 <span class="math inline">\(S\)</span> 中选择元素 <span
class="math inline">\(i_k \ne i_1, i_2, \dots, i_{k-1}\)</span>，<span
class="math inline">\(A_k = \{i_1, i_2 \dots, i_k\}\)</span></li>
<li><span class="math inline">\(\dots\)</span></li>
<li>从 <span class="math inline">\(S\)</span> 中选择元素 <span
class="math inline">\(i_n \ne i_1, i_2, \dots, i_{n-1}\)</span>，<span
class="math inline">\(A_n = \{i_1, i_2 \dots, i_n\}\)</span></li>
</ul></li>
</ul></li>
<li><p><strong>对称链划分：</strong></p>
<ul>
<li><span class="math inline">\(S\)</span> 的幂集 <span
class="math inline">\(\mathcal{P}(S)\)</span> 的一个链划分
<ul>
<li>链中每一个子集比它前面的子集的元素个数多 <span
class="math inline">\(1\)</span></li>
<li>链中第一个子集与最后一个子集的大小和等于 <span
class="math inline">\(n\)</span></li>
<li>如果只含一个子集，那么既是第一个又是最后一个，大小为 <span
class="math inline">\(\dfrac{n}{2}\)</span></li>
<li>每一个链中必须含有一个 <span class="math inline">\(\lfloor n/2
\rfloor\)</span> 的子集和一个 <span class="math inline">\(\lceil n/2
\rceil\)</span> 的子集</li>
<li>链的个数为 <span class="math inline">\(\left(\begin{matrix} n \\
\lfloor n/2 \rfloor \end{matrix}\right)\)</span></li>
</ul></li>
<li>构造方法：对于 <span class="math inline">\(n=k\)</span>
时的每一个含多个子集的链 <span class="math inline">\(E\)</span>，可构造
<span class="math inline">\(n=k+1\)</span> 时的两个链
<ul>
<li>在 <span class="math inline">\(E\)</span> 的最后一个子集中增加 <span
class="math inline">\(k+1\)</span>，并加入这个新子集</li>
<li>在 <span class="math inline">\(E\)</span>
的除最后一个子集外的所有子集中加入 <span
class="math inline">\(k+1\)</span>，并删除最后一个子集</li>
</ul></li>
</ul></li>
</ul>
<h4 id="多项式定理">5.4 多项式定理</h4>
<ul>
<li><p>把二项式定理 <span class="math inline">\((x+y)^n\)</span>
扩展到<span class="math inline">\((x_1+x_2+ \dots +
x_t)^n\)</span>。其中，多项式系数： <span class="math display">\[
\left(\begin{matrix} n \\ n_1 n_2 \dots n_t \end{matrix}\right) =
\dfrac{n!}{n_1! n_2! \dots n_t!}
\]</span></p></li>
<li><p><strong>定理5.4.1：</strong>设 <span
class="math inline">\(n\)</span> 是正整数，对于所有的 <span
class="math inline">\(x_1, x_2, \dots, x_t\)</span>，有 <span
class="math display">\[
(x_1+x_2+...+x_t)^n=\sum\binom{n}{n_1n_1...n_t}{x_1}^{n_1}{x_2}^{n_2}...{x_t}^{n_t}
\]</span></p></li>
</ul>
<h4 id="牛顿二项式定理">5.5 牛顿二项式定理</h4>
<blockquote>
<p>把二项式定理的指数扩展到实数</p>
</blockquote>
<h3 id="第6章-容斥原理及应用"><strong>第6章 容斥原理及应用</strong></h3>
<blockquote>
<p>解决具有重叠集合的并集的计数原理</p>
</blockquote>
<h4 id="容斥原理">6.1 容斥原理</h4>
<ul>
<li><p><strong>定理6.1.1（容斥原理计数）：</strong>集合 <span
class="math inline">\(S\)</span> 不具有性质 <span
class="math inline">\(P_1,P_2, \dots ,P_m\)</span> 的物体的个数： <span
class="math display">\[
| \overline{A_1} \cap  \overline{A_2} \cap \dots \cap  \overline{A_n}|=
|S| - \sum|A_i| + \sum|A_i \cap A_j| -
\sum |A_i \cap A_j \cap A_k| + \dots +
(-1)^m \sum |A_1 \cap A_2 \cap \dots \cap A_m|
\]</span></p>
<ul>
<li><p>例：求 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(1000\)</span> 不能被 <span
class="math inline">\(5, 6, 8\)</span> 整除的数的个数。</p>
<p>设 <span class="math inline">\(A_1, A_2 ,A_3\)</span> 分别是 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(1000\)</span> 中能被 <span
class="math inline">\(5, 6, 8\)</span> 整除的数集合，那么 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(1000\)</span> 不能被 <span
class="math inline">\(5, 6, 8\)</span> 整除的数的个数为 <span
class="math inline">\(|\overline{A_1} \cap \overline{A_2} \cap
\overline{A_3}|\)</span> <span class="math display">\[
\begin{aligned}
|A_1| &amp;= \lfloor 1000/5 \rfloor = 200 \\
|A_2| &amp;= \lfloor 1000/6 \rfloor = 166 \\
|A_3| &amp;= \lfloor 1000/8 \rfloor = 125 \\
|A_1 \cap A_2| &amp;= \lfloor 1000/30 \rfloor = 33 \\
|A_1 \cap A_3| &amp;= \lfloor 1000/40 \rfloor = 25 \\
|A_2 \cap A_3| &amp;= \lfloor 1000/24 \rfloor = 41 \\
|A_1 \cap A_2 \cap A_3| &amp;= \lfloor 1000/120 \rfloor = 8 \\
\end{aligned}
\]</span> 由容斥原理，原式 <span
class="math inline">\(=1000-(200+166+125)+(33+25+41)-8=600\)</span></p></li>
<li><p>例：从 <span class="math inline">\(0\)</span> 到 <span
class="math inline">\(99999\)</span> 中有多少同时含有数字 <span
class="math inline">\(2, 5, 8\)</span> 的整数。</p>
<p>设 <span class="math inline">\(A_1, A2, A_3\)</span> 分别是不包含数字
<span class="math inline">\(2, 5, 8\)</span> 的集合。 <span
class="math display">\[
\alpha_1 = |A_1| = |A_2| = |A_3| = 9^5 \\
\alpha_2 = |A_1 \cap A_2| = 8^5 \\
\alpha_3 = |A_1 \cap A_2 \cap A_3| = 7^5
\]</span> 满足题意的整数个数为 <span class="math inline">\(10^5 - 3
\times 9^5 + 3 \times 8^5 -7^5\)</span></p></li>
</ul></li>
<li><p><strong>推论6.1.2（容斥原理计数）：</strong>集合 <span
class="math inline">\(S\)</span> 至少具有性质 <span
class="math inline">\(P_1,P_2, \dots ,P_m\)</span> 之一的物体的个数：
<span class="math display">\[
| A_1 \cup  {A_2} \cup \dots \cup  A_n|=
\sum|A_i| - \sum|A_i \cap A_j| +
\sum |A_i \cap A_j \cap A_k| + \dots +
(-1)^{m+1} \sum |A_1 \cap A_2 \cap \dots \cap A_m|
\]</span></p>
<blockquote>
<p>用总数 - 6.1.1</p>
</blockquote></li>
</ul>
<h4 id="带重复的组合">6.2 带重复的组合</h4>
<ul>
<li><p>例：确定多重集 <span class="math inline">\(T=\{3 \cdot a, 4 \cdot
b, 5 \cdot c\}\)</span> 的 <span class="math inline">\(10\)</span>
子集的个数。</p>
<ul>
<li><p>令多重集 <span class="math inline">\(T^*=\{\infty \cdot a, \infty
\cdot b, \infty \cdot c\}\)</span> 的所有 <span
class="math inline">\(10\)</span> 子集的集合为 <span
class="math inline">\(S\)</span>。</p>
<blockquote>
<p>用于下文无穷集取方案表述方便</p>
</blockquote>
<p><span class="math inline">\(A_1\)</span> 是 <span
class="math inline">\(S\)</span> 中包含多于 <span
class="math inline">\(3\)</span> 个 <span
class="math inline">\(a\)</span> 的 <span
class="math inline">\(10\)</span> 子集的集合；<span
class="math inline">\(A_2\)</span> 是 <span
class="math inline">\(S\)</span> 中包含多于 <span
class="math inline">\(4\)</span> 个 <span
class="math inline">\(b\)</span> 的 <span
class="math inline">\(10\)</span> 子集的集合；<span
class="math inline">\(A_3\)</span> 是 <span
class="math inline">\(S\)</span> 中包含多于 <span
class="math inline">\(5\)</span> 个 <span
class="math inline">\(c\)</span> 的 <span
class="math inline">\(10\)</span>子集的集合。</p>
<p>那么，<span class="math inline">\(T\)</span> 的 <span
class="math inline">\(10\)</span> - 组合数等于 <span
class="math inline">\(|\overline{A_1} \cap \overline{A_2} \cap
\overline{A_3}|\)</span>。</p>
<ul>
<li><span class="math inline">\(A_1\)</span> 中的每个子集中 <span
class="math inline">\(a\)</span> 至少出现 <span
class="math inline">\(4\)</span> 次，剩下 <span
class="math inline">\(6\)</span> 个元素可以是 <span
class="math inline">\(T*\)</span> 的任何 <span
class="math inline">\(6\)</span> - 组合，因此：（其余类推）</li>
</ul>
<p><span class="math display">\[
|A_1| =
\left( \begin{matrix} 6+3-1 \\ 6 \end{matrix} \right) =
\left( \begin{matrix} 8 \\ 6 \end{matrix} \right) = 28
\]</span></p>
<ul>
<li><span class="math inline">\(A_1 \cap A_2\)</span> 中的每个子集中
<span class="math inline">\(a\)</span> 至少出现 <span
class="math inline">\(4\)</span> 次同时 <span
class="math inline">\(b\)</span> 至少出现 <span
class="math inline">\(5\)</span> 次，剩下 <span
class="math inline">\(1\)</span> 个元素可以是 <span
class="math inline">\(T*\)</span> 的任何 <span
class="math inline">\(1\)</span> 组合，因此：</li>
</ul>
<p><span class="math display">\[
|A_1 \cap A_2| =
\left( \begin{matrix} 1+3-1 \\ 1 \end{matrix} \right) =
\left( \begin{matrix} 3 \\ 1 \end{matrix} \right) = 3
\]</span></p>
<blockquote>
<p>这个地方先取 <span class="math inline">\(4\)</span> 个 <span
class="math inline">\(a\)</span>，后面仍可以从无穷集 <span
class="math inline">\(T^*\)</span> 中取 <span
class="math inline">\(a\)</span>，保证了情况是完备的</p>
</blockquote></li>
</ul></li>
<li><p>例：求满足 <span class="math inline">\(1 \leq x_1 \leq 5, -2 \leq
x_2 \leq 4, 0 \leq x_3 \leq 5, 3 \leq x_4 \leq 9\)</span> 的方程 <span
class="math inline">\(x_1+x_2+x_3+x_4 =18\)</span>的整数解个数。</p>
<ul>
<li>转化为“确定多重集 <span class="math inline">\(T=\{4 \cdot a, 6 \cdot
b, 5 \cdot c, 6 \cdot d\}\)</span> 的 <span
class="math inline">\(16\)</span> 子集的个数”，解法与上类似</li>
</ul></li>
</ul>
<h4 id="错位排列-derangement">6.3 错位排列 Derangement</h4>
<ul>
<li><p><strong>错位排列：</strong> 设 <span
class="math inline">\(X={1,2, \dots ,n}\)</span>，它的排列用 <span
class="math inline">\(i_1 i_2 \dots i_n\)</span> 表示, 错位排列是使得
<span class="math inline">\(i_1 \neq 1, i_2 \neq 2,\dots, i_n \neq
n\)</span> 的排列。用<span
class="math inline">\(D_n\)</span>表示错位排列个数。</p>
<ul>
<li>前几项：<span class="math inline">\(D_1 = 0，D_2 = 1，D_3 = 2，D_4 =
9\)</span></li>
</ul></li>
<li><p><strong>定理6.3.1：</strong> 对 <span class="math inline">\(n
\geq 1\)</span>，（应用容斥原理） <span class="math display">\[
D_n=n!-\binom{n}{1}(n-1)!+\binom{n}{2}(n-2)!+...+(-1)^n\binom{n}{n}0!
\]</span></p>
<p><span class="math display">\[
D_n = n! \ (1 - \dfrac{1}{1!} + \dfrac{1}{2!} - \dfrac{1}{3!} + \dots +
(-1)^n \dfrac{1}{n!})
\]</span></p>
<ul>
<li>计算可得：<span class="math inline">\(D_5=44, D_6=265, D_7=1854,
D_8=14833\)</span></li>
</ul></li>
<li><p>例：确定 <span class="math inline">\({1, 2,…, 8}\)</span>
的排列中恰有四个整数在它们的自然位置上的排列数。</p>
<ul>
<li><p>解：任选四个整数在自然位置上：<span
class="math inline">\(\begin{pmatrix} 8 \\ 4 \end{pmatrix}\)</span></p>
<p>剩下四个整数不在其自然位置上： <span
class="math inline">\(D_4\)</span></p>
<p>因此，恰有四个整数在它们的自然位置上的排列数为<span
class="math inline">\(\begin{pmatrix} 8 \\ 4 \end{pmatrix}
D_4\)</span></p></li>
</ul></li>
<li><p><strong>错位排列的递推关系1：</strong><span
class="math inline">\(D_n\)</span> 满足如下递推关系： <span
class="math display">\[
D_n = (n-1)(D_{n-2} + D_{n-1}), (n=3,4,\dots) \\
D_2 = 1; D_1 = 0
\]</span> <strong>计算用的递推关系2：</strong> <span
class="math display">\[
D_n = nD_{n-1} + (-1)^n
\]</span></p></li>
</ul>
<h4 id="带有禁止位置的排列">6.4 带有禁止位置的排列</h4>
<ul>
<li><p><strong>带禁止位置的“非攻击型车”：</strong><span
class="math inline">\(\{1,2,…, n\}\)</span> 的排列 <span
class="math inline">\(i_1 i_2 \dots i_n\)</span> 对应于棋盘上以方格
<span class="math inline">\((1, i_1), (2, i_2),\dots, (n, i_n)\)</span>
为坐标的 <span class="math inline">\(n\)</span>
个车的位置。一些位置禁止。</p></li>
<li><p><strong>定理6.4.1：</strong> 将 <span
class="math inline">\(n\)</span>
个非攻击型不可区分的车放到带有禁止位置的 <span class="math inline">\(n
\times n\)</span> 的棋盘中，放法总数等于： <span class="math display">\[
n! - r_1 (n-1)! +  r_2 (n-2)! - \dots + (-1)^k r_k (n-k)! + \dots +
(-1)^n r_n
\]</span></p>
<ul>
<li><span class="math inline">\(r_k\)</span>：所有的 <span
class="math inline">\(k\)</span>
个车放置在其禁止位置上的放置方法数，<span class="math inline">\(k=1,2,…,
n\)</span>，且其计算不考虑剩下的 <span
class="math inline">\(n-k\)</span> 个车的放置</li>
<li>应满足：任意两个车不在同一行或同一列</li>
</ul></li>
</ul>
<h4 id="另一个禁止位置问题">6.5 另一个禁止位置问题</h4>
<ul>
<li><p><strong>相对禁止位置排列计数：</strong><span
class="math inline">\(Q_n\)</span>：<span class="math inline">\(\{1, 2,
\dots , n\}\)</span> 的排列中没有 <span class="math inline">\(12, 23,
\dots , (n-1)n\)</span> 这些模式出现的排列的个数</p>
<ul>
<li>前几项：<span class="math inline">\(Q_1= 1， Q_2 = 1, Q_3 = 3, Q_4 =
11\)</span></li>
</ul></li>
<li><p><strong>用容斥原理计算 <span
class="math inline">\(Q_n\)</span>：</strong>令 <span
class="math inline">\(A_i\)</span> 是 <span
class="math inline">\(i(i+1)\)</span> 出现的排列的集合，<span
class="math inline">\(i=1,2,\dots,n-1\)</span></p>
<ul>
<li><p>计算 <span class="math inline">\(A_i\)</span> : <span
class="math inline">\(A_1\)</span> 可看作 <span
class="math inline">\(1,2, 3,\dots, n\)</span> 的所有排列的集合，因此
<span class="math inline">\(|A_1|=(n-1)!\)</span>。
显然，由于对称性，对任意 <span
class="math inline">\(i\)</span>，都有<span
class="math inline">\(|A_i|=(n-1)!\)</span></p></li>
<li><p>计算<span class="math inline">\(|A_i \cap
A_j|\)</span>：讨论两种情况：</p>
<ol type="1">
<li><span class="math inline">\(A_i \cap A_{i+1}\)</span>。可看作 <span
class="math inline">\(1, 2, …, (i, i+1, i+2), i+3, …, n\)</span> 的所有
排列的集合，因此<span class="math inline">\(|A_i \cap
A_{i+1}|=(n-2)!\)</span></li>
<li><span class="math inline">\(A_i \cap A_j\)</span>，其中 <span
class="math inline">\(j&gt;i+1\)</span>。可看作 <span
class="math inline">\(1,2,…, (i, i+1), i+2, …, ( j, j+1), …, n\)</span>
的所有排列的集合，因此<span class="math inline">\(|A_i \cap
A_j|=(n-2)!\)</span></li>
</ol>
<p>所以，对任意 <span class="math inline">\(i, j\)</span>，都有<span
class="math inline">\(|A_i \cap A_j|=(n-2)!\)</span></p></li>
<li><p>同理可证 ，对于每个 <span class="math inline">\(k\)</span> 子集
<span class="math inline">\(\{i_1,…, i_k\}\)</span>，有 <span
class="math inline">\(|A_{i_1} \cap A_{i_2} \cap \dots \cap
A_{i_k}|=(n-k)!\)</span></p></li>
<li><p>由此推出下面公式。</p></li>
</ul></li>
<li><p><strong>定理6.5.1：</strong>对于 <span class="math inline">\(n
\ge 1\)</span> <span class="math display">\[
\begin{align}
Q_n &amp;= n! + \sum_{k=1}^{n-1} (-1)^k
\left( \begin{matrix} n-1 \\ k \end{matrix} \right) (n-k)!    \\
&amp;= n! -
\left( \begin{matrix} n-1 \\ 1 \end{matrix} \right) (n-1)! +
\left( \begin{matrix} n-1 \\ 2 \end{matrix} \right) (n-2)! + \dots +
(-1)^{n-1} \left( \begin{matrix} n-1 \\ n-1 \end{matrix} \right) 1!
\end{align}
\]</span></p></li>
<li><p>例：旋转木马有 <span class="math inline">\(8\)</span>
个座，每个座位都代表一种不同的动物。<span
class="math inline">\(8\)</span>
个男孩脸朝里围坐在旋转木马上，使得每一个男孩都面对到另一个男孩。他们能够有多少种方法改变座位使得每人面对的男孩都不同于之前面对的男孩？</p>
<ul>
<li>假设 <span class="math inline">\(8\)</span> 个男孩分成了四对：<span
class="math inline">\((1,5), (2,6), (3,7), (4,8)\)</span>。 假设 <span
class="math inline">\(A_1, A_2, A_3, A_4\)</span> 分别表示仍然有 <span
class="math inline">\((1,5), (2,6), (3,7), (4,8)\)</span>
出现的坐法的集合。则使得每人面对的男孩都不同的坐法的数目为：<span
class="math inline">\(|\overline{A_1} \cap \overline{A_2} \cap
\overline{A_3} \cap \overline{A_4}|\)</span></li>
</ul>
<p><span class="math display">\[
|A_1| = |A_i| = 8 * 6! \\
|A_1 \cap A_2| = 8 * 6 * 4! \\
|A_1 \cap A_2 \cap A_3| = 8 * 6 * 4*2! \\
|A_1 \cap A_2 \cap A_3 \cap A_4| = 8 * 6 * 4 * 2
\]</span></p></li>
<li><p>相对禁止位置 <span class="math inline">\(Q_n\)</span> 与错位排列
<span class="math inline">\(D_n\)</span> 的关系： <span
class="math display">\[
Q_n = D_n + D_{n-1}
\]</span></p></li>
</ul>
<h3 id="第7章-递推关系和生成函数"><strong>第7章
递推关系和生成函数</strong></h3>
<blockquote>
<p>生成函数核心思想：</p>
<ol type="1">
<li>把离散数列和幂级数一一对应起来</li>
<li>把离散数列间的相互结合关系对应成为幂级数间的运算关系</li>
<li>由幂级数形式确定离散数列的构造</li>
</ol>
</blockquote>
<blockquote>
<p><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611140632902.png" alt="image-20230611140632902" style="zoom:50%;" /></p>
</blockquote>
<h4 id="若干数列">7.1 若干数列</h4>
<ul>
<li><p>例：设 <span class="math inline">\(h_n\)</span> 是 <span
class="math inline">\(1\)</span> 行 <span
class="math inline">\(n\)</span>
列棋盘用红黄蓝三种颜色着色并使得没有着成红色的方格相邻的着色方法数。求
<span class="math inline">\(h_n\)</span> 满足的递推关系。</p>
<ul>
<li><p>末尾为红：必须前面再放黄色or蓝色保证不相邻 <span
class="math inline">\(2h_{n-2}\)</span></p></li>
<li><p>末尾为蓝or黄：直接拼接即可 <span
class="math inline">\(2h_{n-1}\)</span></p></li>
</ul></li>
<li><p>例：确定 <span class="math inline">\(2 \times n\)</span>
棋盘用多米诺牌完全覆盖的方法数 <span
class="math inline">\(h_n\)</span></p></li>
<li><p>例：确定用单牌和多米诺牌完美覆盖 <span class="math inline">\(1
\times n\)</span> 棋盘的方法数 <span
class="math inline">\(b_n\)</span></p></li>
<li><p><strong><span class="math inline">\(Fibonacci\)</span>
数列：</strong></p>
<ul>
<li>部分和：<span class="math inline">\(s_n = f_0+f_1+ \dots +f_n =
f_{n+2}-1\)</span>
<ul>
<li>证明：数学归纳法</li>
</ul></li>
<li><span class="math inline">\(f_n\)</span> 是偶数当且仅当 <span
class="math inline">\(n\)</span> 被 <span
class="math inline">\(3\)</span> 整除
<ul>
<li>每三项都是偶奇奇</li>
</ul></li>
</ul></li>
<li><p><strong>定理7.1.2：</strong>沿 <span
class="math inline">\(Pascal\)</span>
三角形从左下到右上的对角线上的二项式系数和是斐波那契数，即 <span
class="math display">\[
f_n =
\left( \begin{matrix} n-1 \\ 0 \end{matrix} \right) +
\left( \begin{matrix} n-2 \\ 1 \end{matrix} \right) +
\left( \begin{matrix} n-3 \\ 2 \end{matrix} \right) + \dots +
\left( \begin{matrix} n-k \\ k-1 \end{matrix} \right)
\]</span> 其中，<span class="math inline">\(k=\lfloor (n+1)/2
\rfloor\)</span></p></li>
</ul>
<h4 id="生成函数">7.2 生成函数</h4>
<ul>
<li>令 <span class="math inline">\(h_0, h_1, \dots ,h_n \dots\)</span>
为一无穷数列，其生成函数定义为：</li>
</ul>
<p><span class="math display">\[
g(x)=h_0 +h_1x+h_2x^2+\dots+h_nx^n+\dots
\]</span></p>
<ul>
<li><p>例：设 <span class="math inline">\(k\)</span> 是正整数，<span
class="math inline">\(h_n\)</span> 等于方程 <span
class="math inline">\(e_1+e_2+ \dots +e_k =n\)</span>
的非负整数解个数，即 <span class="math inline">\(h_n\)</span> 为多重集
$S={a_1, a_2, , a_k} $的 <span class="math inline">\(n\)</span> -
组合个数，求数列 <span class="math inline">\(h_0, h_1,…, h_n…\)</span>
的生成函数 <span class="math inline">\(g(x)\)</span>。</p>
<ul>
<li>由于<span class="math inline">\(h_n = \left( \begin{matrix} n+k-1 \\
n \end{matrix} \right)\)</span>。因此，</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
g(x) &amp;= \sum_{n=0}^\infty
\left( \begin{matrix} n+k-1 \\ n \end{matrix} \right) x^n =
\dfrac{1}{(1-x)^k} \ (|x|&lt;1)  \\
&amp;= (\sum_{e_1=0}^\infty x^{e_1})
(\sum_{e_2=0}^\infty x^{e_2}) \dots
(\sum_{e_k=0}^\infty x^{e_k})
\end{aligned}
\]</span></p></li>
<li><p>例：设 <span class="math inline">\(S\)</span> 是多重集合${a_1,
a_2, a_3 , a_4} $。确定数列 <span class="math inline">\(h_0, h_1,…, h_n,
…\)</span> 的生成函数，其中 <span class="math inline">\(h_n\)</span>
是满足以下约束的 <span class="math inline">\(S\)</span> 的 <span
class="math inline">\(n\)</span> 组合数。 (1) <span
class="math inline">\(a_1\)</span> 出现奇数次，<span
class="math inline">\(a_2\)</span> 出现偶数次。 (2) 元素 <span
class="math inline">\(a_1\)</span> 不会出现，<span
class="math inline">\(a_2\)</span> 至多出现 <span
class="math inline">\(1\)</span> 次。 (3) 每个 <span
class="math inline">\(a_i\)</span> 出现的次数是 <span
class="math inline">\(3\)</span> 的倍数。</p>
<ul>
<li>解: (1) 生成函数 <span class="math display">\[
\begin{align}
g(x)
&amp;=(x+x^3+x^5+...+x^{2n+1}+...) (1+x^2+x^4+...+x^{2n}+...)
(1+x+x^2+...+x^n+...)^2 \\
&amp;=x(1+x^2+x^4+...+x^{2n}+...)^2 (1+x+x^2+...+x^n+...)^2 \\
&amp;= x(\dfrac{1}{1-x^2})^2 (\dfrac{1}{1-x})^2
\end{align}
\]</span>
<ol start="2" type="1">
<li><p>生成函数 <span class="math inline">\(g(x) =1
(1+x)(1+x+x^2+…+x^n+…)^2= (1+x)/(1-x)^2\)</span></p></li>
<li><p>生成函数 <span class="math inline">\(g(x) =
(1+x^3+x^6+…x^{3n}+…)^4 = 1/(1-x^3)^4\)</span></p></li>
</ol></li>
</ul></li>
<li><p>例：由生成函数求通项 <span
class="math inline">\(h_n\)</span></p></li>
<li><p><strong>几个常见的展开式：</strong> <span class="math display">\[
(1-x)^n = \sum_{k=0}^\infty \left( \begin{matrix} n \\ k \end{matrix}
\right) x^k \\
\dfrac{1}{(1-x)^n} = \sum_{k=0}^\infty \left( \begin{matrix} n+k-1 \\ k
\end{matrix} \right) x^k
\]</span></p>
<ul>
<li><span class="math inline">\(+x\)</span> 用 <span
class="math inline">\(-x\)</span> 带入 <span
class="math inline">\(x\)</span> 即可</li>
</ul></li>
<li><p>例：求装有苹果、香蕉、桔子和梨的果篮的数量 <span
class="math inline">\(h_n\)</span>，其中每个果篮中，苹果的个数是偶数，香蕉的个数是
<span class="math inline">\(5\)</span> 的倍数, 桔子不超过 <span
class="math inline">\(4\)</span> 个，而且至多只有一个梨. <span
class="math display">\[
\begin{align}
g(x) &amp;=(1+x^2+x^4+…)( 1+x^5+x^{10}+x^{15}+…)(1+x+x^2+x^3+x^4)(
1+x)   \\
&amp;= \dfrac{1}{1-x^2} \cdot \dfrac{1}{1-x^5} \cdot \dfrac{1-x^5}{1-x}
\cdot (1+x)   \\
&amp;= \dfrac{1}{(1-x)^2} \\
&amp;= \sum_{n=0}^\infty \left( \begin{matrix} n+1 \\ n \end{matrix}
\right) x^n  \\
&amp;= \sum_{n=0}^\infty (n+1) x^n
\end{align}
\]</span> 因此，满足条件的 <span class="math inline">\(n\)</span>
组合个数为 <span class="math inline">\(h_n =n+1\)</span>。</p></li>
<li><p>例（带系数）：设 <span class="math inline">\(h_n\)</span> 是方程
<span class="math inline">\(3e_1+4e_2+2e_3+5e_4=n\)</span>
的非负整数解的个数，求序列 <span class="math inline">\(h_0, h_1,
…,h_n,…\)</span> 的生成函数.</p>
<blockquote>
<p>生成函数针对的是系数为 <span class="math inline">\(1\)</span>
的情况，所以化归一下，化成系数为 <span class="math inline">\(1\)</span>
即可</p>
</blockquote>
<p>作变量替换 <span class="math inline">\(f_1=3e_1, f_2=4e_2, f_3=2e_3,
f_4=5e_4\)</span> 得到 <span class="math inline">\(f_1+f_2+f_3+f_4=n
\quad (1)\)</span></p>
<p>因此，<span class="math inline">\(h_n\)</span> 等于方程 <span
class="math inline">\((1)\)</span> 的非负整数解的个数，满足 <span
class="math inline">\(f_1\)</span> 是 <span
class="math inline">\(3\)</span> 的倍数，<span
class="math inline">\(f_2\)</span> 是 <span
class="math inline">\(4\)</span> 的倍数，<span
class="math inline">\(f_3\)</span> 是 <span
class="math inline">\(2\)</span> 的倍数，<span
class="math inline">\(f_4\)</span> 是 <span
class="math inline">\(5\)</span> 的倍数。</p>
<p>因此，生成函数为 <span class="math display">\[
\begin{align}
g(x) &amp;=(1+x^3+x^6+…)(1+x^4+x^8+…)(1+x^2+x^4+…)(1+x^5+x^{10}+…) \\
&amp;=\dfrac{1}{1-x^3}\cdot\dfrac{1}{1-x^4}\cdot\dfrac{1}{1-x^2}\cdot\dfrac{1}{1-x^5}
\end{align}
\]</span></p></li>
</ul>
<h4 id="指数生成函数">7.3 指数生成函数</h4>
<ul>
<li><p>数列 <span class="math inline">\(h_0,h_1,h_2, \dots ,h_n\)</span>
的指数生成函数定义为： <span class="math display">\[
g^{(e)}(x) = h_0 + \dfrac{h_1}{1!} x +
\dfrac{h_2}{2!} x^2 + \dfrac{h_3}{3!} x^3 + \dots +
\dfrac{h_k}{k!} x^k + \dots
\]</span></p></li>
<li><p><strong>带有附加限制的多重集合 <span
class="math inline">\(n\)</span> 排列数列：</strong></p>
<ul>
<li><p>例：用红、蓝、黄三种颜色给 <span class="math inline">\(1 \times
n\)</span>
的棋盘着色，如果要求被着成红色的方格数是偶数，确定给这个棋盘着色的方法数
<span class="math inline">\(h_n\)</span>。</p>
<p>设 <span class="math inline">\(h_n\)</span> 表示着色的方法数，定义
<span class="math inline">\(h_0=1\)</span>。 显然，<span
class="math inline">\(h_n\)</span> 等于 <span
class="math inline">\(3\)</span> 种颜色的多重集合的 <span
class="math inline">\(n\)</span>
排列数，其中每种颜色的重数是无穷的，且要求红色出现的次数是偶数。
因此，指数生成函数为 <span class="math display">\[
\begin{align}
g^{(e)}(x) &amp;= (1 + \dfrac{x^2}{2!} + \dfrac{x^4}{4!} + \dots)
(1 + \dfrac{x^1}{1!} + \dfrac{x^2}{2!} + \dots)
(1 + \dfrac{x^1}{1!} + \dfrac{x^2}{2!} + \dots) \\
&amp;= \dfrac{1}{2}(e^x+e^{-x})e^x e^x = \dfrac{1}{2} (e^{3x}+e^x)  \\
&amp;= \dfrac{1}{2} (\sum_{n=0}^\infty 3^n \dfrac{x^n}{n!} +
\sum_{n=0}^\infty \dfrac{x^n}{n!})
= \dfrac{1}{2} \sum_{n=0}^\infty (3^n+1) \dfrac{x^n}{n!}
\end{align}
\]</span> 得$ h_n=(3^n+1)/2$。</p></li>
</ul></li>
<li><p><strong>常见展开</strong> <span class="math display">\[
e^x = \sum_{n=0}^\infty \dfrac{x^n}{n!}
= 1 + x + \dfrac{x^2}{2!} + \dots + \dfrac{x^n}{n!} + \dots   \\
\dfrac{1}{2} (e^x+e^{-x})  = 1 + \dfrac{x^2}{2!} + \dfrac{x^4}{4!} +
\dots + \dfrac{x^{2n}}{2n!} + \dots    \\
\dfrac{1}{2} (e^x-e^{-x})  = x + \dfrac{x^3}{3!} + \dfrac{x^5}{5!} +
\dots + \dfrac{x^{2n+1}}{(2n+1)!} + \dots
\]</span></p></li>
</ul>
<h4 id="求解线性齐次递推关系">7.4 求解线性齐次递推关系</h4>
<ul>
<li><p><strong>（齐次）线性递推关系：</strong>令 <span
class="math inline">\(h_0, h_1, h_2,…, h_n,…\)</span>
是一个数列，若存在量 <span class="math inline">\(a_1, a_2,…,a_k\)</span>
和量 <span
class="math inline">\(b_n\)</span>（每个量是常数或<strong>依赖于 <span
class="math inline">\(n\)</span> 的数</strong>）使得： <span
class="math display">\[
h_n = a_1 h_{n-1} +  a_2 h_{n-2} + \dots +  a_k h_{n-k} +b_n \ (n \geq
k)
\]</span> 则称该数列满足 <strong><span
class="math inline">\(k\)</span></strong> 阶线性递推关系</p>
<p>若 <span class="math inline">\(b_n =0\)</span>，则称该数列是 <span
class="math inline">\(k\)</span> 阶线性齐次递推关系</p>
<p>若 <span class="math inline">\(a_1, a_2, \dots, a_k\)</span>
都为常数，则称该数列是 <span class="math inline">\(k\)</span>
阶常系数线性递推关系</p>
<blockquote>
<p>解法：</p>
<ul>
<li>特征方程法</li>
<li>生成函数法</li>
</ul>
</blockquote></li>
<li><p><strong>定理7.4.1（特征方程与原递推关系同解）：</strong>令 <span
class="math inline">\(q\)</span> 为一个非零数，则 <span
class="math inline">\(h_n =q_n\)</span> 是常系数线性齐次递推关系 <span
class="math display">\[
h_n = a_1 h_{n-1} +  a_2 h_{n-2} + \dots +  a_k h_{n-k} +b_n \ (a_k \neq
0, n \geq k)
\]</span> 的解当且仅当 <span
class="math inline">\(q\)</span>（特征根）是多项式方程 <span
class="math display">\[
x^k - a_1 x_{k-1} - a_2 x_{k-2} - \dots - a_{k-1} x -a_k = 0
\]</span> 的一个根。</p>
<p>若特征根多项式方程有 <span class="math inline">\(k\)</span>
个不同的根 <span class="math inline">\(q_1, q_2,…, q_k\)</span>，则
<span class="math display">\[
h_n = c_1 q_1 ^n  +  c_2 q_2 ^n + \dots +  c_k q_k ^n
\]</span> 是下述意义下原递推关系的通解：任意给定初始值 <span
class="math inline">\(h_0, h_1, …,h_{k-1}\)</span>，都存在 <span
class="math inline">\(c_1, c_2,…, c_k\)</span>
使得上式是满足原递推关系式和初始条件的唯一的数列.</p>
<blockquote>
<p>线性组合的意思</p>
</blockquote></li>
<li><p>例：确定由 <span class="math inline">\(0, 1, 2\)</span>
组成的长度为 <span class="math inline">\(n\)</span> 且不包含两个连续的
<span class="math inline">\(0\)</span> 或两个连续的 <span
class="math inline">\(1\)</span> 的三进制串的个数 <span
class="math inline">\(a_n\)</span> 的递推关系，然后求出 <span
class="math inline">\(a_n\)</span> 的公式。</p>
<ul>
<li><p>解: 当 <span class="math inline">\(n=0\)</span> 时，为空串，此时
<span class="math inline">\(a_0=1\)</span>；</p>
<p>当 <span class="math inline">\(n=1\)</span> 时, 满足条件的三进制串为
<span class="math inline">\(0, 1, 2\)</span>，得 <span
class="math inline">\(a_1=3\)</span></p>
<p>当 <span class="math inline">\(n&gt;1\)</span> 时，设以 <span
class="math inline">\(0，1，2\)</span> 开头的长度为三进制串的个数分别为
<span class="math inline">\(b_n, c_n, d_n\)</span>，则 <span
class="math inline">\(a_n =b_n+c_n+d_n\)</span>。</p>
<ol type="a">
<li><p>当以 <span class="math inline">\(0\)</span> 开头时，<span
class="math inline">\(b_n=c_{n-1}+d_{n-1} \quad (1)\)</span></p></li>
<li><p>当以 <span class="math inline">\(1\)</span> 开头时，<span
class="math inline">\(c_n=b_{n-1}+d_{n-1} \quad (2)\)</span></p></li>
<li><p>当以 <span class="math inline">\(2\)</span> 开头时，<span
class="math inline">\(d_n=b_{n-1}+c_{n-1}+d_{n-1}=a_{n-1} \quad
(3)\)</span></p></li>
</ol>
<p>把 <span class="math inline">\((1), (2), (3)\)</span>
式左右两边分别相加得：<span class="math inline">\(a_n = b_n+c_n+d_n =
c_{n-1}+d_{n-1}+b_{n-1}+d_{n-1}+a_{n-1} = a_{n-1}+a_{n-2}+a_{n-1} =
2a_{n-1} + a_{n-2}\)</span></p></li>
</ul></li>
<li><p>例：利用<strong>生成函数</strong>求解 <span
class="math inline">\(h_n=h_{n-1}+9h_{n-2}-9h_{n-3} (n&gt;2), h_0=0,
h_1=1, h_2=2\)</span>。（配凑递推式的系数）</p>
<ul>
<li><p>令生成函数为 <span
class="math inline">\(g(x)=h_0+h_1x+h_2x^2+…+h_nx^n+… \quad
(1)\)</span></p>
<p><span class="math inline">\((1)\)</span> 式两边分别同乘 <span
class="math inline">\(–x, -9x^2, 9x^3\)</span> , 得 <span
class="math display">\[
\begin{aligned}
&amp;(1-x-9x^2+9x^3) g(x) \\
&amp;= h_0 + (h_1-h_0)x+(h_2-h_1-9h_0)x^2+(h_3-h_2-9h_1+9h_0)x +… \\
&amp;= h_0 + (h_1-h_0)x+(h_2-h_1-9h_0)x^2 \\
&amp;= x+x^2
\end{aligned}
\]</span> 得<span class="math inline">\(g(x) =(x+x^2)/(1-x-9x^2+9x^3) =
(x+x^2)/(1-x)(1-3x)(1+3x)\)</span>，再求得 <span
class="math inline">\(h_n\)</span></p></li>
</ul></li>
<li><p>例：求解递推关系 <span
class="math inline">\(h_n+h_{n-1}-16h_{n-2}+20h_{n-3}=0 (n \ge
3)\)</span> 其中 <span class="math inline">\(h_0=0, h_1=1, h_2=
-1\)</span>.</p>
<ul>
<li><ol type="1">
<li>求数列的生成函数。<span
class="math inline">\(g(x)=x/(1+x-16x^2+20x^3)\)</span></li>
</ol></li>
<li><ol start="2" type="1">
<li>将 <span class="math inline">\(g(x)\)</span> 表示成代数分式和。由于
<span
class="math inline">\((1+x-16x^2+20x^3)=(1-2x)^2(1+5x)\)</span>，得到
<span class="math display">\[
\begin{align}
g(x)&amp; = \dfrac{x}{(1-2x)^2(1+5x)}   \\
&amp;= \dfrac{c_1}{1-2x} + \dfrac{c_2}{(1-2x)^2} +
\dfrac{c_3}{1+5x}    \\
&amp;= -\dfrac{2/49}{1-2x} + \dfrac{7/49}{(1-2x)^2} - \dfrac{5/49}{1+5x}
\end{align}
\]</span></li>
</ol></li>
<li><ol start="3" type="1">
<li>利用牛顿二项式定理展开。 <span class="math display">\[
\dfrac{1}{1-2x} = \sum_{k=0}^\infty 2^k x^k \\
\dfrac{1}{(1-2x)^2} = \sum_{k=0}^\infty
\left( \begin{matrix} k+1 \\ k \end{matrix} \right) 2^k x^k =
\sum_{k=0}^\infty (k+1) 2^k x^k \\
\dfrac{1}{1+5x} = \sum_{k=0}^\infty (-5)^k x^k
\]</span> 于是得到： <span class="math display">\[
g(x) = \sum_{k=0}^\infty
[-\dfrac{2}{49}2^k + \dfrac{7}{49} (k+1) 2^k - \dfrac{5}{49}(-5)^k] x^k
\\
h_n = -\dfrac{2}{49}2^n + \dfrac{7}{49} (n+1) 2^n - \dfrac{5}{49}(-5)^n
\]</span></li>
</ol></li>
</ul></li>
</ul>
<h4 id="非齐次递推关系">7.5 非齐次递推关系</h4>
<ul>
<li><p><strong>一般非齐次递推关系的通解：</strong>假设有非齐次递推关系
<span class="math inline">\(h_n = a_1 h_{n-1} + a_2 h_{n-2} + \dots +
a_k h_{n-k} +b_n\)</span></p>
<p>若 <span class="math inline">\(f_n\)</span> 是对应齐次递推关系 <span
class="math inline">\(h_n&#39; = h_n - b_n = a_1 h_{n-1} + a_2 h_{n-2} +
\dots + a_k h_{n-k}\)</span> 的通解，而 <span
class="math inline">\(c_n\)</span> 是原非齐次递推关系 <span
class="math inline">\((1)\)</span> 的一个特解，那么 <span
class="math inline">\(h_n = c f_n + c_n\)</span> 是原非齐次递推关系
<span class="math inline">\((1)\)</span> 的通解。</p></li>
<li><p>例：求递推关系 <span class="math inline">\(h_n=3h_{n-1}-4n,
h_0=2\)</span>.</p>
<ul>
<li><p>（1）首先求解对应的齐次递推关系 <span
class="math inline">\(h_n=3h_{n-1}\)</span> 的通解。 特征方程为 <span
class="math inline">\(x-3=0\)</span>，特征根为 <span
class="math inline">\(x=3\)</span>，因此通解为 <span
class="math inline">\(h_n =c3^n\)</span></p></li>
<li><p>（2）求 <span class="math inline">\(h_n=3h_{n-1}-4n\)</span>
的一个特解： 猜测解的形式 <span class="math inline">\(h_n
=r_n+s\)</span>，代入递推关系得到：<span class="math inline">\(r_n+s =
3(r_{n-1}+s)-4n= (3r-4)n+(-3r+3s)\)</span> 得到：<span
class="math inline">\(r=3r-4, s=-3r+3s\)</span> 因此，<span
class="math inline">\(r=2\)</span> 和$ s=3$, 从而 <span
class="math inline">\(h_n=2n+3\)</span> 是递推关系的一个特解。</p></li>
<li><p>代入。从而问题的解为：<span class="math inline">\(h_n=
-3^n+2n+3\)</span></p></li>
</ul></li>
<li><p><strong>尝试特解的一些方法：</strong></p>
<ul>
<li><ol type="1">
<li>如果 <span class="math inline">\(b_n\)</span> 是 <span
class="math inline">\(n\)</span> 的 <span
class="math inline">\(k\)</span> 次多项式，那么尝试 <span
class="math inline">\(h_n\)</span> 也是 <span
class="math inline">\(n\)</span> 的 <span
class="math inline">\(k\)</span> 次多项式</li>
</ol>
<ul>
<li>① 若 <span class="math inline">\(b_n =d\)</span> (常数)，尝试 <span
class="math inline">\(h_n =r\)</span> (常数);</li>
<li>② 若 <span class="math inline">\(b_n =d_n+c\)</span> (<span
class="math inline">\(d, c\)</span> 是常数)，尝试 <span
class="math inline">\(h_n = r_n+s\)</span> (<span
class="math inline">\(r,s\)</span> 是常数);</li>
<li>③ 若 <span class="math inline">\(b_n = a_n^2+dn+c\)</span> (<span
class="math inline">\(a,d,c\)</span> 是常数)，尝试 <span
class="math inline">\(h_n = r_n^2+s_n+t\)</span> (<span
class="math inline">\(r,s,t\)</span> 是常数);</li>
</ul></li>
<li><ol start="2" type="1">
<li>若 <span class="math inline">\(b_n =d^n\)</span> (<span
class="math inline">\(d\)</span> 是常数)是指数形式， 尝试 <span
class="math inline">\(h_n = pd^n\)</span> (<span
class="math inline">\(p\)</span> 是常数)也是指数形式。</li>
</ol>
<ul>
<li>如果失败了可以尝试 <span class="math inline">\(h_n =
pnd^n\)</span></li>
</ul></li>
</ul></li>
</ul>
<h4 id="一个几何例子">7.6 一个几何例子</h4>
<ul>
<li><strong>定理7.6.1（凸多边形三角形剖分方法计数）：</strong>设 <span
class="math inline">\(h_n\)</span>
表示用下面方法把凸多边形区域分成三角形区域的方法数： 在有 <span
class="math inline">\(n+1\)</span>
条边的凸多边形区域内通过插入不相交的对角线，而把它分成三角形区域。 定义
<span class="math inline">\(h_1 =1\)</span>。则 <span
class="math inline">\(h_n\)</span> 满足如下递推关系: <span
class="math display">\[
\begin{align}
h_n &amp;= h_1 h_{n-1} + h_2 h_{n-2} + \dots + h_{n-1} h_1    \\
&amp;= \sum_{k=1}^{n-1} h_k h_{n-k} \ (n \geq 2)
\end{align}
\]</span> 该递推关系解为： <span class="math display">\[
h_n = \dfrac{1}{n}
\left( \begin{matrix} 2n-2 \\ n-1 \end{matrix} \right),(n=1,2,3,\dots)
\]</span> 前几项：<span class="math inline">\(h_1 = 1, h_2 = 1, h_3 = 2,
h_4 = 5\)</span></li>
</ul>
<h3 id="第8章-特殊计数序列"><strong>第8章 特殊计数序列</strong></h3>
<h4 id="catalan-数">8.1 <span class="math inline">\(Catalan\)</span>
数</h4>
<ul>
<li><p>（接上文）<strong><span class="math inline">\(Catalan\)</span>
数列：</strong> <span class="math inline">\(Catalan\)</span> 数列是序列
<span class="math inline">\(C_0, C_1,…, C_n,…,\)</span> 其中 <span
class="math display">\[
C_n = \dfrac{1}{n+1}
\left( \begin{matrix} 2n \\ n \end{matrix} \right),(n=0,1,2,\dots)
\]</span> 是第 <span class="math inline">\(n\)</span> 个 <span
class="math inline">\(Catalan\)</span> 数。</p>
<blockquote>
<p>记法：重要的组合部分是 <span class="math inline">\(n\)</span>
相关，外面的分子不太重要</p>
</blockquote>
<p>前几项：<span class="math inline">\(C_1 = 1, C_2 = 2, C_3 = 5, C_4 =
14\)</span></p>
<blockquote>
<p>千万注意是第 <span class="math inline">\(n\)</span> 个还是第 <span
class="math inline">\(n+1\)</span> 个</p>
<p>且 <span class="math inline">\(C_{n-1}\)</span> 对应凸 <span
class="math inline">\(n+1\)</span> 多边形，相差 <span
class="math inline">\(2\)</span></p>
</blockquote></li>
<li><p>例（括号化问题）：矩阵连乘 <span class="math inline">\(P=
A_1×A_2×…×A_n\)</span>，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？</p>
<ul>
<li>分别计算两个部分，然后对两个部分分别括号化</li>
<li><span class="math inline">\(h_n = h_1h_{n-1} + h_2h_{n-2} +
h_3h_{n-3} + \dots + h_{n-1}h_1\)</span></li>
<li><span class="math inline">\(h_n=C_{n-1}\)</span></li>
</ul></li>
<li><p>例（出栈次序问题）：一个栈(无穷大)的进栈序列为 <span
class="math inline">\(1, 2, 3, …, n\)</span>，有多少个不同的出栈序列?
（后进先出）</p>
<ul>
<li><p>记出栈序列数目为 <span
class="math inline">\(h_n\)</span></p></li>
<li><p>假设一个出栈序列的最后一个出栈元素为 <span
class="math inline">\(k (1≤k ≤n)\)</span>，则有</p>
<p>（1）元素 <span class="math inline">\(1, 2, …, k-1\)</span>
的进栈与出栈在 <span class="math inline">\(k\)</span>
入栈前全部完成;</p>
<p>（2）元素 <span class="math inline">\(k+1,…, n\)</span>
的进栈与出栈在 <span class="math inline">\(k\)</span> 入栈后直至 <span
class="math inline">\(k\)</span> 出栈前全部完成。</p>
<p>因此，由乘法原理，最后一个出栈元素为 <span
class="math inline">\(k\)</span> 的出栈序列的个数为 <span
class="math inline">\(h_{k-1} h_{n-k}\)</span></p></li>
<li><p>由递推关系知 <span
class="math inline">\(h_n=C_n\)</span></p></li>
</ul></li>
<li><p>例（二叉树数目）：<span class="math inline">\(n\)</span>
个节点构成的二叉树的情况有 <span class="math inline">\(h_n =
C_n\)</span> 种</p></li>
<li><p><strong>定理8.1.1：</strong>考虑由 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(+1\)</span> 和 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(-1\)</span> 构成的 <span
class="math inline">\(2n\)</span> 项序列 <span
class="math inline">\(a_1,a_2,\dots,a_{2n}\)</span>，
其部分和满足：<span class="math inline">\(a_1 + a_2 + \dots + a_k \geq 0
\ (k=1,2,…,2n)\)</span> 的序列的个数等于第 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(Catalan\)</span> 数 <span class="math display">\[
C_n = \dfrac{1}{n+1}
\left( \begin{matrix} 2n \\ n \end{matrix} \right) (n \geq 0)
\]</span></p>
<ul>
<li><p>例（找零）：有 <span class="math inline">\(2n\)</span>
个人排成一对进电影院，门票 <span class="math inline">\(50\)</span>
元，<span class="math inline">\(2n\)</span> 个人中的 <span
class="math inline">\(n\)</span> 个人有 <span
class="math inline">\(50\)</span> 元纸币，<span
class="math inline">\(n\)</span> 个人有 <span
class="math inline">\(100\)</span> 元纸币。
电影院设置售票点，假设未备有零钱，有多少种排队方法使得只要有 <span
class="math inline">\(100\)</span> 元的人买票，售票处就有 <span
class="math inline">\(50\)</span> 元的纸币找零？</p>
<p>（1）情况 <span class="math inline">\(1\)</span>：若把 <span
class="math inline">\(2n\)</span> 个人看成不可区分的，将 <span
class="math inline">\(50\)</span> 元用 <span
class="math inline">\(+1\)</span> 表示，<span
class="math inline">\(100\)</span> 元用 <span
class="math inline">\(-1\)</span> 表示。答案 <span
class="math inline">\(C_n\)</span></p>
<p>（2）情况 <span class="math inline">\(2\)</span>：若把 <span
class="math inline">\(2n\)</span> 个人看成可区分的。则需要考虑 <span
class="math inline">\(n\)</span> 个有 <span
class="math inline">\(50\)</span> 元纸币的人的排列，以及 <span
class="math inline">\(n\)</span> 个有 <span
class="math inline">\(100\)</span> 元纸币的人的排列。 因此排队方法数为：
<span class="math display">\[
(n!\ n!)\dfrac{1}{n+1} \
\left( \begin{matrix} 2n \\ n \end{matrix} \right) (n \geq 0)
\]</span></p></li>
<li><p>例：一位大城市的律师在她住所以北 <span
class="math inline">\(n\)</span> 个街区和以东 <span
class="math inline">\(n\)</span> 个街区处工作。每天她走 <span
class="math inline">\(2n\)</span>
个街区上班。如果她不穿越从家到办公室的对角线，有多少可能的道路？</p>
<p>用 <span class="math inline">\(+1\)</span> 表示向东，<span
class="math inline">\(-1\)</span> 表示向北。则每条路径对应一个 <span
class="math inline">\(+1, -1\)</span> 的序列 <span
class="math inline">\(a_1,a_2,\dots,a_{2n}\)</span></p></li>
</ul></li>
<li><p><strong><span class="math inline">\(Catalan\)</span>
序列递推关系和初始条件为：</strong> <span class="math display">\[
C_n = \dfrac{4n-2}{n+1} C_{n-1} (n \geq 1) ,C_0 = 1
\]</span></p></li>
</ul>
<h4 id="差分序列和-stirling-数">8.2 差分序列和 <span
class="math inline">\(Stirling\)</span> 数</h4>
<ul>
<li><p><strong>差分序列：</strong>设 <span class="math inline">\(h_0,
h_1, h_2, …, h_n, …\)</span> 是一个序列。定义新序列: $h_0, h_1, h_2, ,
h_n, $称为 <span class="math inline">\(h_0, h_1, h_2, …, h_n, …\)</span>
的（一阶）差分序列，其中 <span class="math inline">\(\Delta h_n =
h_{n+1} - h_n (n \geq 0)\)</span>，是序列的相邻项的差。</p></li>
<li><p><strong>定理8.2.2：</strong>差分表的第 <span
class="math inline">\(0\)</span> 条对角线等于 <span
class="math inline">\(c_0, c_1, c_2, …, c_p, 0, 0, 0, …\)</span>， 其中
<span class="math inline">\(c_p≠ 0\)</span> 的序列的通项满足： <span
class="math display">\[
h_n =
c_0 \left( \begin{matrix} n \\ 0 \end{matrix} \right) +
c_1 \left( \begin{matrix} n \\ 1 \end{matrix} \right) +
c_2 \left( \begin{matrix} n \\ 2 \end{matrix} \right) + \dots +
c_p \left( \begin{matrix} n \\ p \end{matrix} \right)
\]</span> 的关于 <span class="math inline">\(n\)</span> 的 <span
class="math inline">\(p\)</span> 次多项式。</p></li>
<li><p><strong>定理 8.2.3：</strong>假设序列 <span
class="math inline">\(h_0, h_1, h_2, …, h_n, …\)</span> 的差分表的第
<span class="math inline">\(0\)</span> 条对角线等于 <span
class="math inline">\(c_0, c_1, …, c_p, 0, 0,…\)</span> 那么 <span
class="math display">\[
\sum_{k=0}^n h_k =
c_0 \left( \begin{matrix} n+1 \\ 1 \end{matrix} \right) +
c_1 \left( \begin{matrix} n+1 \\ 2 \end{matrix} \right) +
c_2 \left( \begin{matrix} n+1 \\ 3 \end{matrix} \right) + \dots +
c_p \left( \begin{matrix} n+1 \\ p+1 \end{matrix} \right)
\]</span></p>
<p>其中差分表中第 <span class="math inline">\(0\)</span> 条对角线上的第
<span class="math inline">\(k\)</span> 个元素，记为 <span
class="math inline">\(c(p, k)\)</span>。</p></li>
<li><p><strong>第二类 <span class="math inline">\(Stirling\)</span>
数：</strong> <span class="math display">\[
h_n = n^p = \sum_{k=0}^n \dfrac{c(p,k)}{k!} [n]_k = \sum_{k=0}^n S(p,k)
[n]_k
\]</span> <span class="math inline">\([n]_k\)</span> = <span
class="math inline">\(n\)</span> 个不同元素中取 <span
class="math inline">\(k\)</span> 个元素的排列数 <span
class="math inline">\(P(n, k)\)</span></p></li>
<li><p><strong>定理8.2.4（第二类 <span
class="math inline">\(Stirling\)</span> 数的递推公式）：</strong>如果
<span class="math inline">\(1 ≤ k ≤ p-1\)</span> 则 <span
class="math inline">\(S(p, k) = kS(p-1,k) + S(p-1,
k-1)\)</span></p></li>
<li><p><strong>定理8.2.5（第二类 <span
class="math inline">\(Stirling\)</span> 数的组合解释）：</strong> 第二类
<span class="math inline">\(Stirling\)</span> 数 <span
class="math inline">\(S(p, k)\)</span> 计数的是把 <span
class="math inline">\(p\)</span> 个物品的集合划分到 <span
class="math inline">\(k\)</span>
个不可区分的盒子且没有空盒子的划分的个数。</p>
<ul>
<li><ol type="1">
<li>当 <span class="math inline">\(p\)</span> 独占一个盒子时， 当把
<span class="math inline">\(p\)</span> 从盒子中拿走时，得到剩下的 <span
class="math inline">\(\{1,2,…, p-1\}\)</span> 划分到 <span
class="math inline">\(k-1\)</span> 个非空且不可区分的盒子的划分。
因此，存在 <span class="math inline">\(S(p-1, k-1)\)</span> 种对 <span
class="math inline">\(\{1, 2, …, p\}\)</span> 的满足条件的划分。</li>
</ol></li>
<li><ol start="2" type="1">
<li>当 <span class="math inline">\(p\)</span> 不独占一个盒子时，
相当于先将 <span class="math inline">\(\{1, 2,…, p-1\}\)</span> 放到
<span class="math inline">\(k\)</span> 个盒子，不允许空盒， 共有 <span
class="math inline">\(S(p-1, k)\)</span> 种方案，然后将 <span
class="math inline">\(p\)</span> 放进其中一盒，由乘法原理得方案数为 $
kS(p-1, k)$ 。</li>
</ol></li>
</ul></li>
<li><p>常见的几个关系：</p>
<ul>
<li><span class="math inline">\(S(p,1) = 1\)</span></li>
<li><span class="math inline">\(S(p,2) = 2^{p-1} -1\)</span></li>
<li><span class="math inline">\(S(p,p-1) = \left( \begin{matrix} p \\ 2
\end{matrix} \right)\)</span></li>
<li><span class="math inline">\(S(p, p-2) = \left( \begin{matrix} p \\ 3
\end{matrix} \right) + 3 \left( \begin{matrix} p \\ 4 \end{matrix}
\right) (p \geq 2)\)</span></li>
</ul></li>
<li><p><strong><span class="math inline">\(Bell\)</span>
数：</strong><span class="math inline">\(Bell\)</span> 数是将 <span
class="math inline">\(p\)</span>
个元素的集合分成非空、不可区分的盒子的划分数，记为 <span
class="math inline">\(B_p\)</span>，则：（至少一个盒子， 最多 <span
class="math inline">\(p\)</span> 个盒子） <span class="math display">\[
B_p = S(p,0)+S(p,1)+\dots+S(p,p)
\]</span></p></li>
<li><p><strong>定理8.2.8（第一类 <span
class="math inline">\(Stirling\)</span> 数的递推公式）：</strong>如果
<span class="math inline">\(1≤ k ≤ p-1\)</span> 则： <span
class="math display">\[
s(p, k) = (p-1)s(p-1, k) + s(p-1, k-1)
\]</span></p></li>
<li><p><strong>定理8.2.9（第一类 <span
class="math inline">\(Stirling\)</span> 数的组合解释）：</strong>第一类
<span class="math inline">\(Stirling\)</span> 数 <span
class="math inline">\(s(p, k)\)</span> 是将 <span
class="math inline">\(p\)</span> 个物品排成 <span
class="math inline">\(k\)</span> 个非空的循环排列的方法数。</p>
<ul>
<li><p>设 <span class="math inline">\(p\)</span> 个物品记为 <span
class="math inline">\(1, 2, 3, …, p\)</span>。 将 <span
class="math inline">\(1, 2, 3, …, p\)</span> 排成 <span
class="math inline">\(k\)</span> 个圆圈有两种类型：</p>
<ol type="1">
<li><p>有一个循环排列中只有 <span class="math inline">\(p\)</span>
自己，则共有 <span class="math inline">\(s(p-1,
k-1)\)</span>种;</p></li>
<li><p><span class="math inline">\(p\)</span>
至少和另一个物品在一个循环排列中，则可以通过把 <span
class="math inline">\(1, 2, …, p-1\)</span> 排成 <span
class="math inline">\(k\)</span> 个循环排列，并把 <span
class="math inline">\(p\)</span> 放在 <span class="math inline">\(1, 2,
…, p-1\)</span> 任何 一个物品的左边得到，因此共有 <span
class="math inline">\((p-1) s(p-1, k)\)</span> 种。</p></li>
</ol></li>
</ul></li>
</ul>
<h4 id="分拆数">8.3 分拆数</h4>
<ul>
<li><p>设一个正整数 <span
class="math inline">\(n\)</span>，若存在正整数集 <span
class="math inline">\(\{n_1, n_2,…, n_k\} ( 1≤ k ≤ n，n_i ≤
n)\)</span>，使得 <span class="math inline">\(n_1+n_2+…+n_k=n\)</span>
，则称 <span class="math inline">\(\{n_1, n_2,…, n_k\}\)</span> 是 <span
class="math inline">\(n\)</span> 的一个分拆(或拆分)。 称每个 <span
class="math inline">\(n_i\)</span> 为 <span
class="math inline">\(n\)</span> 的一个部分（或类）。 记 <span
class="math inline">\(n\)</span> 的所有包含 <span
class="math inline">\(k\)</span> 个部分的不同分拆的个数为 <span
class="math inline">\(p_n^k\)</span>，<span
class="math inline">\(n\)</span> 的所有不同分拆的个数记为 <span
class="math inline">\(p_n\)</span>，称为 <span
class="math inline">\(n\)</span> 的分拆数。</p>
<ul>
<li><p>二者的关系为：<span class="math inline">\(p_n^1 + p_n^2 + \dots +
p_n^n = p_n\)</span></p></li>
<li><p>拆分中部分的顺序并不重要</p></li>
</ul></li>
<li><p><span class="math inline">\(n = na_n + (n-1)a_{n-1} + \dots +
2a_2 + a_1 = n\)</span> 对应 <span class="math inline">\(n\)</span>
的一个分拆记作：<span class="math inline">\(\lambda = n^{a_n} \dots
2^{a_2}1^{a_1}\)</span></p></li>
<li><p><strong>分拆数的递推关系：</strong><span
class="math inline">\(\sum_{j=1}^{k}p_n^j = p_{n+k}^k, p_n^1 = p_n^n =
1\)</span></p></li>
<li><p><strong>求 <span
class="math inline">\(p_n^k\)</span>：</strong><span
class="math inline">\(p_n^k = p_{n-k+k}^k =
\sum_{j=1}^kp_{n-k}^j\)</span></p></li>
<li><p><strong>定理8.3.1（转换关系）：</strong>设 <span
class="math inline">\(p_n(r)\)</span> 是最大部分为 <span
class="math inline">\(r\)</span> 的 <span
class="math inline">\(n\)</span> 的分拆的个数，<span
class="math inline">\(q_n(r)\)</span> 是满足分拆各部分不大于 <span
class="math inline">\(r\)</span> 的 <span
class="math inline">\(n-r\)</span> 的分拆数量，<span
class="math inline">\(p_n(r) = q_n(r)\)</span></p></li>
<li><p><strong><span class="math inline">\(Ferrers\)</span>
图：</strong><span class="math inline">\(k\)</span> 行，第 <span
class="math inline">\(i\)</span> 行有 <span
class="math inline">\(n_i\)</span> 点的左对齐点组</p></li>
<li><p><strong>共轭分拆：</strong>将分拆 <span
class="math inline">\(\lambda\)</span> 的 <span
class="math inline">\(Fereers\)</span> 图转置，记为 <span
class="math inline">\(\lambda^*\)</span></p>
<ul>
<li>原分拆的行数对应共轭分拆的最大部分</li>
</ul></li>
<li><p><strong>拆分数定理：</strong>正整数 <span
class="math inline">\(n\)</span> 分成 <span
class="math inline">\(k\)</span> 个部分的拆分个数，等于 <span
class="math inline">\(n\)</span> 分成以 <span
class="math inline">\(k\)</span> 为最大部分的拆分个数</p></li>
<li><p><strong>自共轭分拆：</strong><span class="math inline">\(\lambda
= \lambda*\)</span></p></li>
<li><p><strong>定理8.3.2</strong> 设 <span
class="math inline">\(n\)</span> 是正整数，设 <span
class="math inline">\(p_n^s\)</span> 等于 <span
class="math inline">\(n\)</span> 的自共轭分拆数， 而 <span
class="math inline">\(p_n^t\)</span>
等于分拆成互不相同的若干奇数和的分拆数，则有 <span
class="math display">\[
p_n^s = p_n^t
\]</span></p>
<ul>
<li>利用 <span class="math inline">\(Ferrers\)</span>
图建立两种分拆的一一对应</li>
</ul></li>
<li><p><strong>定理8.3.3（欧拉恒等式）：</strong>设 <span
class="math inline">\(n\)</span> 是正整数，设 <span
class="math inline">\(p_n^o\)</span> 是把 <span
class="math inline">\(n\)</span> 分成奇数和的分拆数， <span
class="math inline">\(p_n^d\)</span> 是把 <span
class="math inline">\(n\)</span> 分成不同部分的分拆个数。则 <span
class="math display">\[
p_n^o = p_n^d
\]</span></p>
<ul>
<li>利用 <span class="math inline">\(Ferrers\)</span>
图建立两种分拆的一一对应</li>
</ul></li>
<li><p>计算分拆数的方法：</p>
<ul>
<li><p>方法一：定理：<span class="math inline">\(n\)</span> 分拆数 <span
class="math inline">\(p_n^k\)</span> 满足下列递推关系： <span
class="math display">\[
\sum_{j=1}^k p_n^i = p_{n+k}^k, p_n^1 = p_n^n = 1
\]</span></p></li>
<li><p>方法二：生成函数（见下）</p></li>
</ul></li>
<li><p><strong>定理8.3.4</strong> 数列 <span class="math inline">\(p_0,
p_1, …, p_n, …\)</span> 的生成函数是 <span class="math display">\[
g(x) = \sum_{n=0}^\infty p_n x^n =
\prod_{k=1}^\infty (1-x^k)^{-1}
\]</span></p>
<ul>
<li><p>证明：由<span class="math inline">\((1-x^k)^{-1} =
1+x^k+x^{2k}+x^{3k}+\dots+x^{a_k k}+\dots\)</span>得 <span
class="math display">\[
\begin{align}
\prod_{k=1}^\infty (1-x^k)^{-1} =
&amp;(1+x+x^2+\dots+x^{1a_1}+\dots) \times  \\
&amp;(1+x^2+x^4+\dots+x^{2a_2}+\dots) \times    \\
&amp;(1+x^k+x^{2k}+\dots+x^{ka_k}+\dots) \times \dots \\
\end{align}
\]</span> 每一个项 <span class="math inline">\(x_n\)</span>
由通过从第一个因子选择 <span
class="math inline">\(x^{1a_1}\)</span>，从第二个因子选择项 <span
class="math inline">\(x^{2a_2}\)</span>，从第三个因子选择项 <span
class="math inline">\(x^{3a_3}\)</span> , <span
class="math inline">\(…\)</span> 得到，其中，<span
class="math inline">\(1a_1+2a_2+3a_3+… ka_k+… = n (0≤a_i
≤n)\)</span></p>
<p>显然，方程 <span class="math inline">\((1)\)</span>
的每个正整数解均对应 <span class="math inline">\(n\)</span>
的一个拆分，因此，<span class="math inline">\(x_n\)</span>
的系数，即方程 <span class="math inline">\((1)\)</span>
的非负整数解的个数，就是 <span class="math inline">\(n\)</span>
的分拆数。</p></li>
</ul></li>
<li><p>几个特殊的生成函数</p>
<ul>
<li><p><span class="math inline">\(n\)</span> 分成 <span
class="math inline">\(k\)</span> 个部分的分拆数 <span
class="math inline">\(p_n^k\)</span> 的生成函数——转化为以 <span
class="math inline">\(k\)</span> 为最大部分的拆分个数 <span
class="math display">\[
g(x)=x^k(1-x)^{-1}(1-x^2)^{-1}...(1-x^k)^{-1}
\]</span></p></li>
<li><p><span class="math inline">\(n\)</span> 分成奇数和的分拆数 <span
class="math inline">\(p_n\)</span> 的生成函数 <span
class="math display">\[
\begin{aligned}
g(x)&amp; =(1-x)^{-1}(1-x^3)^{-1}(1-x^5)^{-1}(1-x^7)^{-1}...  \\
&amp;=(1+x+x^2+...+x^{1a_1}+....)\times
(1+x^3+x^6+...+x^{3a_2}+....)\times (1+x^5+x^{10}+...+x^{5a_k}+....)
\end{aligned}
\]</span></p></li>
<li><p><span class="math inline">\(n\)</span> 分成互不相等的部分的分拆数
<span class="math inline">\(p_n\)</span> 的生成函数 <span
class="math display">\[
g(x)=(1+x)(1+x^2)(1+x^3)...(1+x^n)...
\]</span></p></li>
<li><p><span class="math inline">\(n\)</span>
分成互不相等的奇数部分的分拆数 <span class="math inline">\(p_n\)</span>
的生成函数 <span class="math display">\[
g(x)=(1+x)(1+x^3)(1+x^5)...(1+x^{2k-1})...
\]</span></p></li>
</ul></li>
</ul>
<h3 id="第14章-pólya-计数"><strong>第14章 <span
class="math inline">\(Pólya\)</span> 计数</strong></h3>
<blockquote>
<p>明确给出两种着色方案异同的数学定义</p>
<p>在规定每种颜色出现次数的情况下对着色方案数给出统一的表达式</p>
</blockquote>
<h4 id="置换群与对称群">14.1 置换群与对称群</h4>
<ul>
<li><p>群的定义：给定集合 <span class="math inline">\(G\)</span> 和
<span class="math inline">\(G\)</span> 上的二元运算 “<span
class="math inline">\(•\)</span>”，如果以下四个条件满足，则称代数结构
<span class="math inline">\((G, •)\)</span> 为群:</p>
<p>封闭性、结合律、单位元、逆元</p>
<ul>
<li>群的阶：有限群 <span class="math inline">\(G\)</span>
的元素个数，记为 <span class="math inline">\(|G|\)</span></li>
<li>循环群的生成元：<span class="math inline">\(\exists a \in
G\)</span>，<span class="math inline">\(G\)</span> 中任意元素 <span
class="math inline">\(b\)</span> 均可以表示成 <span
class="math inline">\(a\)</span> 的方幂，则称 <span
class="math inline">\(G\)</span> 为循环群，<span
class="math inline">\(a\)</span> 为该群生成元</li>
</ul></li>
<li><p>置换</p>
<ul>
<li>双射</li>
<li><span class="math inline">\(S_n\)</span> 为 <span
class="math inline">\(X = \{1,2, \dots, n\}\)</span> 的所有 <span
class="math inline">\(n!\)</span> 个置换构成的集合</li>
<li>是函数，可以合成
<ul>
<li>先 <span class="math inline">\(f\)</span> 后 <span
class="math inline">\(g\)</span> 记作 <span class="math inline">\(g
\circ f\)</span>，<span class="math inline">\(f\)</span> 的内容是 <span
class="math inline">\(i_k\)</span>，则 <span class="math inline">\(g
\circ f\)</span> 记作 <span class="math inline">\(j_{i_k}\)</span></li>
<li>满足分配律，通常不满足交换律</li>
</ul></li>
<li>特殊置换
<ul>
<li>自身合成置换</li>
<li>恒等置换</li>
<li>逆置换
<ul>
<li>求法：交换上下两行，然后按自然顺序重新排列第一行的整数</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>置换群：<span class="math inline">\(S_n\)</span> 的非空子集 <span
class="math inline">\(G\)</span>
满足如下四个性质，则称为置换的群，简称置换群</p>
<ul>
<li>封闭性、结合律、单位元、逆元</li>
<li><span class="math inline">\(S_n\)</span> 称为 <span
class="math inline">\(n\)</span> 阶对称群</li>
<li>仅含恒等置换的集合 <span class="math inline">\(G = \{ \iota
\}\)</span> 是一个置换群</li>
<li>置换群满足左消去：<span class="math inline">\(f \circ g = f \circ
h\)</span>，则 <span class="math inline">\(g = h\)</span></li>
</ul></li>
<li><p>几何图形 <span class="math inline">\(\Omega\)</span> 的对称</p>
<ul>
<li>看作顶点、边以及三维情形下的面上的一个置换</li>
<li>对称构成置换群，称为 <span class="math inline">\(\Omega\)</span>
的对称群
<ul>
<li>顶点对称群 <span class="math inline">\(G_c\)</span>
<ul>
<li><span class="math inline">\(n\)</span> 个旋转</li>
<li><span class="math inline">\(n\)</span> 个反射
<ul>
<li><span class="math inline">\(n\)</span> 为偶数：<span
class="math inline">\(\dfrac{n}{2}\)</span> 个关于对角点的反射，<span
class="math inline">\(\dfrac{n}{2}\)</span>
个关于对边中点连线的反射</li>
<li><span class="math inline">\(n\)</span> 为奇数：<span
class="math inline">\(n\)</span> 个关于角点与其对边中点的连线的反射</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>置换群与着色</p>
<ul>
<li><p>一个着色可由一个对称（置换）得到与其等价的另一个着色</p></li>
<li><p>定义 <span class="math inline">\(f * c\)</span> 是使 <span
class="math inline">\(i_k\)</span> 具有颜色 <span
class="math inline">\(c(k)\)</span> 的着色，即 <span
class="math inline">\((f*c)(i_k) = c(k)\)</span></p>
<p><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611210113545.png" alt="image-20230611210113545" style="zoom: 33%;" /></p></li>
<li><p><span class="math inline">\((g \circ f)*c =
g*(f*c)\)</span></p></li>
</ul></li>
<li><p>着色等价关系</p>
<ul>
<li><span class="math inline">\(C\)</span> 是 <span
class="math inline">\(X\)</span> 的一个着色集合，对于 <span
class="math inline">\(G\)</span> 中的任意置换 <span
class="math inline">\(f\)</span> 和 <span
class="math inline">\(C\)</span> 中任意着色 <span
class="math inline">\(c\)</span>，<span class="math inline">\(X\)</span>
的着色 <span class="math inline">\(f*c\)</span> 仍属于 <span
class="math inline">\(C\)</span></li>
<li>定义 <span class="math inline">\(C\)</span> 中关系 <span
class="math inline">\(\sim\)</span>：设 <span class="math inline">\(c_1,
c_2\)</span> 是 <span class="math inline">\(C\)</span>
中的任意两种着色，如果存在 <span class="math inline">\(G\)</span>
中的一个置换 <span class="math inline">\(f\)</span>，使得 <span
class="math inline">\(f*c_1 = c_2\)</span>，则称 <span
class="math inline">\(c_1\)</span> 等价于 <span
class="math inline">\(c_2\)</span>，记为 <span class="math inline">\(c_1
\sim c_2\)</span>
<ul>
<li>满足等价关系的自反性、对称性、传递性</li>
</ul></li>
</ul></li>
<li><p>计算非等价的着色数方法：</p>
<ul>
<li><span class="math inline">\(Burnside\)</span> 定理、<span
class="math inline">\(Pólya\)</span> 计算公式</li>
</ul></li>
</ul>
<h4 id="burnside-定理">14.2 <span
class="math inline">\(Burnside\)</span> 定理</h4>
<ul>
<li><p>稳定核与不变着色集</p>
<ul>
<li>使着色 <span class="math inline">\(c\)</span> 的 <span
class="math inline">\(G\)</span> 中所有置换的集合 <span
class="math inline">\(G(c) = \{f | f \in G, f*c = c\}, c\in
C\)</span>，称为 <span class="math inline">\(c\)</span> 的稳定核
<ul>
<li>任何着色 <span class="math inline">\(c\)</span>
的稳定核也形成一个置换群</li>
</ul></li>
<li>在置换 <span class="math inline">\(f\)</span> 作用下保持不变的 <span
class="math inline">\(C\)</span> 中所有着色的集合 <span
class="math inline">\(C(f) = \{c | c \in C, f*c = c\}, f \in G\)</span>
称为 <span class="math inline">\(f\)</span> 的不变着色集</li>
</ul></li>
<li><p><strong>定理14.2.3 (<span class="math inline">\(Burnside\)</span>
定理)：</strong>设 <span class="math inline">\(G\)</span> 是 <span
class="math inline">\(X\)</span> 的置换群，<span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(X\)</span> 中一个满足下面条件的着色集合：对于
<span class="math inline">\(G\)</span> 中所有 <span
class="math inline">\(f\)</span> 与 <span
class="math inline">\(C\)</span> 中所有 <span
class="math inline">\(c\)</span>，<span
class="math inline">\(f∗c\)</span> 仍在 <span
class="math inline">\(C\)</span> 中，则 <span
class="math inline">\(C\)</span> 中非等价的着色数 <span
class="math inline">\(N(G, C)\)</span> 为 ： <span
class="math display">\[
N(G,C) = \dfrac{1}{|G|} \sum_{f \in G} |C(f)| = \dfrac{1}{|G|} \sum_{c
\in C} |G(c)|
\]</span> 即，<span class="math inline">\(C\)</span>
中非等价的着色数等于在 <span class="math inline">\(G\)</span>
中的置换作用下保持不变的着色的平均数。<span class="math inline">\(C(f) =
\{c|c \in C, f * c = c\}, f \in G\)</span></p>
<p>具体地，设<span
class="math inline">\(G=\{f_1,f_2,\dots,f_n\}\)</span>，则<span
class="math inline">\(N(G,C) = \dfrac{1}{n} \sum_{i=1}^n
|C(f_i)|\)</span></p></li>
<li><p>计数非等价的着色数 <span class="math inline">\(N(G,C)\)</span>
的步骤：</p>
<ul>
<li>确定置换群 <span class="math inline">\(G\)</span>，确定着色集 <span
class="math inline">\(C\)</span></li>
<li>计数 <span class="math inline">\(G\)</span>
中每个置换的不变着色集（或每个着色的稳定核）的大小</li>
<li>套用公式</li>
</ul></li>
<li><p>例：用红、蓝两种颜色给一个正方形的 <span
class="math inline">\(4\)</span>
个顶点着色，试问存在多少种不同的着色方法数</p></li>
<li><p>例(循环排列计数) ：把 <span class="math inline">\(n\)</span>
个不同的对象放在一个圆上，有多少种放法</p></li>
</ul>
<h4 id="pólya-计数">14.3 <span class="math inline">\(Pólya\)</span>
计数</h4>
<blockquote>
<p><span class="math inline">\(Burnside\)</span>
定理计数部分比较复杂，仅考虑置换的循环结构并引入有向圈概念</p>
</blockquote>
<ul>
<li><p><strong>置换循环结构</strong>：<span
class="math inline">\(f\)</span> 是置换，<span class="math inline">\(D_f
= (X, A_f)\)</span> 是顶点集为 <span class="math inline">\(X\)</span>
且边集为 <span class="math inline">\(A_f = \{(i, f(i)) | i \in
X\}\)</span> 的有向图</p>
<ul>
<li><span class="math inline">\(D_f\)</span> 有 <span
class="math inline">\(n\)</span> 个顶点和 <span
class="math inline">\(n\)</span> 条边，且各顶点的入度和出度均为 <span
class="math inline">\(1\)</span></li>
<li>弧集 <span class="math inline">\(A_f\)</span>
可以被划分为若干个有向圈，且每个顶点恰好属于一个有向圈</li>
<li><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611213804336.png" alt="image-20230611213804336" style="zoom:33%;" /></li>
<li><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611213914755.png" alt="image-20230611213914755" style="zoom:33%;" /></li>
</ul></li>
<li><p><strong>循环因子分解</strong></p>
<ul>
<li><p>循环因子分解是唯一的，但是循环出现的次序可以任意变化</p></li>
<li><p><span class="math inline">\(1\)</span> 循环也即恒等置换</p></li>
<li><p>在 <span class="math inline">\(f\)</span> 的循环因子分解中，<span
class="math inline">\(X\)</span> 中的每个元素只出现一次</p></li>
<li><p>例：设 <span class="math inline">\(X=\{1,2,3,4,5,6,7,8\}\)</span>
的置换 <span class="math inline">\(f\)</span> 为：<span
class="math inline">\(f=\pmatrix{1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8\\
6&amp;8&amp;5&amp;4&amp;1&amp;3&amp;2&amp;7}\)</span></p>
<p><span class="math inline">\(|C(f)|=4^3=64\)</span></p></li>
</ul></li>
<li><p><strong>定理14.3.1：</strong>设 <span
class="math inline">\(f\)</span> 是集合 <span
class="math inline">\(X\)</span> 的一个置换。假如用 <span
class="math inline">\(k\)</span> 种颜色对 <span
class="math inline">\(X\)</span> 的元素进行着色。令 <span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(X\)</span> 的所有着色的集合，则 <span
class="math inline">\(f\)</span> 保持 <span
class="math inline">\(C\)</span> 中着色不变的着色数为：<span
class="math inline">\(|C(f )|=k^{\#(f)}\)</span></p>
<ul>
<li>和循环因子分解中循环个数有关，而与每个循环的阶数无关</li>
<li><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611221943614.png" alt="image-20230611221943614" style="zoom:33%;" /></li>
</ul></li>
<li><p><strong>置换的类型：</strong><span
class="math inline">\(f\)</span> 的循环因子分解中有 <span
class="math inline">\(e_1\)</span> 个 <span
class="math inline">\(1\)</span> - 循环，<span
class="math inline">\(e_2\)</span> 个 <span
class="math inline">\(2\)</span> - 循环，<span
class="math inline">\(\dots\)</span> <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(n\)</span> - 循环，满足 <span
class="math inline">\(1e_1+2e_2+...+ne_n=n\)</span>，称 <span
class="math inline">\(n\)</span> 元组 <span
class="math inline">\((e_1,e_2,...,e_n)\)</span> 是置换 <span
class="math inline">\(f\)</span> 的类型，记作 <span
class="math inline">\(type(f) = (e_1,e_2,...,e_n)\)</span></p></li>
<li><p><strong>置换的单项式：</strong>引入 <span
class="math inline">\(n\)</span> 个变量 <span
class="math inline">\(z_1,z_2,...,z_n\)</span>，<span
class="math inline">\(z_k\)</span> 对应 <span
class="math inline">\(k\)</span> 循环 <span class="math inline">\((k =
1,2, \dots, n)\)</span>，定义 <span class="math inline">\(f\)</span>
的单项式为 <span class="math inline">\(mon(f) =
z_1^{e_1}~z_2^{e_2}...z_n^{e_n}\)</span></p>
<ul>
<li>单项式的总次数 <span class="math inline">\(e_1+e_2+...+e_n =
\#(f)\)</span></li>
<li>按照类型的生成函数是 <span class="math inline">\(G\)</span>
中所有置换的单项式的和 <span class="math inline">\(\sum_{f\in
G}mon(f)=\sum_{f\in
G}{z_1}^{e_1}{z_2}^{e_2}...{z_n}^{e_n}\)</span>，系数对应类型为 <span
class="math inline">\((e_1,e_2, \dots, e_n)\)</span> 的置换的个数</li>
</ul></li>
<li><p><strong>置换的循环指数：</strong><span
class="math inline">\(P_G(z_1,z_2,...,z_n)=\dfrac{1}{|G|}\sum_{f\in
G}mon(f)=\dfrac{1}{|G|}\sum_{f\in
G}{z_1}^{e_1}{z_2}^{e_2}...{z_n}^{e_n}\)</span></p>
<ul>
<li><p>例：求二面体群 <span class="math inline">\(D_4\)</span>
的循环指数</p>
<p><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230613133725520.png" alt="image-20230613133725520" style="zoom:33%;" /></p>
<p><span
class="math inline">\(P_{D_4}(z_1,z_2,z_3,z_4)=\dfrac{1}{8}(z_1^4+2z_4+3z_2^2+2z_1^2z_2)\)</span></p></li>
<li><p>用循环指数计算非等价着色数</p>
<ul>
<li><p>用 <span class="math inline">\(z_i = k\)</span> 代入 <span
class="math inline">\(P_G\)</span> 中</p></li>
<li><p><span
class="math inline">\(P_G(z_1,z_2,...,z_n)=\dfrac{1}{|G|}\sum_{f\in
G}mon(f)=\dfrac{1}{|G|}\sum_{f\in
G}{z_1}^{e_1}{z_2}^{e_2}...{z_n}^{e_n}\)</span></p></li>
<li><p><span class="math inline">\(|C(f)| =k^{\#(f)} = k^{e_1+e_2+ \dots
+e_n} = k^{e_1}k^{e_2} \dots k^{e_n}\)</span></p></li>
<li><p><span class="math inline">\(N(G,C)=\dfrac{1}{|G|}\sum_{f\in
G}|C(f)| =\dfrac{1}{|G|}\sum_{f\in G}k^{e_1}k^{e_2}\dots k^{e_n}
=P_G(k,k,...,k)\)</span>w</p></li>
</ul></li>
</ul></li>
<li><p><strong>定理14.3.2：</strong><span
class="math inline">\(N(G,C)=P_G(k,k,...,k)\)</span></p>
<ul>
<li><p>例：求用 <span class="math inline">\(k\)</span>
种颜色对正方形的顶点进行着色的非等价着色数</p>
<ul>
<li>图略</li>
<li><span
class="math inline">\(P_{D_4}(z_1,z_2,z_3,z_4)=\dfrac{1}{8}(z_1^4+2z_4+3z_2^2+2z_1^2z_2)\)</span></li>
<li><span
class="math inline">\(N(D_4,C)=P_{D_4}(k,k,k,k)=\dfrac{1}{8}(k^4+2k+3k^2+2k^2k)=\dfrac{1}{8}(k^4+2k^3+3k^2+2k)\)</span></li>
</ul></li>
</ul></li>
<li><p><strong>二元变量生成函数：</strong>非等价着色数等于 <span
class="math inline">\(P_G(r+b, r^2+b^2, \dots, r^n+b^n)\)</span> 中
<span class="math inline">\(r^pb^q\)</span> 的系数</p>
<ul>
<li><p>例：用 <span class="math inline">\(2\)</span>
种颜色对一个正方形的顶点着色，求它们的非等价着色数的生成函数</p>
<p>​ <span
class="math inline">\(P_{D_4}(z_1,z_2,z_3,z_4)=\dfrac{1}{8}(z_1^4+2z_4+3z_2^2+2z_1^2z_2)\)</span></p>
<p>​ <span class="math inline">\(\begin{aligned}
&amp;P_{D_4}(r+b,r^2+b^2,r^3+b^3,r^4+b^4) \\
&amp;=\dfrac{1}{8}((r+b)^4+2(r^4+b^4)+3(r^2+b^2)^2+2(r+b)^2(r^2+b^2)) \\
&amp;=r^4+r^3b+2r^2b^2+r b^3+b^4. \end{aligned}\)</span></p></li>
</ul></li>
<li><p><strong><span class="math inline">\(Pólya\)</span>
定理：</strong><span
class="math inline">\(\{u_1,u_2,\ldots,u_k\}\)</span> 是 <span
class="math inline">\(k\)</span> 种颜色的一个集合，则针对各颜色数目的
<span class="math inline">\(C\)</span>
的非等价着色数的生成函数是由循环指数 <span
class="math inline">\(P_G(z_1,z_2,...,z_n)\)</span> 通过做变量代换 <span
class="math inline">\(z_j=u_1^j+u_2^j+...+u_k^j(j=1,2,...,n)\)</span>
得到的表达式 <span
class="math inline">\(P_G(u_1+u_2+\text{...}+u_k,u_1^2+u_2^2+\text{...}+u_k^2,\text{...},u_1^n+u_2^n+\text{...}+u_k^n)\)</span></p>
<ul>
<li><p><span
class="math inline">\(u_1^{p_1}u_2^{p_2}...u_k^{p_k}\)</span> 的系数等于
<span class="math inline">\(X\)</span> 中的 <span
class="math inline">\(p_1\)</span> 个元素着色成 <span
class="math inline">\(u_1\)</span>，<span
class="math inline">\(p_2\)</span> 个元素着色成 <span
class="math inline">\(u_2\)</span>，<span
class="math inline">\(\dots\)</span>，<span
class="math inline">\(p_k\)</span> 个元素着色成 <span
class="math inline">\(u_k\)</span> 的非等价的着色数</p></li>
<li><p>例：用 <span class="math inline">\(3\)</span>
种颜色对一个正方形的顶点着色，求它们的非等价着色数的生成函数</p>
<p>​ <span
class="math inline">\(P_{D_4}(z_1,z_2,z_3,z_4)=\dfrac{1}{8}(z_1^4+2z_4+3z_2^2+2z_1^2z_2)\)</span></p>
<p>​ <span class="math inline">\(\begin{aligned}
&amp;P_{D_4}(r+b+g,r^2+b^2+b^2,r^3+b^3+g^3,r^4+b^4+g^4) \\
&amp;=\dfrac{1}{8}((r+b+g)^4+2(r^4+b^4+g^4)+3(r^2+b^2+g^2)^2+2(r+b+g)^2(r^2+b^2+g^2))
\\ \end{aligned}\)</span></p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Mathematics</category>
        <category>S4</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Combinatorics</tag>
      </tags>
  </entry>
  <entry>
    <title>「SUSTECH-C++11」</title>
    <url>/cpp11-sustech/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>Notes of SUSTECH C++11</p>
</blockquote>
<span id="more"></span>
<h1 id="chapter1-introduction-and-background">Chapter1 Introduction and
Background</h1>
<blockquote>
<p>第一章、基础知识</p>
</blockquote>
<h2 id="g">g++</h2>
<p>1、编译 hello.cpp 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ hello.cpp</span><br></pre></td></tr></table></figure>
<p>2、使用 c++11：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ hello.cpp --std=c++11</span><br></pre></td></tr></table></figure>
<p>3、自定义生成文件名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ hello.cpp --std=c++11 -o hello</span><br></pre></td></tr></table></figure>
<p>4、运行生成的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></table></figure>
<h2 id="compile-and-link">Compile and Link</h2>
<p>函数声明一般放在 <code>*.hpp</code> 文件中</p>
<p>分门别类管理，节约编译时间，条理清晰</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mul.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pick two integers:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cin &gt;&gt; b;</span><br><span class="line">    result = <span class="built_in">mul</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The result is &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mul.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mul.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mul.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="Images/compile-and-link.png" alt="compile-and-link" />
<figcaption aria-hidden="true">compile-and-link</figcaption>
</figure>
<p>注：g++ 的 -c 选项表示只编译不链接。</p>
<p>好处：分开编译，<strong>节约编译时间</strong></p>
<p><strong>引号和尖括号引用的区别</strong></p>
<ul>
<li>尖括号：编译器从编译器指定的 include 路径寻找头文件</li>
<li>引号：从指定的和当前路径寻找</li>
</ul>
<h2 id="debug">Debug</h2>
<p>错误三大类：</p>
<ul>
<li>编译错误：编译时就出错了，一般由语法造成</li>
<li>链接错误：错误提示一般与 symbol 有关，顺藤摸瓜查这个符号</li>
<li>运行错误：编译链接正常，运行时报错</li>
</ul>
<h2 id="preprocessor-and-macros">Preprocessor and Macros</h2>
<p>预处理指令是以“#”开头的指令，只能占一行，换行需要转义符</p>
<h2 id="simple-input-and-output">Simple Input and Output</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::ostream cout;</span><br><span class="line">std::istream cin;</span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt;</code> 是运算符，采用运算符重载定义，返回值依然是
<code>cout</code>，故可以链式调用</p>
<h2 id="arguments">Arguments</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments.cpp</span></span><br></pre></td></tr></table></figure>
<h1 id="chapter2-data-types-and-arithmetic-operations">Chapter2 Data
Types and Arithmetic Operations</h1>
<blockquote>
<p>第二章、数据类型及算术运算</p>
<p>整形类型，浮点类型，算数运算，类型转换</p>
</blockquote>
<h2 id="integer-numbers">Integer Numbers</h2>
<p>Please initialize variables <strong>EXPLICITLY</strong>!</p>
<p>新的初始化方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span> <span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> num &#123;<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="data-width-and-more-integer-types">Data Width and More Integer
Types</h2>
<p>C 和 C++ 标准并未固定数据位宽</p>
<p><code>long long int</code> 保证 64 位</p>
<p><code>sizeof</code> 是
<code>operator</code>，因为函数的参数必须是变量</p>
<p>c++标准并没有规定char（-128~127）表示unsigned char（0~255）还是signed
char。不同平台不一样。</p>
<p>从c++11开始增加了 char16_t（16位的char）、char32_t（32位的char）
类型，可以表示中文字符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="type">16_t</span> c = <span class="string">u&#x27;于&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="type">32_t</span> c = <span class="string">U&#x27;于&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>字符类型前面添加 <code>+</code> 会隐式转换为整数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> i = b; <span class="comment">// the value of i is 1</span></span><br><span class="line"><span class="type">bool</span> b = <span class="number">-256</span>; <span class="comment">// 非0值均为1 unrecommended conversion</span></span><br><span class="line"><span class="type">bool</span> b = (<span class="number">-256</span> != <span class="number">0</span>); <span class="comment">// better choice</span></span><br></pre></td></tr></table></figure>
<h2 id="boolean-in-c">Boolean in C</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> <span class="type">bool</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="textttsize_t"><span
class="math inline">\(\texttt{size\_t}\)</span></h2>
<p><code>sizeof</code> 的返回值类型</p>
<p>表达内存、表达元素的个数等等</p>
<p>自减时不会减到负数，循环时不能自减，否则会无限循环</p>
<h2 id="fixed-width-integer-types-since-c11">Fixed Width Integer Types
(since C++11)</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Defined in &lt;cstdint&gt;</span></span><br><span class="line"><span class="type">int8_t</span>;</span><br><span class="line"><span class="type">int16_t</span>;</span><br><span class="line"><span class="type">int32_t</span>;</span><br><span class="line"><span class="type">int64_t</span>;</span><br><span class="line"><span class="type">uint8_t</span>;</span><br><span class="line"><span class="type">uint16_t</span>;</span><br><span class="line"><span class="type">uint32_t</span>;</span><br><span class="line"><span class="type">uint64_t</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some useful macros</span></span><br><span class="line">INT8_MIN;</span><br><span class="line">INT16_MIN;</span><br><span class="line">INT32_MIN;</span><br><span class="line">INT64_MIN;</span><br><span class="line">INT8_MAX;</span><br><span class="line">INT16_MAX;</span><br><span class="line">INT32_MAX;</span><br><span class="line">INT64_MAX;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="floating-point-numbers">Floating Point Numbers</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> f1 = <span class="number">1.2f</span>;</span><br><span class="line">    <span class="type">float</span> f2 = f1 * <span class="number">1000000000000000</span>; <span class="comment">//1.0e15</span></span><br><span class="line">    cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因在于小数是无限的，计算机表示数据有位数限制。写一个很长的小数，计算机不一定能表示出来。所以计算机表示浮点数的时候进行了采样。比如上面要表示一个15位有效数字的1.2，得到的是计算机在那段范围进行了采样后的结果。</p>
<p>如果支持 <code>long double</code>，则为 128
位。半精度是深度学习中大量使用的，但是不属于 C++ 标准</p>
<p>double 类型的数据操作比 float 更慢。</p>
<h2 id="constant-numbers">Constant Numbers</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">95</span>; <span class="comment">// decimal</span></span><br><span class="line"><span class="number">0137</span>; <span class="comment">// octal</span></span><br><span class="line"><span class="number">0x5F</span>; <span class="comment">// hexadecimal</span></span><br><span class="line"><span class="number">95</span>; <span class="comment">// int</span></span><br><span class="line"><span class="number">95u</span>; <span class="comment">// unsigned int</span></span><br><span class="line"><span class="number">95l</span>; <span class="comment">// long</span></span><br><span class="line"><span class="number">95ul</span>; <span class="comment">// unsigned long</span></span><br><span class="line"><span class="number">95lu</span>; <span class="comment">// unsigned long</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.02e23</span>L; <span class="comment">// long double</span></span><br></pre></td></tr></table></figure>
<h2 id="textttauto"><span
class="math inline">\(\texttt{auto}\)</span></h2>
<p><code>auto</code> is placeholder type specifier</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">2</span>; <span class="comment">// int</span></span><br><span class="line"><span class="keyword">auto</span> bc = <span class="number">2.3</span>; <span class="comment">// double</span></span><br><span class="line"><span class="keyword">auto</span> c; <span class="comment">// valid in C, error in C++</span></span><br><span class="line"><span class="keyword">auto</span> d = a * <span class="number">1.2</span>; <span class="comment">// double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Question</span></span><br><span class="line"><span class="keyword">auto</span> a = <span class="number">2</span>;</span><br><span class="line">a = <span class="number">2.3</span>; <span class="comment">// will a be converted to double again? No</span></span><br></pre></td></tr></table></figure>
<h2 id="conversion">Conversion</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num1 = (<span class="type">int</span>)<span class="string">&#x27;C&#x27;</span>; <span class="comment">// C-style</span></span><br><span class="line"><span class="type">int</span> num2 = <span class="built_in">int</span>(<span class="string">&#x27;C&#x27;</span>); <span class="comment">// function style</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">17</span> / <span class="number">5</span>; <span class="comment">// f will be 3.f</span></span><br></pre></td></tr></table></figure>
<h1 id="chapter3-statements">Chapter3 Statements</h1>
<blockquote>
<p>第三章、语句</p>
</blockquote>
<h2 id="assign-statement">Assign Statement</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="type">int</span> * p = <span class="built_in">get</span>())&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>赋值表达式的值是等号右边的内容。</p>
<h2 id="textttgoto"><span
class="math inline">\(\texttt{goto}\)</span></h2>
<p>在函数的末尾进行错误处理、清理等操作。当程序出错时跳转到错误处理的相关代码，其他情况不建议使用
goto 语句。</p>
<h2 id="textttswitch"><span
class="math inline">\(\texttt{switch}\)</span></h2>
<p>更像 goto 语句，所以要注意写 break</p>
<h1 id="chapter4-arrays">Chapter4 Arrays</h1>
<blockquote>
<p>数组</p>
<p>数组（一维数组，定长数组，变长数组，多维数组，常量数组等等，字符串string），结构体(struct)【将不同的数据类型统一起来，用法基本上同后面学到的类】，联合体（union）【共享同一块地址】以及枚举（enum）[替换常量],</p>
</blockquote>
<h2 id="variable-length-arrays">Variable-length Arrays</h2>
<p>运行时才能确定数组的大小，如果用常量开，编译时便可确定</p>
<p>不一定能够直接初始化</p>
<p>C 和 C++
禁止数组首地址的赋值，这样两个数组地址指向同一块内存，有一个数组丢失</p>
<p>循环逐个赋值或者内存拷贝函数赋值</p>
<p>无越界检查</p>
<p>在 C/C++ 中数组不是对象，这点不同于 Java</p>
<h2 id="textttconst-arrays"><span
class="math inline">\(\texttt{const}\)</span> arrays</h2>
<p>常常用作函数传参</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">wchat_t</span>[] s1 = <span class="string">L&quot;ABCD&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char16_t</span>[] s2 = <span class="string">u&quot;ABCD&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char32_t</span>[] s3 = <span class="string">U&quot;ABCD&quot;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span>* dst, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果溢出了也会继续复制，所以有了更安全的 <code>strncpy</code></p>
<h2 id="textttstring-class"><span
class="math inline">\(\texttt{string}\)</span> class</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot;Lee&quot;</span>;</span><br><span class="line">std::string result = str1 + <span class="string">&quot;, &quot;</span> + str2;</span><br></pre></td></tr></table></figure>
<h2 id="different-types-of-textttstring">Different Types of <span
class="math inline">\(\texttt{string}\)</span></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string</span><br><span class="line">std::wstring</span><br><span class="line">std::u8string <span class="comment">// C++20</span></span><br><span class="line">std::u16string <span class="comment">// C++11</span></span><br><span class="line">std::u32string <span class="comment">// C++11</span></span><br></pre></td></tr></table></figure>
<p>直接用方括号下标访问不会有异常，at 方法越界会有异常</p>
<h2 id="textttstruct"><span
class="math inline">\(\texttt{struct}\)</span></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> point1 = &#123;.type=TYPE_INT8, .data8=&#123;<span class="number">-2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="textttenum"><span
class="math inline">\(\texttt{enum}\)</span></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123;WHITE, BLACK, RED, GREEN, BLUE, YELLOW, NUM_COLORS&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> pen_color = RED;</span><br><span class="line">pen_color = <span class="built_in">color</span>(<span class="number">3</span>); <span class="comment">// type convertion</span></span><br><span class="line">pen_color += <span class="number">1</span>; <span class="comment">// ERROR!</span></span><br><span class="line"><span class="type">int</span> color_index = pen_color;</span><br><span class="line">color_index += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="texttttypedef"><span
class="math inline">\(\texttt{typedef}\)</span></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> vec3b[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> color[<span class="number">3</span>];</span><br><span class="line">vec3b color = &#123;<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="chapter5-pointers-and-memory-management">Chapter5 Pointers and
Memory Management</h1>
<blockquote>
<p>第五章、指针与内存管理</p>
</blockquote>
<h2 id="constant-pointers">Constant Pointers</h2>
<p>指针指向的内容不能通过 <code>*</code> 取内容来修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// You cannot change the value p1 points to through p1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * p1 = &amp;num;</span><br><span class="line">*p1 = <span class="number">3</span>; <span class="comment">// error</span></span><br><span class="line">num = <span class="number">3</span>; <span class="comment">// okay</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You cannot change the value of p2</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p2 = &amp;num;</span><br><span class="line">*p2 = <span class="number">3</span>; <span class="comment">// okay</span></span><br><span class="line"><span class="type">int</span> another = <span class="number">2</span>;</span><br><span class="line">p2 = &amp;another; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You cannot change either of them</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p3 = &amp;num;</span><br><span class="line"><span class="comment">// But you can still change num directly</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// play a trick to remove const restriction?</span></span><br><span class="line">    <span class="type">char</span> * p2 = p; <span class="comment">// syntax error</span></span><br><span class="line">    <span class="comment">// You cannot assign a const pointer to non-const one</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="textttsize_t-1"><span
class="math inline">\(\texttt{size\_t}\)</span></h2>
<p>一个无符号整型，表示当前系统内存中可以存储的最大对象的大小。</p>
<h2 id="memory-types">Memory Types</h2>
<ul>
<li>代码区：存放程序的执行指令，试图写入的操作会被系统 kill。</li>
<li>静态变量区：初始化的、未初始化的分开存放。</li>
<li>堆内存区：动态申请的内存会存放此处，</li>
<li>栈内存区：临时、局部变量存放在此区。</li>
</ul>
<p><img src="Images/memory-types.png" alt="memory-types" style="zoom:50%;" /></p>
<h2 id="textttvoid-malloc-size_t-size"><span
class="math inline">\(\texttt{void* malloc( size\_t size
)}\)</span></h2>
<ul>
<li>单位是字节。</li>
<li>分配的内存是未初始化的，不改变原有存储内容。</li>
<li>存在内存对齐机制，比如：int * p1 = (int*) malloc
(4);只想分配4字节，但是不同操作系统分配的是不同的，有的会最小分配4字节，有的会最小分配16字节。</li>
<li><strong>当程序结束后操作系统会把分配给该程序的所有内存回收。</strong></li>
</ul>
<h2 id="memory-leak">Memory Leak</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="number">4</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">p = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="textttnew"><span
class="math inline">\(\texttt{new}\)</span></h2>
<blockquote>
<p>Operator new is similar with malloc() but with more features</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//allocate an int, default initializer (do nothing)</span></span><br><span class="line"><span class="type">int</span> * p1 = <span class="keyword">new</span> <span class="type">int</span>; </span><br><span class="line"><span class="comment">//allocate an int, initialized to 0</span></span><br><span class="line"><span class="type">int</span> * p2 =  <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line"><span class="comment">//allocate an int, initialized to 5</span></span><br><span class="line"><span class="type">int</span> * p3 =  <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>); </span><br><span class="line"><span class="comment">//allocate an int, initialized to 0</span></span><br><span class="line"><span class="type">int</span> * p4 =  <span class="keyword">new</span> <span class="type">int</span>&#123;&#125;;<span class="comment">//C++11    </span></span><br><span class="line"><span class="comment">//allocate an int, initialized to 5</span></span><br><span class="line"><span class="type">int</span> * p5 =  <span class="keyword">new</span> <span class="type">int</span> &#123;<span class="number">5</span>&#125;;<span class="comment">//C++11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//allocate a Student object, default initializer</span></span><br><span class="line">Student * ps1 = <span class="keyword">new</span> Student;</span><br><span class="line"><span class="comment">//allocate a Student object, initialize the members</span></span><br><span class="line">Student * ps2 = <span class="keyword">new</span> Student &#123;<span class="string">&quot;Yu&quot;</span>, <span class="number">2020</span>, <span class="number">1</span>&#125;; <span class="comment">//C++11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//allocate 16 int, default initializer (do nothing) </span></span><br><span class="line"><span class="type">int</span> * pa1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">16</span>];</span><br><span class="line"><span class="comment">//allocate 16 int, zero initialized </span></span><br><span class="line"><span class="type">int</span> * pa2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">16</span>]();</span><br><span class="line"><span class="comment">//allocate 16 int, zero initialized </span></span><br><span class="line"><span class="type">int</span> * pa3 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">16</span>]&#123;&#125;; <span class="comment">//C++11</span></span><br><span class="line"><span class="comment">//allocate 16 int, the first 3 element are initialized to 1,2,3, the rest 0</span></span><br><span class="line"><span class="type">int</span> * pa4 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">16</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//C++11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//allocate memory for 16 Student objects, default initializer</span></span><br><span class="line">Student * psa1 = <span class="keyword">new</span> Student[<span class="number">16</span>];</span><br><span class="line"><span class="comment">//allocate memory for 16 Student objects, the first two are explicitly initialized</span></span><br><span class="line">Student * psa2 = <span class="keyword">new</span> Student[<span class="number">16</span>]&#123;&#123;<span class="string">&quot;Li&quot;</span>, <span class="number">2000</span>,<span class="number">1</span>&#125;, &#123;<span class="string">&quot;Yu&quot;</span>, <span class="number">2001</span>,<span class="number">1</span>&#125;&#125;; <span class="comment">//C++11</span></span><br></pre></td></tr></table></figure>
<h2 id="textttdelete"><span
class="math inline">\(\texttt{delete}\)</span></h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//deallocate memory</span></span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="comment">//deallocate memory</span></span><br><span class="line"><span class="keyword">delete</span> ps1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//deallocate the memory of the array</span></span><br><span class="line"><span class="keyword">delete</span> pa1;</span><br><span class="line"><span class="comment">//deallocate the memory of the array</span></span><br><span class="line"><span class="keyword">delete</span> []pa2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//deallocate the memory of the array, and call the destructor of the first element</span></span><br><span class="line"><span class="keyword">delete</span> psa1;</span><br><span class="line"><span class="comment">//deallocate the memory of the array, and call the destructors of all the elements</span></span><br><span class="line"><span class="keyword">delete</span> []psa2;</span><br></pre></td></tr></table></figure>
<p>养成用 <code>delete []</code> 的习惯是比较安全的</p>
<h1 id="chapter6-7-functions">Chapter6-7 Functions</h1>
<blockquote>
<p>第六章、函数</p>
<p>1、函数的定义 2、函数的返回值（本质就是值复制）
3、函数的参数（深拷贝与浅拷贝
也就是对应大的值传递还是地址传递地问题。最终在实际中的体现就是深拷贝在函数里面的修改会对外面的参数有影响。）
4、函数的声明与使用（通常函数编辑的时候，首先在入口处要对参数进行各种检查，这样可以避免出现BUG）
5、引用：相比较于指针，引用一定要初始化，会更加的安全。
6、内联函数，就是以空间换时间的作用；</p>
<p>第七章、函数的扩展：默认参数问题以及函数模板等等
1、默认参数都是从后面开始写的；
2、函数的重载：函数名相同，签名不同的函数，主要的作用就是在调用的时候能根据参数的传入不同，调用不同的函数体。
3、函数模板：本质上就是泛型，类似于C#中的泛型，在定义的时候是不会生成代码，在实例化的时候才生成真正的代码。
多态的本质就是延迟定义，这样可以让程序变得更加灵活。 4、函数指针：
就是指向函数的指针。
类似于C#中的委托，这样做到深层次可以实现事件进行异步通讯。 5、函数引用：
6、递归函数：优点就是可以让复杂程序变得简单，比如树的遍历等等；缺点就是占据内存高，计算复杂度高，同时耗时且理解困难。</p>
</blockquote>
<p>The parameters should be checked first!!</p>
<p>好的风格是先声明，否则要不断调整函数的顺序</p>
<p>一般把函数的声明放在头文件里</p>
<h2 id="function-calling">Function Calling</h2>
<ul>
<li>应用程序执行的时候实际上是二进制指令一条条地往CPU里面搬，每一段代码都是一条条指令。</li>
<li>当碰到函数时，因为函数的指令不一定和当前执行的指令放在一起的，那么在执行函数时会跳到其他位置去执行，在跳之前一般要保存当前的状态，即各种数据入栈。</li>
<li>执行完函数之后从栈中取出各种数据。拿到函数返回值（如果有），继续执行原来的代码。</li>
<li>程序执行的代价就是各种数据的出入栈的花费，如果函数非常复杂那么代价可以忽略不计，如果是简单的函数又频繁调用代价就大了，这时候可以设为内联函数。</li>
</ul>
<h2 id="references">References</h2>
<blockquote>
<p>an alias to an already-existing variable/object</p>
</blockquote>
<ul>
<li>A reference <strong>must</strong> be initialized after its
declaration.</li>
<li>References are much safer.</li>
<li>Affecting the original object, to avoid this, add <code>const</code>
modifier.</li>
<li>Higher efficiency without data copying.</li>
</ul>
<h2 id="multiple-return-values">Multiple Return Values</h2>
<ul>
<li>such as matrix addition function</li>
<li>A suggested prototype
<ul>
<li>To use references to avoid data copying</li>
<li>To use const parameters to avoid input data being modified</li>
<li>To use non-const reference parameters to receive the output</li>
</ul></li>
</ul>
<h2 id="inline-functions">Inline Functions</h2>
<ul>
<li><p>inline 只是对编译器的一种建议</p></li>
<li><p>内联后的代码大概如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">30</span>;</span><br><span class="line">    <span class="type">int</span> maxv =</span><br><span class="line">    &#123; <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> num2; &#125;</span><br><span class="line">    maxv =</span><br><span class="line">    &#123; <span class="keyword">if</span> (numn &gt; maxv)</span><br><span class="line">        <span class="keyword">return</span> numn;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> maxv; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="default-arguments">Default Arguments</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">norm</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> z = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// z is parameter, 0 is argument</span></span><br></pre></td></tr></table></figure>
<p>只能从尾部开始，只能定义一次，效果可以叠加</p>
<h2 id="function-overloading">Function Overloading</h2>
<p>返回值不参与比较，两个参数列表相同但返回值不同的函数被认为是同一个函数。</p>
<h2 id="function-templates">Function Templates</h2>
<p>编译器不会为模板函数生成机器指令，因为不知道具体的类型，只有模板实例化时才会生成机器指令。</p>
<p>函数模板实例化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T x, T y)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The input type is &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// instantiates explictly</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">double</span> <span class="built_in">sum</span>&lt;<span class="type">double</span>&gt;(<span class="type">double</span>, <span class="type">double</span>);</span><br><span class="line"><span class="keyword">template</span> <span class="type">char</span> sum&lt;&gt;(<span class="type">char</span>, <span class="type">char</span>);</span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="specialization">Specialization</h2>
<p>特化</p>
<p>如对于结构类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>直接执行会报错，需要针对此类型进行特例化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">Point <span class="built_in">sum</span>&lt;Point&gt;(Point pt1, Point pt2) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The input type is &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(pt1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    Point pt;</span><br><span class="line">    pt.x = pt1.x + pt2.x;</span><br><span class="line">    pt.y = pt1.y + pt2.y;</span><br><span class="line">    <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意此处必须加 <code>&lt;&gt;</code></p>
<h2 id="function-pointers">Function Pointers</h2>
<p>指向的是指令区的数据，指向指令的地址</p>
<p>有些时候需要用到代表某一类函数的函数指针，例如标准库容器的自定义操作</p>
<p>还有一种是把函数作为参数传入另一个函数作为<strong>回调函数</strong>，如
<code>qsort</code> 的调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">norm_l1</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">norm_l2</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span></span>;</span><br><span class="line"><span class="built_in">float</span> (*norm_ptr)(<span class="type">float</span> x, <span class="type">float</span> y);</span><br><span class="line">norm_ptr = norm_l1; <span class="comment">// pointing</span></span><br><span class="line">norm_ptr = &amp;norm_l2;</span><br><span class="line"><span class="type">float</span> len1 = <span class="built_in">norm_ptr</span>(<span class="number">-3.0f</span>, <span class="number">4.0f</span>); <span class="comment">// invoking</span></span><br><span class="line"><span class="type">float</span> len1 = (*norm_ptr)(<span class="number">-3.0f</span>, <span class="number">4.0f</span>);</span><br></pre></td></tr></table></figure>
<h2 id="function-references">Function References</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">norm_l1</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">norm_l2</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span></span>;</span><br><span class="line"><span class="built_in">float</span> (&amp;norm_ref)(<span class="type">float</span> x, <span class="type">float</span> y) = norm_l1;</span><br></pre></td></tr></table></figure>
<p>当然函数引用越少越好</p>
<h2 id="recursive-functions">Recursive Functions</h2>
<h1 id="chapter8-optimizations">Chapter8 Optimizations</h1>
<blockquote>
<p>第八章、Arm下的C++和C编程</p>
<p>1、平台不一样 2、如何让程序加速？ 本质就是三点：短，简单，高效；
主要包括以下几点：A、算法合适；B、代码简洁；C、内存优化；D、避免内存复制；E、循环里面不要使用printf、cout
F、可以使用查表法；G、SIMD,OPENMP自带的加速机制；
3、如何避免内存的复制？</p>
</blockquote>
<ol type="1">
<li>优化算法，从算法的时间复杂度、空间复杂度方面考虑优化算法。</li>
<li>现在的编译器非常强大，把代码写得简洁以便编译器可以优化。</li>
<li>考虑内存操作的影响。计算机的储存机制是分层的，最慢的、储存量最大的是磁盘，读取数据时会（计时用户只需要读取少量数据也会）一次性读取大量数据到内存，再一层层读到
cache 里面，所以读写数据时如果数据的地址是连续的就会很快。</li>
<li>避免拷贝大的对象。</li>
<li>尽可能不要再循环里面打印内容。</li>
<li>查表法。比如 sin()、cos()
这些计算很费时间，可以计算出其常用的值存到数组，可以大大提高效率。处理复杂操作可以考虑使用。</li>
</ol>
<h1 id="chapter9-basics-of-classes">Chapter9 Basics of Classes</h1>
<blockquote>
<p>第九章、类与对象</p>
<p>1、类：类成员变量以及类成员方法；
2、文件结构设计：头文件（.hpp），函数具体实现（.cpp），主函数实现（main.cpp）
3、构造函数以及析构函数 4、this 指针：指定当前的对象 5、const 成员与
static 成员</p>
</blockquote>
<p>操作结构时要非常小心数据取值和地址越界问题</p>
<h2 id="access-specifier">Access Specifier</h2>
<p>成员默认是 <code>private</code></p>
<h2 id="member-functions">Member Functions</h2>
<p>成员函数可以在类里也可以在类外。可以仅在类中放函数声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// member-function.cpp</span></span><br></pre></td></tr></table></figure>
<p>类中定义的函数默认是 <code>inline</code> 函数</p>
<p>建议：</p>
<ul>
<li>简单且适合内联的函数放在类内</li>
<li>操作复杂的函数建议放到类的外部</li>
</ul>
<h2 id="file-structure">File Structure</h2>
<p>将类的声明放到头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Chapter9/files</span></span><br></pre></td></tr></table></figure>
<h2 id="constructors">Constructors</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// constructor.cpp</span></span><br></pre></td></tr></table></figure>
<h2 id="destructors">Destructors</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// destructor.cpp</span></span><br></pre></td></tr></table></figure>
<ul>
<li>加波浪线 <code>~</code></li>
<li>不允许重载</li>
<li>无参数无返回值</li>
</ul>
<h2 id="textttthis-pointer"><span
class="math inline">\(\texttt{this}\)</span> pointer</h2>
<p>表示当前对象</p>
<blockquote>
<p>类似 Python 的 self</p>
</blockquote>
<h3 id="textttconst-and-textttstatic-members"><span
class="math inline">\(\texttt{const}\)</span> and <span
class="math inline">\(\texttt{static}\)</span> members</h3>
<ul>
<li><span class="math inline">\(\texttt{const}\)</span> variables</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * p_int;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * p_int;</span><br><span class="line"><span class="comment">// 相同，指针指向的内容不能通过指针修改</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p_int;</span><br><span class="line"><span class="comment">// 指针一定指向某个不可修改的地址</span></span><br></pre></td></tr></table></figure>
<ul>
<li><span class="math inline">\(\texttt{static}\)</span> members</li>
</ul>
<h1 id="chapter10-advances-in-classes">Chapter10 Advances in
Classes</h1>
<blockquote>
<p>第十章、运算符重载</p>
<p>1、运算符重载的主要目的是简化程序
2、友元函数：函数的朋友，可以不受限类的约束，因为它不是类的成员；
3、类型转换：在运算符重载的过程中，通常会遇到各种类型的转换，注意最好使用显式转换，不建议使用隐式转换。
4、自增与自减运算符的重载： 可以让代码更加地简洁；</p>
</blockquote>
<h2 id="textttfriend-functions"><span
class="math inline">\(\texttt{friend}\)</span> functions</h2>
<ul>
<li>在类中声明</li>
<li>有权限访问类的所有成员</li>
<li><strong>不是</strong>类的成员，所以在类外定义的时候不加
<code>classname::</code></li>
<li><strong>可以用来重定义输入输出操作，类似 Java 中的
<code>toString</code></strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp time.hpp</span></span><br></pre></td></tr></table></figure>
<h2 id="user-defined-type-conversion">User-defined Type Conversion</h2>
<p>一行定义并初始化会调用构造函数，而先定义不初始化后面再赋值会调用赋值运算符</p>
<h2 id="increment-and-decrement-operators">Increment and Decrement
Operators</h2>
<figure>
<img src="Images/operators-can-be-overloaded.png"
alt="operators-can-be-overloaded" />
<figcaption aria-hidden="true">operators-can-be-overloaded</figcaption>
</figure>
<h1 id="chapter11-dynamic-memory-management-in-classes">Chapter11
Dynamic Memory Management in Classes</h1>
<blockquote>
<p>第十一章、类的动态内存操作 1、默认构造函数： 2、动态内存的例子；
3、内存泄漏的解法； 4、软拷贝 5、智能指针可以自动释放内存；
（只管申请，不管释放：本质就是模板类，在析构函数中根据引用次数减少到指定值时（比如到0时）就会自动删除delete[]从而释放内存。）</p>
</blockquote>
<h2 id="default-operations">Default Operations</h2>
<ul>
<li>默认构造函数</li>
<li>隐式定义的析构函数</li>
<li>默认拷贝构造函数</li>
<li>默认拷贝赋值运算符</li>
</ul>
<h2 id="an-example-with-dynamic-memory">An Example with Dynamic
Memory</h2>
<h2 id="hard-copy">Hard Copy</h2>
<ul>
<li>自定义拷贝构造函数</li>
<li>自定义拷贝运算符重载使指针指向自己申请的内存。</li>
</ul>
<h2 id="soft-copy">Soft Copy</h2>
<blockquote>
<p>Hard copy 的时间和空间代价较高</p>
</blockquote>
<ul>
<li>浅拷贝，使用引用计数。</li>
</ul>
<h2 id="smart-pointers">Smart Pointers</h2>
<ul>
<li><span class="math inline">\(\texttt{std::shared\_ptr}\)</span></li>
</ul>
<p>​ 允许多个对象同时指向一块内存，当没有指针指向这块内存时会被销毁</p>
<ul>
<li><span class="math inline">\(\texttt{std::unique\_ptr}\)</span></li>
</ul>
<p>​ 不允许和别人分享</p>
<h1 id="chapter12-class-inheritance">Chapter12 Class Inheritance</h1>
<blockquote>
<p>第十二章、改善你的源代码
1、一些建议：A、使用size_t代替int;B、矩阵拷贝不适用双层循环，使用内存可能更好；C、使用一维数组，而不是使用二维数组。D、不要使用太多的循环结构；E、多对输入参数进行检查，这样可以避免更多的bug.F、将代码写得更加具有可移植性，这样可以方便拓展；G、文件命名规则；H、代码优化无止境。
2、头文件里面应用了单例模式； 3、代码最好要做到高内聚低耦合。
4、派生类：子类继承父类的所有特性，先执行父类的构造函数，析构函数则是相反。
5、访问权限的控制：private,public,protected具有不同的访问权限与范围。
6、虚函数：虚函数就是在父类中进行申明，在子类中进行实现与重写。这样可以实现多态，延迟定义：
在C#中，虚函数是一种很好的抽象，著名的抽象工厂，抽象方法以及抽象类也是类似于这种思想实现的。
虚函数的本质就是动态绑定，非虚函数就是静态绑定。
7、析构函数一定是虚函数。 8、静态与动态的内存申请：
9、opencv中的实例；</p>
</blockquote>
<h2 id="suggestions-to-project3-2021">Suggestions to Project3 2021</h2>
<ul>
<li>用 <span class="math inline">\(\texttt{size\_t}\)</span>
表达行数和列数</li>
<li>用 <span class="math inline">\(\texttt{memcpy}\)</span>
完成矩阵的拷贝</li>
<li>数据检查是减少程序调试时间最重要的一点</li>
<li><strong>做Project一定要作为一种艺术</strong></li>
</ul>
<h2 id="reference-implementation">Reference Implementation</h2>
<ul>
<li>第二次申请失败的可能性较高：多次申请内存可能导致泄露</li>
<li>不能第二次申请失败就直接返回，需要把第一次申请的内存释放掉</li>
<li>申请矩阵和矩阵加法分开实现，在加法函数内部调用申请函数，分工明确</li>
<li>用 bool 表示成功与否，相加的结果放在参数中返回</li>
<li>在写代码时多写 debug
信息，产品交付时要少，否则容易被攻击者猜测实现方案</li>
<li>不要依赖编译器的优化，自己能做就尽量做掉</li>
</ul>
<h2 id="derived-classes">Derived Classes</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> c) : <span class="built_in">Base</span>(c<span class="number">-2</span>, c<span class="number">-1</span>), <span class="built_in">c</span>(c) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>Constructors
<ul>
<li>先执行父类的构造函数</li>
</ul></li>
<li>Destructors
<ul>
<li>先执行子类的析构函数</li>
</ul></li>
</ul>
<p>对基类数据的保护程度：public &lt; protected &lt; private</p>
<ol type="1">
<li>基类中的私有数据：三种方式都不能访问。</li>
<li>基类中的 protected 数据：以 public、protected
方式继承，该数据在子类还是 protected 的；以private
方式继承，该数据在子类中是不可直接访问的（可以通过父类间接访问）。</li>
<li>基类中的 public 数据：以 public 方式继承，该数据在子类是 public
的，以 protected 方式继承，该数据在子类中是 protected 的，以 private
方式继承，该数据在子类中是不可直接访问的。</li>
</ol>
<h2 id="virtual-functions">Virtual Functions</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// virtual.cpp</span></span><br></pre></td></tr></table></figure>
<p>虚函数用于多态</p>
<p>其区别在于绑定</p>
<ul>
<li>静态绑定：编译器在编译期确定调用哪个函数</li>
<li>动态绑定：在运行时根据传入参数的类型确定执行的函数。</li>
</ul>
<p>动态绑定原理：一旦定义了虚函数，类的成员变量会多出一个指向自身函数表的指针，这个成员变量是类的第一个成员变量。执行时查虚函数表确定实际执行的函数。</p>
<p>析构函数一定是虚函数，否则调用析构函数时只会调用父类的析构函数。</p>
<h2 id="inheritance-and-dynamic-memory-allocation">Inheritance and
Dynamic Memory Allocation</h2>
<p>如果基类使用了动态内存分配，并且重写了拷贝构造函数和赋值运算符</p>
<ul>
<li>子类不使用动态内存分配，无需特殊操作</li>
<li>子类使用动态内存分配，需要重写拷贝构造函数和赋值运算符</li>
</ul>
<h1 id="chapter13-class-templates-and-std-library">Chapter13 Class
Templates and std Library</h1>
<blockquote>
<p>第十三章、类模板和标准库
1、类模板是最近C++标准推出的功能，主要也就是泛型在类上面的实现。
2、可以更加灵活地调用类，泛型（模板）的出现主要就是延迟创建，让使用变得更加方便；</p>
<p>3、模板还可以相互继承； 4、C++中有很多的标准类模板；</p>
</blockquote>
<h2 id="review-function-templates">Review: Function Templates</h2>
<p>是一个空壳子，编译器对空壳子不做任何事情。只有在实例化以后才会做事</p>
<p>Function Templates：空壳子</p>
<p>Template Functions：函数模板初始化后的具体函数</p>
<p><code>= delete</code> 表示不调用默认生成的函数</p>
<h2 id="template-non-type-parameters">Template non-type Parameters</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> rows, <span class="type">size_t</span> cols&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mat</span> &#123;</span><br><span class="line">    T data[rows][cols];</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mat</span>()&#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">getElement</span><span class="params">(<span class="type">size_t</span> r, <span class="type">size_t</span> c)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setElement</span><span class="params">(<span class="type">size_t</span> r, <span class="type">size_t</span> c, T value)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>rows</code>、<code>cols</code> 在编译的时候就确定了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat&lt;<span class="type">int</span>, <span class="number">3</span>, <span class="number">3</span>&gt; vec;</span><br></pre></td></tr></table></figure>
<h2 id="class-template-specialization">Class Template
Specialization</h2>
<p>我非要用 <code>bool</code> 类型实例化对操作内容为完整字节的模板类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// specialization.cpp</span></span><br></pre></td></tr></table></figure>
<h2 id="textttstd-classes"><span
class="math inline">\(\texttt{std}\)</span> classes</h2>
<ul>
<li><span class="math inline">\(\texttt{std::string}\)</span></li>
<li><span class="math inline">\(\texttt{std::array}\)</span></li>
<li><span class="math inline">\(\texttt{vector}\)</span></li>
<li><span class="math inline">\(\texttt{list}\)</span></li>
<li><span class="math inline">\(\texttt{set}\)</span></li>
<li><span class="math inline">\(\texttt{map}\)</span></li>
<li><span class="math inline">\(\texttt{stack}\)</span></li>
</ul>
<h1 id="chapter14-error-handling">Chapter14 Error Handling</h1>
<blockquote>
<p>第十四章、错误处理机制 1、cin ,cout,cerr等不同的信息输出到多管道中；
2、assert 是一个宏，不是一个标准；
3、exception异常，通常使用try……catch对不同的异常进行捕获。
4、还有更多的异常捕获机制，就是对应于不同的异常进行捕获，然后进行相应的处理。</p>
</blockquote>
<h2 id="standard-output-stream-and-standard-error-stream">Standard
Output Stream and Standard Error Stream</h2>
<p>在输出很多的时候可以通过管道重定向到文件，不重定向都会输出到控制台</p>
<p>一些操作：</p>
<h2 id="assert">assert</h2>
<p><span class="math inline">\(\texttt{assert}\)</span>
是一个像函数的宏定义，定义在 <span
class="math inline">\(\texttt{&lt;assert.h&gt;}\)</span> 和 <span
class="math inline">\(\texttt{&lt;cassert&gt;}\)</span> 头文件中</p>
<p>条件不满足会做相应的处理，并调用 <span
class="math inline">\(\texttt{abort()}\)</span> 函数终止程序</p>
<p>如果在产品发布时想去掉 assert 信息，可以在文件中定义
<code>NDEBUG</code> 或者在编译时定义一个宏</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ assert.cpp -DNDEBUG</span><br></pre></td></tr></table></figure>
<h2 id="exceptions">Exceptions</h2>
<p>几种可能的处理方式：</p>
<ul>
<li>直接 kill 程序</li>
<li>用返回值表示成功与否，缺点是需要引入额外的参数</li>
<li>抛出异常</li>
</ul>
<p><span class="math inline">\(\texttt{throw}\)</span>
应该会跳过后续的执行语句</p>
<p>函数层层调用，最内层的函数抛出异常，如果外层的函数不捕获异常，那么异常会层层往外扔直到主函数，如果到最后异常没有被捕获那么程序会被kill。</p>
<h2 id="catch-all-handler">Catch-all Handler</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">catch</span>(...) <span class="comment">// 这里就是...</span></span><br></pre></td></tr></table></figure>
<p>三个点表示匹配任何异常，即任何扔到主函数的异常都被捕获，可防止程序被kill。</p>
<h2 id="exceptions-and-inheritance">Exceptions and Inheritance</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// derived.cpp</span></span><br></pre></td></tr></table></figure>
<h2 id="textttstdexception"><span
class="math inline">\(\texttt{std::exception}\)</span></h2>
<p>是标准库定义的标准异常类，可以重写 <span
class="math inline">\(\texttt{std::exception::what()}\)</span>
方法返回一个字符串</p>
<p>当new申请内存失败时，默认会抛出异常。</p>
<h2 id="exception-specifications-and-textttnoexcept">Exception
Specifications and <span
class="math inline">\(\texttt{noexcept}\)</span></h2>
<p>如果抛出异常编译期就会出错</p>
<h2 id="textttnothrow-new"><span class="math inline">\(\texttt{nothrow
new}\)</span></h2>
<p><span class="math inline">\(\texttt{std::nothrow}\)</span></p>
<h1 id="chapter15-nested-classes-and-rtti">Chapter15 Nested Classes and
RTTI</h1>
<blockquote>
<p>第十五章、拓展的C++知识
1、友元类：友元函数不是成员函数。友元类可以调用基类的私有成员；
2、Nested types嵌套：
3、RTTI和不同的数据类型转换：（记住一点那就是最好使用显式转换，不然出现信息都是都是容易造成bug的问题的出现。）
4、</p>
</blockquote>
<h2 id="textttfriend-classes"><span
class="math inline">\(\texttt{friend}\)</span> Classes</h2>
<p>友元类可以访问类的私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// friend.cpp</span></span><br></pre></td></tr></table></figure>
<h2 id="textttfriend-member-functions"><span
class="math inline">\(\texttt{friend}\)</span> Member Functions</h2>
<p>限制友元类只有一部分函数可以访问类的私有成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译时如果遇到“死锁”，考虑将类的声明和类的成员函数声明先写出，后续补充其定义。</p>
<h2 id="nested-types">Nested Types</h2>
<h2 id="rtti-and-type-cast-operators">RTTI and Type Cast Operators</h2>
<p>RTTI: Runtime Type Identification</p>
<ul>
<li><span
class="math inline">\(\texttt{dynamic\_cast}\)</span>：将<strong>多态类型</strong>进行转换</li>
<li><span class="math inline">\(\texttt{typeid}\)</span>：返回类型
id</li>
<li><span
class="math inline">\(\texttt{type\_info}\)</span>：返回的对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typeid.cpp</span></span><br></pre></td></tr></table></figure>
<h2 id="more-type-cast-operators">More Type Cast Operators</h2>
<ul>
<li><span class="math inline">\(\texttt{const\_cast}\)</span></li>
<li><span class="math inline">\(\texttt{static\_cast}\)</span></li>
<li><span class="math inline">\(\texttt{reinterpret\_cast}\)</span></li>
</ul>
<h1 id="appendix">Appendix</h1>
<blockquote>
<p>附录 1、OPENBLAS项目创始人介绍如何进行代码优化：1、局部性原理2、GEMM
2、OPENCV中国区域负责人：Vadim Pisarevsky与于教授的对答环节：</p>
</blockquote>
<h2
id="interview-with-vadim-pisarevsky-on-class-textttcvmat-in-opencv">Interview
with Vadim Pisarevsky on class <span
class="math inline">\(\texttt{cv::Mat}\)</span> in OpenCV</h2>
<ol type="1">
<li>（长久来看）建议关注算法、概念、技术，而不是特定的特性或者编程语言本身。</li>
<li>不要尝试把你学到的花哨功能全部用到开发上，因为过一段时间你可以就都不懂你的代码了。</li>
<li>“当程序员避免使用原始指针而使用智能指针等封装好的结构，内存泄漏的问题就降到几乎为零”</li>
<li>c++语言变得越来越复杂，但应该形成自己的提高程序稳定性的方法论，比如：</li>
</ol>
<ul>
<li>尽量不要手动管理内存，使用已有的容器。</li>
<li>在重构和优化之前要进行回归测试。</li>
<li>写代码时应注意让程序更容易调试，不要用复杂的语言结构（代码应该越简单越好）。</li>
</ul>
]]></content>
      <categories>
        <category>S5</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
