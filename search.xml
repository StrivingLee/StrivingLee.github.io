<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《C陷阱与缺陷》读书笔记</title>
    <url>/c-traps-pitfalls-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="总述">总述</h2>
<blockquote>
<p>C 陷阱与缺陷读书笔记，批判阅读</p>
</blockquote>
<span id="more"></span>
<h1 id="c-陷阱与缺陷">C 陷阱与缺陷</h1>
<h2 id="第1章-词法陷阱">第1章 词法陷阱</h2>
<h3 id="不同于">1.1 =不同于==</h3>
<p>不应该关闭警告选项，而应进行显式比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// improper</span></span><br><span class="line"><span class="keyword">if</span> (x = y)</span><br><span class="line">    foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// proper</span></span><br><span class="line"><span class="keyword">if</span> ((x = y) != <span class="number">0</span>)</span><br><span class="line">    foo();</span><br></pre></td></tr></table></figure>
<p>赋值误写为比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((filedsc == open(argv[i], <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    error();</span><br><span class="line"><span class="comment">// 完全没有调用error的机会</span></span><br></pre></td></tr></table></figure>
<h3 id="和不同于和">1.2 &amp;和|不同于&amp;&amp;和||</h3>
<p>见后</p>
<h3 id="词法分析中的贪心法">1.3 词法分析中的“贪心法”</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a---b;</span><br><span class="line"><span class="comment">/* is same as</span></span><br><span class="line"><span class="comment"> * a -- -b</span></span><br><span class="line"><span class="comment"> * is different from</span></span><br><span class="line"><span class="comment"> * a - --b</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">y = x<span class="comment">/*p; // is regarded as MULTI</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">y = x / *p; <span class="comment">// x point to p</span></span><br><span class="line">y = x/(*p);</span><br></pre></td></tr></table></figure>
<h3 id="整型常量">1.4 整型常量</h3>
<p>1-4.c</p>
<p>不允许出现9</p>
<h3 id="字符和字符串">1.5 字符和字符串</h3>
<p>双引号引起的字符串代表指向无名数组起始字符的指针，无名数组用引号之间的字符以及二进制为0的字符
<code>\0</code> 初始化</p>
<h3 id="练习题">练习题</h3>
<h2 id="第2章-语法陷阱">第2章 语法陷阱</h2>
<h3 id="理解函数声明">2.1 理解函数声明</h3>
<p>C
变量的声明由两部分构成：类型以及一组类似表达式的声明符(declarator)</p>
<p>声明符与表达式类似，对它求值返回一个声明中给定类型的结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> ((f));</span><br></pre></td></tr></table></figure>
<p>这个声明的含义是，当对其求值时，<code>((f))</code>
的类型为浮点类型，由此推知 <code>f</code> 的类型也是浮点类型</p>
<p>且 <code>()</code> 结合优先级高于 <code>*</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> *<span class="title function_">g</span><span class="params">()</span>, <span class="params">(*h)</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// is same as the following statement</span></span><br><span class="line"><span class="type">float</span> *(g()), (*h)();</span><br></pre></td></tr></table></figure>
<p>知道如何声明一个类型的变量后就很容易得到该类型的类型转换符了：去掉声明中的变量名和末尾分号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="type">float</span> (*)())</span><br></pre></td></tr></table></figure>
<p>调用函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*fp)();</span><br><span class="line"><span class="comment">// abbr</span></span><br><span class="line">fp();</span><br></pre></td></tr></table></figure>
<p>todo</p>
<h2 id="第3章-语义陷阱">第3章 语义陷阱</h2>
<h3 id="指针与数组">3.1 指针与数组</h3>
<p>二维数组事实上是一个指向一维数组的指针数组</p>
<p>所以取行就只需取一个下标</p>
<h3 id="非数组的指针">3.2 非数组的指针</h3>
<p><code>malloc()</code> 可能会返回 <code>NULL</code>
作为内存分配失败的标志（不过一般来说也许不用？）</p>
<h3 id="作为参数的数组声明">3.3 作为参数的数组声明</h3>
<p>用数组作为函数参数没什么意义，和传入首地址是等效的</p>
<p>他卖了个关子 todo</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *hello;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> hello[];</span><br></pre></td></tr></table></figure>
<h3 id="避免举隅法">3.4 避免“举隅法”</h3>
<p>玄之又玄，大概就是表达复制指针并不复制原始内容，即shallow
copy，当然，修改字符串常量的行为貌似是UB，与编译器实现有关</p>
<h3 id="空指针并非空字符串">3.5 空指针并非空字符串</h3>
<p>编译器保证由0转换而来的指针不等于任何有效的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br></pre></td></tr></table></figure>
<p>不能访问空指针指向的内容</p>
<h3 id="边界计算与不对称边界">3.6 边界计算与不对称边界</h3>
<p>不对称边界：左闭右开，在数学上的不对称的丑陋带来了编程时出奇的方便</p>
<p>另一种看待不对称问题的方式：把上界视作某序列中第一个被占用的元素，把下界视作序列中第一个被释放的元素</p>
<p>来看一段例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1024</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[N];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *bufptr;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bufwrite</span><span class="params">(<span class="type">char</span> *p, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bufptr == &amp;buffer[N])</span><br><span class="line">            flushbuffer();</span><br><span class="line">        -bufptr++ = *p++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ANSI C 标准中允许与“溢界”的元素地址相比较，但是对其引用是非法的</p>
<p><code>memcpy()</code>
提供了一次复制多个字符的方法，并且通常借助汇编语言的实现提高速度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bufwrite</span><span class="params">(<span class="type">char</span> *p, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> k, rem;</span><br><span class="line">        <span class="keyword">if</span> (bufptr == &amp;buffer[N])</span><br><span class="line">            flushbuffer();</span><br><span class="line">        rem = N - (bufptr - buffer);</span><br><span class="line">        k = n &gt; rem ? rem : n;</span><br><span class="line">        <span class="built_in">memcpy</span>(bufptr, p, k);</span><br><span class="line">        bufptr += k;</span><br><span class="line">        p += k;</span><br><span class="line">        n -= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在“师出有名”的情况下，我们应该有信心写对这些技巧性很强的代码</p>
<p>另一个打印给定行号or列号字符的函数</p>
<h3 id="求值顺序">3.7 求值顺序</h3>
<p>主要说了短路求值</p>
<h3 id="运算符和">3.8 运算符&amp;&amp;、||和!</h3>
<p>逻辑运算符只会返回0或1</p>
<p>&amp;和|两侧的值都会算出，而不会短路求值</p>
<h3 id="溢出">3.9 溢出</h3>
<h3 id="为函数-main-提供返回值">3.10 为函数 main 提供返回值</h3>
<p>忘记显示声明 main 返回值为 int，而又在前面定义了其他 struct</p>
<h2 id="第4章-连接">第4章 连接</h2>
<h3 id="什么是连接器">4.1 什么是连接器</h3>
<h3 id="声明与定义">4.2 声明与定义</h3>
<p>外部变量尽量不要重复定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file1.c</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.c</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>
<h3 id="命名冲突与static修饰符">4.3 命名冲突与static修饰符</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure>
<p>将 a 的作用域限制在一个源文件内</p>
<p>因此，如果若干个函数需要共享一组外部对象，可以将这些函数放到一个源文件中，把他们需要用到的对象在同一个源文件中用
static
声明，如果一个函数仅仅被同一个源文件中的其他函数调用，我们就应该声明该函数为
static</p>
<h3 id="形参实参与返回值">4.4 形参、实参与返回值</h3>
<p>如果一个函数在被定义或声明之前被调用，它的返回类型默认为 int</p>
<p>C 中形参和实参匹配的规则略为复杂，ANSI C
允许程序员在声明时指定函数的参数类型，如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">square</span><span class="params">(<span class="type">double</span>)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">square(<span class="number">2</span>); <span class="comment">// legal, is same as square((double)2)</span></span><br></pre></td></tr></table></figure>
<p>如果一个函数没有 float、short 或者 char
类型的参数，在函数声明中可以省略参数类型的说明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isvowel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isvowel</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scanf 和 printf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// expected: 0 1 2 3 4</span></span><br><span class="line"><span class="comment">// actual:   0 0 0 0 0</span></span><br></pre></td></tr></table></figure>
<p>字符 c 附近的内存因为整型所占存储空间大于字符型而被覆盖</p>
<h3 id="检查外部类型">4.5 检查外部类型</h3>
<p>保证 extern 变量与其声明一致</p>
<h3 id="头文件">4.6 头文件</h3>
<h2 id="第5章-库函数">第5章 库函数</h2>
<p><strong>尽可能</strong>使用库函数</p>
<h3 id="返回整数的getchar函数">5.1 返回整数的getchar函数</h3>
<p>不知所云，不管了</p>
<h3 id="更新顺序文件">5.2 更新顺序文件</h3>
<p>fread 操作，用到时候再细究</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (fread( (<span class="type">char</span> *)&amp;rec, <span class="keyword">sizeof</span>(rec), <span class="number">1</span>, fp) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// do something on rec</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*rec needs to be update*/</span>) &#123;</span><br><span class="line">        fseek(fp, -(<span class="type">long</span>)<span class="keyword">sizeof</span>(rec), <span class="number">1</span>);</span><br><span class="line">        fwrite( (<span class="type">char</span> *)&amp;rec, <span class="keyword">sizeof</span>(rec))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缓存输出与内存分配">5.3 缓存输出与内存分配</h3>
<p>程序输出的两种方式：</p>
<ul>
<li>即时处理（系统负担较大）</li>
<li>先暂存再大块写入</li>
</ul>
<p>因此 C
语言实现通常都允许程序员进行实际的写操作之前控制产生的输出数据量，一般通过库函数
<code>setbuf(stdout, buf)</code> 实现</p>
<p>这个语句通知输入/输出库，所有写入到 stdout 的输出都应该使用 buf
作为缓冲区，直到 buf 被填满或者程序员直接调用
fflush（对于写操作打开的文件，fflush
会直接导致输出缓冲区的内容被实际写入该文件）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> BUF[BUFSIZ];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    </span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != EOF)</span><br><span class="line">        <span class="built_in">putchar</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用errno检测错误">5.4 使用errno检测错误</h3>
<p>先检测作为错误指示的返回值，确定已经执行失败，再检查 errno
确定出错原因</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="comment">/*wrong return value*/</span>) &#123;</span><br><span class="line">    <span class="comment">// check errno</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="库函数signal">5.5 库函数signal</h3>
<p>signal 是一种捕获异步事件的方式</p>
<p>信号是真正的“异步”，可能在 C
语言执行期间的任何时刻发生，甚至可能出现在 malloc
等复杂函数的执行过程中。因此从安全角度考虑，信号处理函数不应该调用上述类型的库函数</p>
<p>唯一绝对安全可移植的操作：print 错误语句，exit 退出</p>
<h2 id="第6章-预处理器">第6章 预处理器</h2>
<blockquote>
<p>主要讲的宏的事情</p>
</blockquote>
<h3 id="不能忽视宏定义中的空格">6.1 不能忽视宏定义中的空格</h3>
<h3 id="宏并不是函数">6.2 宏并不是函数</h3>
<p>主要是括号的问题</p>
<p>但是比如下面这段就会出现重复计算的bug</p>
<p>经典的把 <code>toupper</code> 定义成宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">toupper</span>(*p++);</span><br></pre></td></tr></table></figure>
<p>嵌套宏也可能导致代码过长，比如四层嵌套的 <code>max</code> 语句</p>
<p>其实写成四行 if-else 更好</p>
<h3 id="宏并不是语句">6.3 宏并不是语句</h3>
<h3 id="宏并不是类型定义">6.4 宏并不是类型定义</h3>
<blockquote>
<p>省流：用 typedef</p>
</blockquote>
<h2 id="第7章-可移植性缺陷">第7章 可移植性缺陷</h2>
<p>就感觉...没太大必要</p>
<p>就摸了（不是）</p>
]]></content>
      <categories>
        <category>C&amp;C++</category>
        <category>Notes</category>
        <category>S4 Summer</category>
      </categories>
      <tags>
        <tag>C&amp;C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>OO Pre Review</title>
    <url>/OO-Pre-Review/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="写在前面">写在前面</h2>
<blockquote>
<p>OO Pre 的学期总结，痛并快乐着</p>
</blockquote>
<span id="more"></span>
<p>[TOC]</p>
<p>也记得找jsgg debug的时候，他说：你push到仓库里，我明天帮你看看</p>
<p>可惜我当时甚至还没学会用idea进行版本管理</p>
<h2 id="pre0_task1">Pre0_task1</h2>
<blockquote>
<p>本次目标：完成git和idea的安装，学习其基本用法</p>
</blockquote>
<p>题外话，Git 这东西真的魔力很大，但是确实也有点难学</p>
<p>课程组推荐给大家的我也推荐给大家（</p>
<h3 id="git-相关">Git 相关：</h3>
<ol type="1">
<li><p><a href="https://juejin.cn/post/6844904191203213326">Git 使用心得
&amp; 常见问题整理</a></p></li>
<li><p><a
href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰老师的 Git
教程</a></p></li>
<li><p><a href="https://learngitbranching.js.org/">Git
基础可视化教程</a> 与 <a
href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1">Git
进阶可视化教程</a></p></li>
<li><p><a href="https://www.progit.cn/">Git Pro</a></p></li>
</ol>
<h3 id="java相关">Java相关：</h3>
<p><a href="https://docs.oracle.com/en/java/javase/18/docs/api/">JDK
Document</a></p>
<h3 id="commit-message">Commit message</h3>
<p>可以采用插件规范自己的 <code>commit message</code>
，摘录一些如下：（来源于<a
href="https://blog.csdn.net/m0_46636892/article/details/122093889">陈大大的期待的CSDN博客</a>）</p>
<p>Git Commit Template插件在使用时选择的git提交类型解释：</p>
<blockquote>
<p>feat
功能feature的意思，也是最常用的。当你的功能有变更的时候，都可以采用这种类型的type</p>
<p>fix 当然指的是bug修复</p>
<p>docs 更新了文档，或者更新了注释</p>
<p>style 代码格式调整，比如执行了format、更改了tab显示等</p>
<p>refactor
重构代码。指的是代码结构的调整，比如使用了一些设计模式重新组织了代码</p>
<p>perf
对项目或者模块进行了性能优化。比如一些jvm的参数改动，把stringbuffer改为stringbuilder等</p>
<p>test 这个简单，就是增加了单元测试和自动化相关的代码</p>
<p>build 影响编译的一些更改，比如更改了maven插件、增加了npm的过程等</p>
<p>ci
持续集成方面的更改。现在有些build系统喜欢把ci功能使用yml描述。如有这种更改，建议使用ci</p>
<p>chore
其他改动。比如一些注释修改或者文件清理。不影响src和test代码文件的，都可以放在这里</p>
<p>revert 回滚了一些前面的代码</p>
</blockquote>
<h2 id="pre1_task1">Pre1_task1</h2>
<blockquote>
<p>本次目标：初识Java，实现一系列基础的类，并且熟悉类、属性和方法的使用</p>
</blockquote>
<p>本次作业只需要使用Java基础语法、容器和简单的getter、setter，以及对大数类
<code>BigInteger</code> 用法有基本了解即可完成</p>
<h3 id="关于容器">关于容器：</h3>
<p>容器是好用的，容器是需要学习的</p>
<p><strong>容器是现代程序设计非常基础而重要的手段</strong></p>
<p>如果采用类似C语言结构体数组的写法，通过遍历数组查找所需要的信息，就不太符合Java的感觉，更好的做法是采用HashMap。概括起来就是下面这句话：</p>
<blockquote>
<p>不要重复造轮子！不要重复造轮子！不要重复造轮子！</p>
</blockquote>
<h3 id="关于面向对象">关于面向对象：</h3>
<blockquote>
<p>面向对象是一种主流的软件开发方法，也是一种思维方式，其核心是识别类，并在类之间建立层次式的协作关系。</p>
</blockquote>
<p>有兴趣的同学也可以看这篇读书笔记——《面向对象是如何工作的（第2版）》读书笔记</p>
<p><del>啊当然也是还在紧锣密鼓地筹备当中辣</del></p>
<h3 id="关于构造函数constructor">关于构造函数Constructor</h3>
<p>一个压行的方法是将参数传入constuctor，省去了多次调用set方法</p>
<blockquote>
<p>关于构造函数的理解：</p>
<p>构造函数的用途是在你需要创建一个对象的时候完成一些初始化工作，并给对象的所有属性赋予初始值。</p>
<p>也就是这两步：①创建这个对象 ②给这个对象部分初始化</p>
</blockquote>
<p>一个愚蠢的压行方法：不用中间变量存储读入，直接将读入传入</p>
<p>详细说明如下<del>，但是貌似不符合软工要求</del></p>
<p>有条理的写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line">    </span><br><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> in.next();</span><br><span class="line"><span class="type">String</span> <span class="variable">bottleId</span> <span class="operator">=</span> in.next();</span><br><span class="line">function(userId, bottleId);</span><br></pre></td></tr></table></figure>
<p>不太好的压行写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line">    </span><br><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">function(in.next(), in.next());</span><br></pre></td></tr></table></figure>
<h3 id="多说一嘴">多说一嘴</h3>
<p>为什么 ArrayList
可以存不同的对象呢？（这会在本单元第2、3次作业中有所体现），记住Java中一句非常重要的话：<code>Everything is reference</code>
，这会帮助你理解很多问题</p>
<p>什么、不太明白，请耐心看下去哦~</p>
<p>toString() 方法</p>
<p>操作10要求输出特定的<code>Bottle</code>类型实例的属性，建议在
<code>Bottle</code> 类中重写<code>toString</code> 方法，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bottle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The bottle&#x27;s id is &quot;</span> + id + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">        <span class="type">Bottle</span> <span class="variable">bottle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bottle</span>();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(bottle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 : The bottle&#x27;s id is 1.</span></span><br></pre></td></tr></table></figure>
<p><code>java.io.PrintStream.println(Object x)</code>函数将调用<code>String.valueOf(x)</code>以获得实例<code>x</code>的字符串描述，而<code>java.lang.String.valueOf(Object x)</code>函数将在<code>x</code>不为<code>null</code>时返回<code>x.toString()</code>，因此我们可以通过重写<code>toString</code>方法使<code>println</code>函数输出自定义格式的“实例属性”。详见
<a
href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/PrintStream.html#println()">println()
- JDK Documentation</a> 和 <a
href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/String.html#valueOf(java.lang.Object)">valueOf()
- JDK Documentation</a> 。</p>
<blockquote>
<p>简而言之这个 toString() 就是对象的字符串描述，println() 会打印它</p>
</blockquote>
<h2 id="pre1_task2">Pre1_task2</h2>
<blockquote>
<p>本次目标：多态和继承的练习，以及了解工厂模式</p>
</blockquote>
<p><del>虽然我没写出来工厂模式，但是我觉得这很漂亮，很符合我对设计模式的想象</del></p>
<p><del>工厂模式可以看我的另一篇博客（啊写好了会post上来的，问就是还在紧锣密鼓地筹备当中）</del></p>
<h3 id="一继承">一、继承</h3>
<blockquote>
<p>继承就是定义子类继承父类的特征和行为，使得子类可以拥有父类的属性和方法，从而起到代码复用的目的。</p>
<p><strong>从语义上来说，在 <code>A</code> 和 <code>B</code> 类型满足
<em>is-a</em> 关系（A is a B），即<code>A</code> 类型是 <code>B</code>
类型的一种时，可以使用继承来在程序表述。</strong></p>
</blockquote>
<h3 id="二向上转型upcasting">二、向上转型（Upcasting）</h3>
<blockquote>
<p>在建立了继承关系之后，可以使用<strong>父类型</strong>去引用通过<strong>子类型</strong>创建的对象。</p>
</blockquote>
<p>在调用构造函数的时候会涉及先后问题，这里要注意，是先调用父类的构造函数，再调用子类的构造函数，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Equipment</span><span class="params">(<span class="type">int</span> tmpId, String tmpName, <span class="type">long</span> tmpPrice)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = tmpId;</span><br><span class="line">    <span class="built_in">this</span>.name = tmpName;</span><br><span class="line">    <span class="built_in">this</span>.price = tmpPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类构造函数</span></span><br><span class="line"><span class="comment">// public class Bottle extends Equipment</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Bottle</span><span class="params">(<span class="type">int</span> tmpId, String tmpName, <span class="type">long</span> tmpPrice,</span></span><br><span class="line"><span class="params">                  <span class="type">double</span> tmpCapacity, <span class="type">boolean</span> tmpFilled)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(tmpId, tmpName, tmpPrice);</span><br><span class="line">    <span class="built_in">this</span>.capacity = tmpCapacity;</span><br><span class="line">    <span class="built_in">this</span>.filled = tmpFilled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public class HealingPotion extends Bottle</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HealingPotion</span><span class="params">(<span class="type">int</span> tmpId, String tmpName, <span class="type">long</span> tmpPrice,</span></span><br><span class="line"><span class="params">                         <span class="type">double</span> tmpCap, <span class="type">boolean</span> tmpFilled, <span class="type">double</span> tmpEff)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(tmpId, tmpName, tmpPrice, tmpCap, tmpFilled);</span><br><span class="line">    <span class="built_in">this</span>.efficiency = tmpEff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三向下转型downcasting">三、向下转型（Downcasting）</h3>
<blockquote>
<p>一种比较危险的行为，需要搭配 instanceof 来使用</p>
</blockquote>
<p>Java 语言提供了一个特殊的关键词 <code>instanceof</code>
用来判断一个对象引用所指向的对象的创建类型是否为特定的某个类，一般写为
<code>obj instanceof A</code>，其中 obj 为一个对象引用，A
为一个类型（类或接口），这个表达式的取值结果为布尔型，如果 obj
的创建类型为 A，则结果为 true，否则为 false。在这个表达式取值为 true
的情况下，可以使用<strong>向下转型</strong> (down cast) 来使用一个 A
类型的对象来引用obj： <code>A ao = (A)obj</code> 。注意，实际上 obj
所指向对象的创建类型永远不会发生变化，转型的只是对象引用类型。</p>
<p>本次作业中的应用为：哦好像没有应用，在下一个 task 里有应用</p>
<h3 id="四对象方法的重写和复用">四、对象方法的重写和复用</h3>
<blockquote>
<p>有时候，具有继承关系的类的某些行为具有递进关系，但又有自己特定的行为。</p>
<p>我们期望这两个类中实现的特定方法同名。<strong>这种让子类重新实现一个在父类中已经实现的方法是面向对象的一个重要机制，称为方法重写。</strong>方法重写获得的直接好处是让子类与父类在相应方法的调用上保持了一致性。</p>
<p>更通俗的说，重写方法与父类方法在行为上具有相似功能，但子类重写的方法一般额外增加一些行为。</p>
<p>在程序编写方面，一般会为重写方法标上一个@Override标签。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Course</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Course(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">displayInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这门课很难&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OOCourse</span> <span class="keyword">extends</span> <span class="title class_">Course</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">displayInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这门课很难&quot;</span>); <span class="comment">// 这里出现了代码拷贝，是低质量的代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;上面那句是放p&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议更换为下面的代码：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OOCourse</span> <span class="keyword">extends</span> <span class="title class_">Course</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">displayInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.displayInfo(); <span class="comment">// 调用了类Course中定义的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;上面那句是放p&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java语言提供了一个重要的关键词<strong>super</strong>，它实际指代的是当前对象从父类继承得到的内容</p>
<blockquote>
<p>联想上面构造函数里的super，你甚至可以理解为，这个super会替换为这个类的父类名称，这里使用
<code>Course.displayInfo()</code> 也是一样的效果，同理，构造函数
<code>super(argument)</code> 也可以替换为
<code>Course(argument)</code></p>
</blockquote>
<h3 id="五多态">五、多态</h3>
<p>实际调用的方法与对象<strong>引用的类型</strong>无关，取决于被引用对象的<strong>创建类型</strong>。请看下面的代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Course</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Course</span>();</span><br><span class="line"><span class="type">Course</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OOCourse</span>();</span><br><span class="line">c1.displayInfo();</span><br><span class="line">c2.displayInfo();</span><br></pre></td></tr></table></figure>
<p>其中通过c1调用的实际是Course类实现的displayInfo方法，而通过c2调用的则是OOCourse类重写的displayInfo方法，但实际上c1和c2的引用类型都是Course。上面我们提到的这个特性，就叫做多态。</p>
<p><strong>参差多态，乃是幸福本源</strong>（逃）</p>
<h3 id="六异常处理">六、异常处理</h3>
<blockquote>
<p>异常：程序运行时发生了意外的事件，阻止了程序按照程序员的预期正常执行</p>
</blockquote>
<p>运行出错后，Java
提供了一种优秀的解决办法：异常处理机制，它采取显式的方式处理异常，包括两个方面：</p>
<ul>
<li>引入了专门的表达和处理方式，代码上一目了然就能看出是异常处理；</li>
<li>一旦发生异常，会强迫程序执行进入异常处理分支。</li>
</ul>
<p>在Java语言中，每个异常都被封装为Exception，异常有抛出和捕捉两种处理方式。所谓抛出，就是使用Java提供的throw关键词来产生一个Exception或者其某个子类的对象；而捕捉则是通过catch关键词来捕捉在一段代码的执行过程中所抛出的相关异常对象。</p>
<p>课程推荐使用异常处理机制来区分处理显著不同于一般情况下的数据状态。使用异常处理可以让你的代码更加清晰易于理解，降低出现
bug 的可能性。</p>
<p>👆上面内容来自指导书<del>，相信我不说你也看出来了</del></p>
<p>前面代码出现异常后，后面的代码不会执行，程序会抛出异常并结束（×）</p>
<p>异常发生并不意味着程序终止，找到地方可以处理这个异常即可</p>
<p>当然，当前作用域，异常后面的部分不会执行</p>
<p>具体运行过程为：</p>
<p><img src="..\images\exception-execution.png" /></p>
<p>一个很全面覆盖上面流程图的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIndex</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        a[<span class="number">10</span>] = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">h</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            g();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">k</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            h();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;k()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            k();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;caught&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>解释：</p>
<p>f产生异常，所处不是try，所处是函数g，返回调用者g</p>
<p>g与f同理，返回调用者h</p>
<p>h产生异常，所处不是try，所处是if语句，不是函数，退出到if大括号的外层，此时所处是函数，返回调用者k</p>
<p>k产生异常，产生异常的代码块所处是try，catch异常不匹配（因为是AIOOBE），退出到外层</p>
<p>能不能把所有代码放到一个try块里，这样啥异常都能输出啊（逃）</p>
<p>《Core Java》的第七章相关内容请见：<del>紧锣密鼓筹备中</del></p>
<h2 id="pre1_task3">Pre1_task3</h2>
<h3 id="前言-碎碎念">前言 &amp; 碎碎念</h3>
<blockquote>
<p>这次作业真的有点难度，我也是借助了 bygg <span class="citation"
data-cites="一个虚空的blog地址">@一个虚空的blog地址</span> 的力量才勉强
AK 了</p>
</blockquote>
<p>难点主要在 deep clone 和 所属关系的复制</p>
<p>deep clone 这里呼应了前面说的向下转型 downcasting，具体来说，需要根据
Commodity 的类型创建对应的 Commodity 副本，此时需要用到 instanceof
运算符</p>
<p>具体的实现可以见代码，代码我放到 GitHub仓库 里了</p>
<p>这里的版本控制的实现，和 Git
的好像不大一样，先挖个坑，有空思考了回来填上</p>
<p>一个细的点在于，不能对 Adventurer 所拥有的 Adventurer 直接 deep
clone</p>
<p>举个例子，A 雇佣了 B，如果 deep clone，B 使用道具后的后果不能同步给 A
雇佣的这个 B，所以两个 B 就不一样了。这里直接 shallow
copy即可（其实也节省了代码量）</p>
<h2 id="pre2_task1">Pre2_task1</h2>
<p>挺好做的，可以用捕获组，也可以用字符串类的方法，不过后面迭代比较痛苦</p>
<p>另外，关于 substring()
方法，建议大家多试试下标的选择。不要怕麻烦，这个地方很可能背刺你</p>
<h2 id="pre2_task2">Pre2_task2</h2>
<p>这次也很简单。我感觉正则的题目比第一次的大模拟还是友好不少的</p>
<h2 id="pre2_task3">Pre2_task3</h2>
<p>注意跨年日期的判断（可以参考我的狼人样例，能过了强测基本没问题）</p>
<h2 id="pre3_task1">Pre3_task1</h2>
<p>想起pre1_task3那周，我在图书馆坐了整整一周，最后还是de不出bug，果然肉眼debug的形式是不行的。</p>
<p>建议大家自己捏一些数据</p>
<p>我的数据也放在 GitHub仓库 里了</p>
<p>正则表达式的题目，就建议大家多试多练多学习。我个人感觉没什么好说的，大家比我聪明，看一看就能学会</p>
<p>我一直没学先验后验什么的，挖个坑，下学期学，下学期一定学，嗯</p>
<h2 id="最后的最后">最后的最后</h2>
<p>看过很多博客，还是觉得qsgg的“<strong>只有</strong>一个曲别针的小男孩”的故事最入我心</p>
<p>小男孩经过一系列的交换，把手里的曲别针换成了别墅</p>
<p>可我觉得这故事没什么意思，我更想看到小男孩用别墅继续交换继续交换，最后虽然损失了别墅，但是收获了远比别墅珍贵更多的东西，最后云淡风轻：“嗯，不过损失一个曲别针而已，我得到的是更大的世界”</p>
<p>我来的时候连一个曲别针也没有，我走的时候却收获了很多故事，认识了很多朋友，收获了比别墅价值大得多的东西</p>
<p>很多很多年以后，可能我还会想起那个新主楼的夜晚和风景，和五教二楼的美丽对拍</p>
<p>或许要问有什么遗憾，那就是最后一次的作业赶时间没用递归下降完成。以及这门课确实有点耽误我计组的时间了，不过这都过去了</p>
<p>他给我的最大的宝藏就是，如果方法得当，愿意多做调试愿意自己多捏数据，你能够对自己的成绩有十足的把握，每次强测之前我都有信心这次再拿100。以及，他让我知道小白也有从零开始成为金刚的权利，真的让我尝到了取得小成就的满足</p>
<p>后面的文字写的有些仓促，主要是计组进度压上来，顶不住了，对不住各位认真读到这里的看官</p>
<p>以及正则的题目确实不难，希望大家认真学认真练</p>
<p>希望诸位看官能从我这堆毫无章法的文字中读出些东西</p>
<p>如果看完什么也没看明白，那是怪我水平粗浅，与诸位无关</p>
<p>一路顺风</p>
]]></content>
      <categories>
        <category>OO</category>
        <category>S3</category>
      </categories>
      <tags>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>「D2L」19-Convolution</title>
    <url>/d2l-19-convolution/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>动手学深度学习19 卷积层</p>
</blockquote>
<span id="more"></span>
<h2 id="回顾单隐藏层-mlp">回顾：单隐藏层 MLP</h2>
<p>// todo</p>
<blockquote>
<p>MLP是一种稠密的特征提取方式，而人类学习到的很有可能是一种稀疏的特征。</p>
</blockquote>
<p><strong>两个原则</strong></p>
<ul>
<li>平移不变性</li>
<li>局部性</li>
</ul>
]]></content>
      <categories>
        <category>AI</category>
        <category>S5</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>「BUAA-CO」 Pre</title>
    <url>/co-pre/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>2023年Pre题目回忆版及我的3A答案回忆版</p>
</blockquote>
<span id="more"></span>
<p>文件在我的 GitHub</p>
<h2 id="supaltitude">1.supaltitude</h2>
<p>骑手在初始海拔为 <span class="math inline">\(0\)</span>
的原点，依次读入数组大小 <span class="math inline">\(n\)</span>
和相邻两地点的海拔差 <span
class="math inline">\(gain[n]\)</span>，输出骑手所经过的最高海拔</p>
<p>数据范围 <span class="math inline">\(1 \le n \le 64\)</span></p>
<p><span class="math inline">\(-128 \le gain[n] \le 128\)</span></p>
<p>思路：题目所求即为数组最大前缀和，维护一个变量保存当前前缀和，并维护最大值即可，没有开辟数组空间的必要</p>
<p><strong>注</strong>：保存最高海拔的前提是数组的下标连续，而不能像买卖理财产品，只在有收益的时候售出。也即如下的代码思路是错误的（虽然我相信聪明的大家都想到了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (data &gt; <span class="number">0</span>) &#123; <span class="comment">// data is the input value</span></span><br><span class="line">    sum += data;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码挖空：</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="comment"># get n</span></span><br><span class="line">    <span class="comment"># set prefix sum, maximum value and loop var</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">for_loop:</span></span><br><span class="line">    <span class="comment"># get data</span></span><br><span class="line">    <span class="keyword">add </span> $<span class="built_in">s1</span>, $<span class="built_in">s1</span>, $<span class="built_in">t1</span></span><br><span class="line"><span class="symbol">if:</span></span><br><span class="line">    <span class="comment"># no need to update, jump to &#x27;else&#x27; label </span></span><br><span class="line">    <span class="keyword">move </span>$<span class="built_in">s2</span>, $<span class="built_in">s1</span> <span class="comment">#update</span></span><br><span class="line"><span class="symbol">else:</span></span><br><span class="line">    <span class="keyword">addi </span>$<span class="built_in">t0</span>, $<span class="built_in">t0</span>, <span class="number">1</span> <span class="comment"># DONT FORGET TO INCREMENT LOOP VAR</span></span><br><span class="line">    <span class="keyword">bne </span> $<span class="built_in">t0</span>, $<span class="built_in">s0</span>, for_loop</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">loop_end:</span></span><br><span class="line">    <span class="comment"># DONT FORGET TO PRINT</span></span><br></pre></td></tr></table></figure>
<p>此外建议大家在编写汇编代码时多用伪指令，能显著加快编程速度（毕竟这就是伪指令的使命）</p>
<p>如 <code>blt</code> 省去了 <code>slt</code> 和 <code>beq</code>
的使用，将两条指令合为一条；<code>move</code> 比 <code>add</code>
指令少一个操作数；<code>li</code> 比 <code>addi</code>
少两个操作数等等</p>
<h2 id="nodescendsequence">2.noDescendSequence</h2>
<p>识别16bit输入从高位到低位每4bit组成的4位序列是否为不下降序列</p>
<table>
<thead>
<tr class="header">
<th>信号</th>
<th>方向</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>data[15:0]</td>
<td>input</td>
<td>代表4位4bit输入</td>
</tr>
<tr class="even">
<td>result</td>
<td>out</td>
<td>输出结果：是否为不下降序列</td>
</tr>
</tbody>
</table>
<p>思路：本题<strong>不涉及时序逻辑</strong>，直接取 <code>data</code>
的对应位进行比较即可。一行代码我就不贴出来了（</p>
<h2 id="tetris">3.tetris</h2>
<p>模拟8位俄罗斯方块游戏设计 Mealy 状态机</p>
<table>
<thead>
<tr class="header">
<th>信号</th>
<th>方向</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>input[7:0]</td>
<td>I</td>
<td>八位独热码，模拟掉落一个俄罗斯方块</td>
</tr>
<tr class="even">
<td>reset</td>
<td>I</td>
<td><strong>异步复位</strong></td>
</tr>
<tr class="odd">
<td>clk</td>
<td>I</td>
<td>时钟信号</td>
</tr>
<tr class="even">
<td>output[1:0]</td>
<td>O</td>
<td>输出状态</td>
</tr>
</tbody>
</table>
<p>reset为<strong>异步复位</strong>，当reset为高电平时，状态恢复到一开始状态</p>
<p>状态：输出01表示输入位置已有方块，放置无效，保持原状态</p>
<p>输出10表示有效放置</p>
<p>输出11表示消去一行</p>
<h3 id="思路">思路</h3>
<p><strong>第一步也是最重要的一步，确定状态机类型。一时不慎，满盘皆输！！！</strong></p>
<p>方块的摆放情况数为 8 位二进制数的数量 <span
class="math inline">\(2^8\)</span>，再考虑每次独热码输入有 8
种，<strong>有效的</strong>状态转移真值表共约 <span
class="math inline">\(8 \times 2^8\)</span>
行，再考虑到无效的状态转移行，故采用真值表刻画状态转移的方式应该不是题目意图<del>（当然如果你毅力超群，我致以崇高敬意）</del>。我采取的方案是用当前的方块摆放情况表示状态，在
Mealy 状态机的输出模块再转换成 <code>output[1:0]</code></p>
<p>放置方块的行为让我联想到二进制的按位运算。判断某位是否已有方块，只需将输入和当前方块<strong>按位与</strong>，结果非
0
即为无效放置。而更新状态，只需将输入和当前方块放置状态<strong>按位或</strong>，注意<strong>特判</strong>放满后清空即可。</p>
<h3 id="tips">Tips</h3>
<p>注意到 logisim 中寄存器初值为 0，所以不用进行寄存器的初始化。</p>
<p>注意判断<strong>复位方式</strong>是同步复位还是异步复位。异步复位在
logisim 中的实现较为简单。</p>
<p>此外，注意判断<strong>时钟</strong>是输入还是自带信号。</p>
<p>还有一件事<del>（成龙历险记老爹音）</del>，题目要求的电路外观似乎不同于三输入一输出的默认外观，只需将左边三输入向下移动一格即可，外观的线不是很重要。</p>
<p>电路外观如图（已隐去部分内容）</p>
<p>最后，祝大家上机顺利，学有所获！</p>
]]></content>
      <categories>
        <category>CO</category>
        <category>S5</category>
      </categories>
      <tags>
        <tag>CO</tag>
        <tag>Replay</tag>
      </tags>
  </entry>
  <entry>
    <title>恋爱讲座</title>
    <url>/romantic-tutorial/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>2022 年的一场恋爱讲座笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="qa-恋爱前我准备好了吗">Q&amp;A 恋爱前我准备好了吗?</h3>
<p>Q1：我怀疑自己没有爱的能力</p>
<p>Q2：和喜欢的人聊天总会紧张，觉得自己不能和好朋友聊天那样正常发挥</p>
<p>Q3：如何看出来女生对一个男生的态度?</p>
<ul>
<li><p>用想象两人在一起后的方式来安抚紧张情绪</p></li>
<li><p>不太赞成疾风劲雨的表白，建议多接触脱敏。也可以更了解真实的对方，避免荷尔蒙上头的冲动</p></li>
<li><p>提一些更小的要求，如“做我npy吧”是个大要求，“今天一起吃个饭”是更小更具体的要求</p></li>
<li><p>给对方选择权更高的决定，如吃饭退出的成本可能比较高，但是散步不想散就随时可以走</p></li>
</ul>
<h3 id="酝酿恋爱">酝酿恋爱</h3>
<p>普通——关系好——时机成熟时表达</p>
<p><strong>爱要表达</strong>：鼓起勇气，发觉对方对你有好感，你往前推动一步</p>
<p>设计一些<strong>体验式的活动</strong>，相对多与对方接触</p>
<p><strong>表白</strong>：私密空间的个性化表达</p>
<ul>
<li>推荐一本书《如何让你爱的人爱上你》</li>
</ul>
<h3 id="恋爱中">恋爱中</h3>
<p>激情淡薄是自然的现象</p>
<p>你是否在这个过程中压抑了自己的心理而仅仅是期待对方做出改变？应该表达出自己的情绪和感受。比如，你期待对方在你的生日给你送礼物，对方没有送。看看ta关注生日吗？ta在生日时渴望有礼物吗？毕竟大家来自不同的地方，不同的性别（也可能相同），不同的原生家庭，有差异是最正常不过的事情。那你应该提前真诚地和ta说：“生日对我来说很重要，我期待这一天收到礼物”</p>
<p><strong>明确表达</strong>需要、意见和不愉快，给亲密关系以讨论差异、表达不一致的<strong>空间</strong></p>
<h3 id="分手">分手</h3>
<p>爱是强烈的，后悔也是真的</p>
<p>失落情绪是自然的，刻意通过“喝酒蹦迪”等形式屏蔽失落情绪也许对你的影响更大。也许用半年的时间来缓和都是正常的。</p>
<blockquote>
<p>当然如果超过半年的界限，建议寻找心理咨询</p>
</blockquote>
<p>合理向同性异性朋友倾诉。</p>
<blockquote>
<p>尝试和异性朋友倾诉，有利于得到异性的观点，丰富角度</p>
</blockquote>
<p>但仍然值得与你，没错过什么再分开。——《黄金广场》陈奕迅</p>
<p>投入地爱一次</p>
<p><strong>祝大家都能获得恋爱的自由</strong></p>
]]></content>
      <categories>
        <category>Romantic</category>
        <category>S2</category>
      </categories>
      <tags>
        <tag>Romantic</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora数学公式</title>
    <url>/MarkDown-Grammar/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>MarkDown 比较全的数学公式语法集合</p>
</blockquote>
<span id="more"></span>
<p>[TOC] &gt; 其实本质是对 Tex 语法的支持</p>
<h3 id="一打开typora选择数学模块">一、打开Typora选择数学模块</h3>
<p>三种打开方式： * 点击“段落” --&gt; “公式块” * 快捷键ctrl + shift +m *
“$$” + 回车</p>
<h3 id="二添加数学公式">二、添加数学公式</h3>
<p>输出美观的数学公式，需要知道他们的格式和代码！
ps:Typora有时出现公式块无法删除，可能是软件bug，Ctrl + /
打开源代码模式，在这里面可以进行删除 <span class="math display">\[
e^{i\pi + 1} = 2
\]</span> ### 三、常用的公式格式代码练习</p>
<ol type="1">
<li>公式块内换行</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">\\ 公式块内换行</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>常用基本函数：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">1、x^2 //上下标</span><br><span class="line">2、1/2 //分式1</span><br><span class="line">3、\frac&#123;1&#125;&#123;2&#125; //分式2</span><br><span class="line">4、\cdots //省略号</span><br><span class="line">5、\sqrt&#123;4&#125; //开根号</span><br><span class="line">6、\vec&#123;a&#125; //矢量</span><br><span class="line">7、\int&#123;x&#125;dx //积分1</span><br><span class="line">8、\int_&#123;1&#125;^&#123;2&#125;dx //积分2</span><br><span class="line">9、\lim&#123;a + b&#125; //极限1</span><br><span class="line">10、\lim_&#123;n\rightarrow + \infty&#125; //极限2</span><br><span class="line">11、\sum_&#123;n=1&#125;^&#123;100&#125;&#123;a_n&#125; //累加</span><br><span class="line">12、\prod_&#123;n=1&#125;^&#123;199&#125;&#123;x_n&#125; //累乘</span><br><span class="line">13、\sin&#123;(x + y)&#125; //三角函数</span><br><span class="line">14、\ln2 //对数函数1</span><br><span class="line">15、\log_28 //对数函数2</span><br><span class="line">16、a&#x27; //导数</span><br><span class="line">17、\partial&#123;F&#125; //偏微分</span><br><span class="line">18、\iint&#123;xy&#125;dxdy //二重积分</span><br><span class="line">19、\oiint&#123;x + y&#125;dxdy //二重环路积分</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
1、x^2\\
2、1/2\\
3、\frac{1}{2}\\
4、\cdots\\
5、\sqrt{4}\\
6、\vec{a}\\
7、\int{x}dx\\
8、\int_{1}^{2}dx\\
9、\lim{a + b}\\
10、\lim_{n\rightarrow + \infty}\\
11、\sum_{n=1}^{100}{a_n}\\
12、\prod_{n=1}^{199}{x_n}\\
13、\sin{(x + y)}\\
14、\ln2\\
15、\log_28\\
16、a&#39;\\
17、\partial{F}\\
18、\iint{xy}dxdy\\
19、\oiint{(x + y)}dxdy\\
\]</span></p>
<ol start="3" type="1">
<li>公式块内左对齐：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;aligned&#125; //</span><br><span class="line">&amp;1、y = \sin(x) \\&amp;为对齐格式符</span><br><span class="line">&amp;2、</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{aligned}
&amp;1、y = \sin(x) \\
&amp;2、
\end{aligned}
\]</span></p>
<ol start="4" type="1">
<li>下标</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">v_1\\</span><br><span class="line">v_&#123;体积&#125; 下标为多个英文字母时，使用&#123;&#125;包起来：</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
v_1\\
v_{体积}
\]</span></p>
<ol start="5" type="1">
<li>关系运算符：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">\pm // ± plus&amp;minor</span><br><span class="line">\times // ×</span><br><span class="line">\div // ÷ divide</span><br><span class="line">\equiv // == equal</span><br><span class="line">\le // &lt;= lower&amp;equal</span><br><span class="line">\ge // &gt;= greater&amp;equal</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\pm\\
\times \\
\div\\
\equiv\\
\leq\\
\geq
\]</span></p>
<ol start="6" type="1">
<li>花括号公式组合：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">c(u) =</span><br><span class="line">\begin&#123;cases&#125; </span><br><span class="line">\sqrt\frac&#123;1&#125;&#123;N&#125;, u = 0 \\ </span><br><span class="line">\sum_&#123;n=1&#125;^&#123;100&#125;&#123;a_n&#125;, n \neq0  neq:not equal</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
c(u) =
\begin{cases}
\sqrt\frac{1}{N}, u = 0 \\
\sum_{n=1}^{100}{a_n}, n \neq0
\end{cases}
\]</span></p>
<ol start="7" type="1">
<li>空格：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">a \quad b</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
a \quad b
\]</span></p>
<ol start="8" type="1">
<li>矩阵：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">0&amp;1&amp;1\\</span><br><span class="line">1&amp;1&amp;0\\</span><br><span class="line">1&amp;0&amp;1\\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{matrix}
0&amp;1&amp;1\\
1&amp;1&amp;0\\
1&amp;0&amp;1\\
\end{matrix}
\]</span></p>
<blockquote>
<p>在起始、结束标记用下列词替换 matrix：</p>
<p>pmatrix：小括号边框 bmatrix：中括号边框 ` Bmatrix：大括号边框
vmatrix：单竖线边框 Vmatrix：双竖线边框</p>
</blockquote>
<p><span class="math display">\[
\begin{pmatrix}
0&amp;1&amp;1\\
1&amp;1&amp;0\\
1&amp;0&amp;1\\
\end{pmatrix}
\]</span></p>
<p><span class="math display">\[
\begin{vmatrix}
0&amp;1&amp;1\\
1&amp;1&amp;0\\
1&amp;0&amp;1\\
\end{vmatrix}
\]</span></p>
<ol start="9" type="1">
<li>特殊字符及希腊字母表：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\infty //无穷</span><br><span class="line">\emptyset //空集</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\infty \\
\emptyset
\]</span></p>
<ol start="10" type="1">
<li>更多字符 更多特殊字符及希腊字母代码见wps中LaTex公式符号</li>
</ol>
<p>① 常用字母字符</p>
<figure>
<img
src="https://i0.hdslb.com/bfs/article/a76a8e35df7722e6b3d02b70f579380bc768afbf.png@921w_459h_progressive.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>② 特殊符号</p>
<figure>
<img
src="https://i0.hdslb.com/bfs/article/5f471724c265c39e6c832a9a3212f67aa094791e.png@942w_387h_progressive.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="https://i0.hdslb.com/bfs/article/a750d31bd5a69f8dd8b58c6b2d690988025d323c.png@942w_1500h_progressive.webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
]]></content>
      <categories>
        <category>Tools</category>
        <category>S2</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Group Theory</title>
    <url>/visual-group-theory-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="总述">总述</h2>
<blockquote>
<p>English notes of Visual Group Theory</p>
<span id="more"></span>
</blockquote>
<h1 id="visual-group-theory">Visual Group Theory</h1>
<blockquote>
<p>Start on 7-5-2023</p>
</blockquote>
<h2 id="overview">Overview</h2>
<p>Three nonstandard aspect of nonstandard approach in the book:</p>
<ul>
<li><strong>images and visual examples</strong>-the heart</li>
<li>focuses more on finite groups than infinite ones-easier to diagram
and give a solid foundation of intuition</li>
<li>approaches groups from the opposite direction of traditional
textbooks-groups are defined to be collections of actions and later
proved to be sets with binary operations</li>
<li><strong>linear order</strong>, to be read in order</li>
<li>exceptions: Chapter 5 and Chapter 10, you can skip most of them
without understanding other chapters. But the definition of abelian in
Section 5.2 and the Cauchy's Theorem in Section 9.2 are important</li>
</ul>
<h2 id="what-is-a-group">What is a group?</h2>
<blockquote>
<p>Group theory is not primarily about numbers, but rather about
<strong>patterns</strong> and <strong>symmetry</strong></p>
</blockquote>
<h4 id="four-key-observations">Four key observations</h4>
<p>Observation 1</p>
<ul>
<li>There is a predefined list of moves that never changes.</li>
</ul>
<p>Observation 2</p>
<ul>
<li>Every move is reversible.</li>
</ul>
<p>Observation 3</p>
<ul>
<li>Every move is deterministic.</li>
</ul>
<p>Observation 4</p>
<ul>
<li>Moves can be combined in any sequence.</li>
</ul>
<p>A move is a twist of one of the six faces.</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507155405607.png"
alt="image-20230507155405607" />
<figcaption aria-hidden="true">image-20230507155405607</figcaption>
</figure>
<p>Let's rephrase the 4 observations as rules (axioms) that will define
the boundaries of our objects of study.</p>
<h4 id="rules-of-groups">Rules of groups</h4>
<p>Rule 1</p>
<ul>
<li>There is a predefined of <strong>actions</strong> that never
changes.</li>
</ul>
<p>Rule 2</p>
<ul>
<li>Every action is reversible.</li>
</ul>
<p>Rule 3</p>
<ul>
<li>Every action is deterministic.</li>
</ul>
<p>Rule 4</p>
<ul>
<li>Any sequence of consecutive actions is also an action.</li>
</ul>
<blockquote>
<p>We swapped the word "move" for "action"</p>
<p>The (usually short) list of actions required by Rule 1 is our set of
building blocks; called the <strong>generators</strong>.</p>
<p><strong>Not</strong> all actions are generators. Generators are the
subset of all possible actions in a group.</p>
<p>Rule 4 tells us that any sequence of the generators is also an
action.</p>
</blockquote>
<p>Our unofficial definition of a group (We'll make things a bit
rigorous later.)</p>
<h4 id="definition-informal">Definition (informal)</h4>
<blockquote>
<p>A group is a set of actions satisfying Rules 1-4.</p>
</blockquote>
<p>Let's call these generators a, b, c, d, e, and f. Every word over the
alphabet <span class="math inline">\(\{a, b, c, d, e, f\}\)</span>
describes a unique configuration of the cube (starting from the solved
position)</p>
<blockquote>
<p>Obviously, I don't care which is which.</p>
</blockquote>
<h4 id="summary-of-the-big-ideas">Summary of the big ideas</h4>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507160953096.png"
alt="image-20230507160953096" />
<figcaption aria-hidden="true">image-20230507160953096</figcaption>
</figure>
<h2 id="cayley-graphs">Cayley graphs</h2>
<h3 id="a-road-map-for-the-rubiks-cube">A road map for the Rubik's
Cube</h3>
<p>Let's pretend for a moment that we were interested in writing a
complete solutions manual for the Rubik's Cube. And let me be more
specific</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507161729491.png"
alt="image-20230507161729491" />
<figcaption aria-hidden="true">image-20230507161729491</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507161902686.png"
alt="image-20230507161902686" />
<figcaption aria-hidden="true">image-20230507161902686</figcaption>
</figure>
<blockquote>
<p>We can think of the <em>Big Book</em> as a road map for the Rubik's
Cube. Each page says "you are here" and “if you follow this road, you'll
end up over there."</p>
</blockquote>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507162334393.png"
alt="image-20230507162334393" />
<figcaption aria-hidden="true">image-20230507162334393</figcaption>
</figure>
<blockquote>
<p>Despite the Big Book's apparent shortcomings, it made for a good
thought experiment. The Big Book is a map of a group. The Big Book
introduced the mapmaking ideas, although the map is too large. We can
use the same ideas to map out any group. In fact, we shall frequently do
exactly that.</p>
<p>And Let's try something simpler....</p>
</blockquote>
<h3 id="the-rectangle-puzzle">The Rectangle Puzzle</h3>
<blockquote>
<p>How can we check the moves of the Rectangle Puzzle form a group?</p>
</blockquote>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507165129308.png"
alt="image-20230507165129308" />
<figcaption aria-hidden="true">image-20230507165129308</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507170457691.png"
alt="image-20230507170457691" />
<figcaption aria-hidden="true">image-20230507170457691</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507170733456.png"
alt="image-20230507170733456" />
<figcaption aria-hidden="true">image-20230507170733456</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507171547441.png"
alt="image-20230507171547441" />
<figcaption aria-hidden="true">image-20230507171547441</figcaption>
</figure>
<h3 id="more-on-arrows">More on arrows</h3>
<ul>
<li><p>node <span class="math inline">\(y\)</span> is the result of
applying the action $ g G $ to node $x $.</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507173327983.png"
alt="image-20230507173327983" />
<figcaption aria-hidden="true">image-20230507173327983</figcaption>
</figure></li>
<li><p>if an action <span class="math inline">\(h \in G\)</span> is its
own inverse (that is, <span class="math inline">\(h ^ 2 = e\)</span>),
then we have a 2-way arrow. For clarity, our convention is to drop the
tips on all 2-way arrows like that</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507173338448.png"
alt="image-20230507173338448" />
<figcaption aria-hidden="true">image-20230507173338448</figcaption>
</figure></li>
<li><p>When we focus on a group's structure, we frequently omit the
labels at the nodes</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507173356200.png"
alt="image-20230507173356200" />
<figcaption aria-hidden="true">image-20230507173356200</figcaption>
</figure></li>
</ul>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507185713813.png"
alt="image-20230507185713813" />
<figcaption aria-hidden="true">image-20230507185713813</figcaption>
</figure>
<blockquote>
<p>isomorphic: corresponding or similar in form and relations.</p>
</blockquote>
<h3 id="the-klein-4-group">The Klein 4-group</h3>
<p>Any group with the same Cayley diagram as the Rectangle Puzzle and
the 2-Light Switch Group is called the Klein 4-group, denoted by <span
class="math inline">\(V_4\)</span> for <em>vierergruppe</em>,
“four-group" in German. It is named after the mathematician Felix
Klein.</p>
<h3 id="the-triangle-puzzle">The triangle puzzle</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507190725806.png"
alt="image-20230507190725806" />
<figcaption aria-hidden="true">image-20230507190725806</figcaption>
</figure>
<h3 id="properties-of-cayley-graphs">Properties of Cayley graphs</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507191305245.png"
alt="image-20230507191305245" />
<figcaption aria-hidden="true">image-20230507191305245</figcaption>
</figure>
<h3 id="a-theorem-and-proof">A Theorem and Proof!</h3>
<p>Theorem Suppose an action <span class="math inline">\(g\)</span> has
the property that <span class="math inline">\(gx = x\)</span> for some
other action <span class="math inline">\(x\)</span>. Then g is the
<em>identity action</em>, i.e., <span class="math inline">\(gh = h =
hg\)</span> for all other actions <span
class="math inline">\(h\)</span>.</p>
<blockquote>
<p><span class="math inline">\(g\)</span> apply to <em>anything
else</em> !</p>
</blockquote>
<p>Proof:</p>
<blockquote>
<p>The identity action (we'll denote by 1) is simply the action <span
class="math inline">\(hh^{-1}\)</span>, for any action <span
class="math inline">\(h\)</span>. If <span class="math inline">\(gx =
x\)</span>, then multiplying by <span
class="math inline">\(x^{-1}\)</span> <em>on the right</em> yields:</p>
<p><span class="math display">\[g = gxx^{-1} = xx^{-1} = 1\]</span>.</p>
<p>Thus <span class="math inline">\(g\)</span> is the identity
action.</p>
</blockquote>
<h2 id="groups-in-science-art-and-mathematics">Groups in science, art,
and mathematics</h2>
<h3 id="group-of-symmetries">Group of symmetries</h3>
<h3 id="how-to-make-a-group-out-of-symmetries">How to make a group out
of symmetries</h3>
<p>Groups relate to symmetry because an object's symmetries can be
described using arrangements of the object's parts.</p>
<p>Algorithm 1. Identify all the parts of the object that are similar
(e.g., the corners of an n-gon), and give each such part a different
number. 2. Consider the actions that may rearrange the numbered parts,
but leave the object it the same physical space. (This collection of
actions forms a group. 3. (Optional) If you want to visualize the group,
explore and map it as we did in the previous lecture with the rectangle
puzzle, etc.</p>
<p><strong>Footprint</strong>: the physical space that an object
occupies</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507193006888.png"
alt="image-20230507193006888" />
<figcaption aria-hidden="true">image-20230507193006888</figcaption>
</figure>
<blockquote>
<p>This section seems to be useless. So if I have time later, let's
continue to see at 9:37.</p>
</blockquote>
<h2 id="group-presentations">Group presentations</h2>
<blockquote>
<p>Our definition of groups before (a collection of actions that obeyed
Rules 1-4) is not the ordinary definition of a group. We'll be working
toward introducing the standard (and more formal) definition of a group.
Along the way, we will learn some helpful <strong>tools</strong> to get
us there.</p>
<p>Group presentations, an algebraic device to concisely describe groups
by their <strong>generators</strong> and <strong>relations</strong>.</p>
</blockquote>
<h3 id="more-on-cayley-diagrams">More on Cayley diagrams</h3>
<p>All arrows of a fixed color correspond to the same generator.</p>
<p>Two things with the node:</p>
<ul>
<li><p>Labeling the nodes with configurations of a thing we are acting
on</p></li>
<li><p>Leaving the nodes unlabeled (this is the "abstract Cayley
diagram”)</p></li>
<li><p>Label the nodes with actions (this is called a “diagram of
actions").</p>
<blockquote>
<p>motivated by the fact that every <strong>path</strong> in the Cayley
diagram represents an <strong>action</strong> of the group</p>
</blockquote></li>
</ul>
<p>Motivating idea If we distinguish one node as the “unscrambled”
configuration and label that with the identity action, then we can label
each remaining node with the action that it takes to reach it from the
unscrambled state.</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230507210640251.png"
alt="image-20230507210640251" />
<figcaption aria-hidden="true">image-20230507210640251</figcaption>
</figure>
<h3 id="a-group-calculator">A "group calculator"</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230510215301253.png"
alt="image-20230510215301253" />
<figcaption aria-hidden="true">image-20230510215301253</figcaption>
</figure>
<p>A concise way to describe <span class="math inline">\(V_4\)</span> is
the following group representation: <span class="math display">\[
V_4 = &lt;v, h | v^2 = e, h^2 = e, vh = hv &gt;
\]</span> The following is one (of many!) presentations for this group:
<span class="math display">\[
D_3 = &lt;r, f | r^3 = e, f^2 = e, r^2f = fr&gt;
\]</span></p>
<blockquote>
<p>To be more precise</p>
</blockquote>
<p>If we want to be more precise, we use a <strong>group
presentation</strong> of the following form: <span
class="math display">\[
G = &lt;generators | relations&gt;
\]</span> The vertical bar here can be thought of as meaning "subject
to".<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230510220205721.png"
alt="image-20230510220205721" /></p>
<blockquote>
<p>The famous "halting problem" is unsolvable</p>
</blockquote>
<h2 id="multiplication-tables">Multiplication tables</h2>
<blockquote>
<p>We are almost ready to introduce the formal definition of a group In
this lecture, we will introduce one more useful algebraic tool for
better understanding groups: multiplication tables. We will also look
more closely at inverses of the actions in a group. Finally, we will
introduce a new group of size 8 called the quaternions which frequently
arise in theoretical physics.</p>
</blockquote>
<h3 id="inverses">Inverses</h3>
<p>denoted by <span class="math inline">\(g^{-1}\)</span></p>
<h3 id="multiplication-tables-1">Multiplication tables</h3>
<p>follow the convention that write row <span
class="math inline">\(g\)</span> before column <span
class="math inline">\(h\)</span></p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230510221817825.png"
alt="image-20230510221817825" />
<figcaption aria-hidden="true">image-20230510221817825</figcaption>
</figure>
<h3 id="some-remarks">Some remarks</h3>
<p>A group is abelian <span class="math inline">\(iff\)</span> its
multiplication table is symmetric about the “main diagonal."</p>
<p>In each row and each column, each group action occurs exactly
once.</p>
<blockquote>
<p>The following theorem will explain that</p>
</blockquote>
<p><strong>Theorem:</strong> An element cannot appear twice in the same
row or column of a multiplication table.</p>
<p><strong>Proof:</strong></p>
<p>Suppose that in row <span class="math inline">\(a\)</span>, the
element <span class="math inline">\(g\)</span> appears in columns <span
class="math inline">\(b\)</span> and <span
class="math inline">\(c\)</span>. Algebraically, this means <span
class="math display">\[
ab=g=ac
\]</span> Multiplying everything on the left by <span
class="math inline">\(a^{-1}\)</span> yields <span
class="math display">\[
a^{-l}ab=a^{-1}g=a^{-1}ac \Rightarrow b = c
\]</span> Thus, <span class="math inline">\(g\)</span> (or any element)
element cannot appear twice in the same row.</p>
<p>Similarly, we can finish the proof for column.</p>
<h3 id="the-quaternion-group">The quaternion group</h3>
<h2 id="the-formal-definition-of-a-group">The formal definition of a
group</h2>
<p><span class="math inline">\(S\)</span> is closed on the operation
*</p>
<h3 id="associativity">Associativity</h3>
<p>交换律</p>
<p>An operation is associative if parentheses are permitted anywhere,
but required nowhere.</p>
<h3 id="formal-definitions">Formal definitions</h3>
<p>Viewing groups from these two different paradigms:</p>
<ul>
<li>a group as a collection of actions</li>
<li>a group as a set with a binary operation</li>
</ul>
<h3 id="properties">Properties</h3>
<p><strong>Theorem: </strong>Every element of a group has a
<em>unique</em> inverse</p>
<p><strong>Proof:</strong></p>
<p><strong>Theorem:</strong> Every group has a <em>unique</em> identity
element</p>
<h2 id="cyclic-and-abelian-groups">Cyclic and abelian groups</h2>
<h3 id="overview-1">Overview</h3>
<p><span class="math inline">\(5\)</span> families of groups:</p>
<ul>
<li>cyclic groups</li>
<li>abelian groups</li>
<li>dihedral groups</li>
<li>symmetric groups</li>
<li>alternating groups</li>
</ul>
<p>Informally, a group is cyclic if it is generated by a single element,
and is abelian if multiplication commutes. (Like <span
class="math inline">\(a * b = b * a, \forall a, b \in G\)</span>)</p>
<h3 id="cyclic-groups-additively">Cyclic groups, additively</h3>
<p><strong>Definition:</strong> A group is cyclic if it can be generated
by a single element.</p>
<blockquote>
<p>Finite cyclic groups describe the symmetry of objects that have
<em>only</em> rotational symmetry.</p>
</blockquote>
<p><span class="math display">\[
C_n = &lt;r| r^n = e&gt;
\]</span></p>
<p><strong>Remark:</strong> This is a natural generator, but not the
only one. For instance, <span class="math inline">\(r^3\)</span> is also
a generator.</p>
<p><strong>Definition:</strong> The order of a group <span
class="math inline">\(G\)</span> is the number of distinct elements in
<span class="math inline">\(G\)</span>, denoted by <span
class="math inline">\(|G|\)</span>.</p>
<p>The cyclic group of order <span class="math inline">\(n\)</span>
(i.e., <span class="math inline">\(n\)</span> rotations) is denoted
<span class="math inline">\(C_n\)</span> (or sometimes by <span
class="math inline">\(\mathbb{Z}_n\)</span>). In fact, the alternative
notation <span class="math inline">\(\mathbb{Z}_n\)</span> comes from
the fact that the binary operation in <span
class="math inline">\(C_n\)</span> is just modular addition. To add two
numbers in <span class="math inline">\(\mathbb{Z}_n\)</span>, add them
as integers, divide by <span class="math inline">\(n\)</span>, and take
the remainder.</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230512195612827.png"
alt="image-20230512195612827" />
<figcaption aria-hidden="true">image-20230512195612827</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230512195732611.png"
alt="image-20230512195732611" />
<figcaption aria-hidden="true">image-20230512195732611</figcaption>
</figure>
<h3 id="cyclic-groups-multiplicatively">Cyclic groups,
multiplicatively</h3>
<p>If <span class="math inline">\(r\)</span> is a generator (e.g., a
rotation by <span class="math inline">\(2 \pi /n\)</span>), then we can
denote the <span class="math inline">\(n\)</span> elements by <span
class="math display">\[
1, r, r^2, \dots , r^{n-1}
\]</span> Think of <span class="math inline">\(r\)</span> as the complex
number <span class="math inline">\(e^{2\pi i/n}\)</span>, with the group
operation being <em>multiplication!</em></p>
<blockquote>
<p>复数相乘，模相乘，辐角相加</p>
</blockquote>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230512202225352.png"
alt="image-20230512202225352" />
<figcaption aria-hidden="true">image-20230512202225352</figcaption>
</figure>
<h3 id="more-on-cyclic-groups">More on cyclic groups</h3>
<p>The (unique) infinite cyclic group (additively) is (<span
class="math inline">\(\mathbb{Z}, +\)</span>), the integers under
addition. Using multiplicative notation, the infinite cyclic group is
<span class="math display">\[
G=&lt;r\quad|\quad&gt;=\{r^k : k \in \mathbb{Z}\}
\]</span> For the infinite group <span
class="math inline">\((\mathbb{Z}, +)\)</span>, only <span
class="math inline">\(1\)</span> or <span
class="math inline">\(-1\)</span> can be generators. (Considering
multiple generators are pointless.)</p>
<p><strong>Proposition:</strong> Any number from <span
class="math inline">\(\{0, 1, \dots, n-1\}\)</span> that is relatively
prime to <span class="math inline">\(n\)</span> will generate <span
class="math inline">\(\mathbb{Z}_n\)</span>.</p>
<p>For example, <span class="math inline">\(1, 2, 3, 4\)</span> all
generate <span class="math inline">\(\mathbb{Z}_5\)</span>. i.e., <span
class="math display">\[
\mathbb{Z}_5 = &lt;1&gt; = &lt;2&gt; = &lt;3&gt; = &lt;4&gt;.
\]</span></p>
<blockquote>
<p>The above notation just means "generated by" instead of a
presentation.</p>
</blockquote>
<p><strong>Observation:</strong> One of the most important properties of
the multiplication tables is that, if the headings on the multiplication
table are arranged in the "natural" order <span
class="math inline">\((0, 1, 2, \dots , n-1)\)</span> or <span
class="math inline">\((e, r, r^2, \dots, r^{n-1})\)</span>, then each
row is a cyclic shift to the left of the row above it.</p>
<h3 id="orbits">Orbits</h3>
<p>Orbits are usually written with braces. In the case, the orbit of
<span class="math inline">\(r\)</span> is <span
class="math inline">\(\{e, r, r^2\}\)</span>, and the orbit of <span
class="math inline">\(f\)</span> is <span class="math inline">\(\{e,
f\}\)</span></p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230514201107827.png"
alt="image-20230514201107827" />
<figcaption aria-hidden="true">image-20230514201107827</figcaption>
</figure>
<p><strong>Definition:</strong> The order of an element</p>
<blockquote>
<p>Anything you can get by the path, following or backwards</p>
</blockquote>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230514230616848.png"
alt="image-20230514230616848" />
<figcaption aria-hidden="true">image-20230514230616848</figcaption>
</figure>
]]></content>
      <tags>
        <tag>Notes</tag>
        <tag>Group Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础教程（第3版）阅读笔记</title>
    <url>/python-book-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>Python的入门书，结合了暑假 Python 课的内容</p>
</blockquote>
<span id="more"></span>
<h1 id="一基础知识">一、基础知识</h1>
<h2 id="python-的碎碎念">Python 的碎碎念</h2>
<p><strong>Python
是一种解释型、面向对象、动态数据类型的高级程序设计语言。</strong></p>
<ul>
<li><strong>解释型语言：</strong>
开发过程中没有编译环节。类似于PHP和Perl语言。</li>
<li><strong>交互式语言：</strong> 可以在一个 Python 提示符
<strong>&gt;&gt;&gt;</strong> 后直接执行代码。</li>
<li><strong>面向对象语言：</strong>Python支持面向对象的风格或代码封装在对象的编程技术。</li>
<li><strong>初学者的语言：</strong>Python
对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到
WWW 浏览器再到游戏。</li>
</ul>
<p>澄清一下，Python 起源于一个幽默团体，而非蟒蛇（（（</p>
<h2 id="运行-python-的三种方式">运行 Python 的三种方式</h2>
<h3 id="交互式解释器">1、交互式解释器：</h3>
<p>通过命令行窗口进入 Python，在交互式解释器中编写 Python 代码</p>
<blockquote>
<p><em>小知识：交互式会话中所有语句都会被单独执行并且打印出内容</em></p>
</blockquote>
<h3 id="命令行脚本">2、命令行脚本</h3>
<p>常用的命令行参数：<code>python file</code> 在给定的文件执行 Python
脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:&gt;python script.py # Windows/DOS</span><br></pre></td></tr></table></figure>
<h3 id="ide-pycharm">3、IDE: PyCharm</h3>
<h2 id="中文编码">中文编码</h2>
<p>Python3.X 源码文件默认使用utf-8编码，所以可以正常解析中文，无需指定
UTF-8 编码。如果使用编辑器，同时需要设置 py 文件存储的格式为 UTF-8</p>
<h2 id="标识符">标识符</h2>
<p>以下划线开头的标识符是有特殊意义的。</p>
<p>以单下划线开头 <strong><code>_foo</code></strong>
的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用
<strong><code>from xxx import *</code></strong> 而导入。</p>
<p>以双下划线开头的 <strong><code>__foo</code></strong> 代表类的
<code>private</code> 成员，以双下划线开头和结尾的
<strong><code>__foo__</code></strong> 代表 Python
里特殊方法专用的标识，如 <strong><code>__init__()</code></strong>
代表类的构造函数。</p>
<p>分号用于分开一行内的多个语句</p>
<h2 id="空行">空行</h2>
<p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<blockquote>
<p>你只需要简单地在 PyCharm 里自动格式化就 OK</p>
</blockquote>
<h2 id="运算符">运算符</h2>
<p>绝大部分算术运算符及位运算符同 C 语言（除 <code>//</code> 和
<code>and</code> <code>or</code> <code>not</code>
，这三位是布尔运算符）</p>
<p>双斜线 <code>//</code> 会对结果进行 <code>floor</code> 操作，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> // -<span class="number">3</span></span><br><span class="line">-<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><code>**</code>
是幂次，注意幂次的优先级比取反要高（事实上是最高的），所以 <span
class="math inline">\((-3)^2\)</span> 应写为 <code>(-3) ** 2</code></p>
<p>成员运算符 <code>in</code> <code>not in</code></p>
<p>身份运算符 <code>is</code> <code>is not</code></p>
<h2 id="十六进制和八进制数">十六进制和八进制数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0xAF</span></span><br><span class="line"><span class="number">175</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span>10</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="comment"># 这个会报错，应该改为0o10</span></span><br><span class="line"><span class="comment">#   File &quot;&lt;stdin&gt;&quot;, line 1</span></span><br><span class="line"><span class="comment">#   010</span></span><br><span class="line"><span class="comment">#   ^</span></span><br><span class="line"><span class="comment"># SyntaxError: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0b1011010010</span></span><br><span class="line"><span class="number">722</span></span><br></pre></td></tr></table></figure>
<h2 id="变量">变量</h2>
<p>Python 中变量没有默认值，必须给它赋值</p>
<blockquote>
<p>通过赋值的方式声明变量</p>
</blockquote>
<h2 id="语句">语句</h2>
<p>所有语句的基本特征：执行修改操作，如赋值语句改变变量，<code>print</code>
语句改变屏幕外观（Python 2.X）</p>
<blockquote>
<p>很有意思的一句话</p>
</blockquote>
<h2 id="获取用户输入">获取用户输入</h2>
<p>input 会把所有的输入以文本或字符串的方式返回</p>
<h2 id="if-语句">if 语句</h2>
<p>在交互式解释器中执行时，需要按两次回车才能执行</p>
<h2 id="函数">函数</h2>
<p>round 函数会取整到最近的数字，如果两个数字一样近就取整到偶数</p>
<h2 id="模块">模块</h2>
<p>可以将模块视为扩展，导入模块可以扩展 Python 功能</p>
<p>并且可以使用变量来引用函数</p>
<h2 id="保存并执行程序">保存并执行程序</h2>
<p>很有意思的海龟机器人，可以用来画图</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230312020233185.png"
alt="image-20230312020233185" />
<figcaption aria-hidden="true">image-20230312020233185</figcaption>
</figure>
<h1 id="二变量类型">二、变量类型</h1>
<p>Python 定义了五个标准的数据类型：</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Dictionary（字典）</li>
</ul>
<h2 id="数字">数字</h2>
<p>Python支持三种不同的数字类型：</p>
<ul>
<li>int（有符号整型）</li>
<li>float（浮点型）</li>
<li>complex（复数）</li>
</ul>
<blockquote>
<p><em>在 Python3.X 版本中 long 类型被移除，使用 int 替代。</em></p>
</blockquote>
<p>int
类型是无上限的，数字变量是不可变的，如果改变值将重新分配内存空间</p>
<blockquote>
<p>Python 中采用引用语义，如果对变量重新赋值会重新分配空间存放新值</p>
<p>C 中采用值语义，更改原地址的数据内容</p>
</blockquote>
<p>一个小栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">2512373612848</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">2512373612848</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">2512373612912</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">2512373612848</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转换">类型转换</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int(x [,base ])         将x转换为一个整数，base是基值（进制数）</span><br><span class="line">float(x )               将x转换到一个浮点数  </span><br><span class="line">complex(real [,imag ])  创建一个复数  </span><br><span class="line">str(x )                 将对象 x 转换为字符串  </span><br><span class="line">repr(x )                将对象 x 转换为表达式字符串  </span><br><span class="line">eval(str )              用来计算在字符串中的有效Python表达式,并返回一个对象  </span><br><span class="line">tuple(s )               将序列 s 转换为一个元组  </span><br><span class="line">list(s )                将序列 s 转换为一个列表  </span><br><span class="line">chr(x )                 将一个整数转换为一个字符  </span><br><span class="line">unichr(x )              将一个整数转换为Unicode字符  </span><br><span class="line">ord(x )                 将一个字符转换为它的整数值  </span><br><span class="line">hex(x )                 将一个整数转换为一个十六进制字符串  </span><br><span class="line">oct(x )                 将一个整数转换为一个八进制字符串  </span><br></pre></td></tr></table></figure>
<h2 id="mathcmath">math、cmath</h2>
<p>二者模块函数基本一致，只是运算对象不同</p>
<h3 id="数学函数">数学函数</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">返回值 ( 描述 )</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-abs.html">abs(x)</a></td>
<td style="text-align: left;">返回数字的绝对值，如abs(-10) 返回 10</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-ceil.html">ceil(x)</a></td>
<td style="text-align: left;">返回数字的上入整数，如math.ceil(4.1) 返回
5</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-cmp.html">cmp(x,
y)</a></td>
<td style="text-align: left;">如果 x &lt; y 返回 -1, 如果 x == y 返回 0,
如果 x &gt; y 返回 1</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-exp.html">exp(x)</a></td>
<td style="text-align: left;">返回e的x次幂(ex),如math.exp(1)
返回2.718281828459045</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-fabs.html">fabs(x)</a></td>
<td style="text-align: left;">返回数字的绝对值，如math.fabs(-10)
返回10.0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-floor.html">floor(x)</a></td>
<td style="text-align: left;">返回数字的下舍整数，如math.floor(4.9)返回
4</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-log.html">log(x)</a></td>
<td
style="text-align: left;">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-log10.html">log10(x)</a></td>
<td
style="text-align: left;">返回以10为基数的x的对数，如math.log10(100)返回
2.0</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-max.html">max(x1,
x2,...)</a></td>
<td
style="text-align: left;">返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-min.html">min(x1,
x2,...)</a></td>
<td
style="text-align: left;">返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-modf.html">modf(x)</a></td>
<td
style="text-align: left;">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-pow.html">pow(x,
y)</a></td>
<td style="text-align: left;">x**y 运算后的值。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">[round(x <a
href="https://www.runoob.com/python/func-number-round.html">,n])</a></td>
<td
style="text-align: left;">返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-sqrt.html">sqrt(x)</a></td>
<td style="text-align: left;">返回数字x的平方根</td>
</tr>
</tbody>
</table>
<blockquote>
<p>与 C 语言的数学函数基本一致</p>
</blockquote>
<h3 id="随机数函数">随机数函数</h3>
<p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-choice.html">choice(seq)</a></td>
<td
style="text-align: left;">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td>
</tr>
<tr class="even">
<td style="text-align: left;">[randrange (<a
href="https://www.runoob.com/python/func-number-randrange.html">start,]
stop [,step])</a></td>
<td
style="text-align: left;">从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为
1</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-random.html">random()</a></td>
<td style="text-align: left;">随机生成下一个实数，它在[0,1)范围内。</td>
</tr>
<tr class="even">
<td style="text-align: left;">[seed(<a
href="https://www.runoob.com/python/func-number-seed.html">x])</a></td>
<td
style="text-align: left;">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-shuffle.html">shuffle(lst)</a></td>
<td style="text-align: left;">将序列的所有元素随机排序</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-uniform.html">uniform(x,
y)</a></td>
<td style="text-align: left;">随机生成下一个实数，它在[x,y]范围内。</td>
</tr>
</tbody>
</table>
<h3 id="三角函数">三角函数</h3>
<table>
<colgroup>
<col style="width: 55%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">函数</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-acos.html">acos(x)</a></td>
<td style="text-align: left;">返回x的反余弦弧度值。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-asin.html">asin(x)</a></td>
<td style="text-align: left;">返回x的反正弦弧度值。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-atan.html">atan(x)</a></td>
<td style="text-align: left;">返回x的反正切弧度值。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-atan2.html">atan2(y,
x)</a></td>
<td style="text-align: left;">返回给定的 X 及 Y 坐标值的反正切值。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-cos.html">cos(x)</a></td>
<td style="text-align: left;">返回x的弧度的余弦值。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-hypot.html">hypot(x,
y)</a></td>
<td style="text-align: left;">返回欧几里德范数 sqrt(x<em>x +
y</em>y)。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-sin.html">sin(x)</a></td>
<td style="text-align: left;">返回的x弧度的正弦值。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-tan.html">tan(x)</a></td>
<td style="text-align: left;">返回x弧度的正切值。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-degrees.html">degrees(x)</a></td>
<td style="text-align: left;">将弧度转换为角度,如degrees(math.pi/2) ，
返回90.0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://www.runoob.com/python/func-number-radians.html">radians(x)</a></td>
<td style="text-align: left;">将角度转换为弧度</td>
</tr>
</tbody>
</table>
<h3 id="数学常量">数学常量</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">常量</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">pi</td>
<td style="text-align: left;">数学常量 pi（圆周率，一般以π来表示）</td>
</tr>
<tr class="even">
<td style="text-align: left;">e</td>
<td style="text-align: left;">数学常量 e，e即自然常数（自然常数）。</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cmath</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmath.sqrt(-<span class="number">1</span>)</span><br><span class="line"><span class="number">1j</span></span><br></pre></td></tr></table></figure>
<p>注意这里没有使用 <code>from...import</code>
，否则会引起命名冲突，就无法再使用普通的 <code>sqrt()</code> 函数了</p>
<p><strong>Python 本身提供对复数的支持</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span> + <span class="number">3j</span>) * (<span class="number">9</span> + <span class="number">4j</span>)</span><br><span class="line">(-<span class="number">3</span> + <span class="number">31j</span>)</span><br></pre></td></tr></table></figure>
<p>虚数被看作实数部分为 0 的复数</p>
<h1 id="三数据结构">三、数据结构</h1>
<h2 id="序列概览">序列概览</h2>
<p>Python 的 6 种内建序列：列表、元组、字符串、Unicode 字符串、buffer
对象、xrange 对象</p>
<p><strong>List(列表)是 Python 中使用最频繁的数据类型。</strong></p>
<p>列表可以修改，元组不能，<strong>相当于只读列表</strong></p>
<p>列表用 <code>[]</code> 表示，元组用 <code>()</code> 表示</p>
<p>一般都可以使用列表，例外：字典的键不能修改，使用元组</p>
<p>容器：包含其他对象的任意对象</p>
<p>序列和映射（例如字典）是两类主要的容器，其他的类型还有集合（set）等</p>
<p><strong>字典(dictionary)是除列表以外最灵活的内置数据结构类型。</strong></p>
<h2 id="通用序列操作">通用序列操作</h2>
<p>索引（indexing）、分片（sliceing）、加（adding）、乘（multiplying）、成员资格、计算序列长度、找出最大或最小元素</p>
<p>负数下标表示倒数第几个</p>
<h3 id="索引">索引</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">months = [</span><br><span class="line">    <span class="string">&#x27;January&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;February&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;March&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;April&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;May&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;June&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;July&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;August&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;September&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;October&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;November&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;December&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">endings = [<span class="string">&#x27;st&#x27;</span>, <span class="string">&#x27;nd&#x27;</span>, <span class="string">&#x27;rd&#x27;</span>] + <span class="number">17</span> * [<span class="string">&#x27;th&#x27;</span>] \</span><br><span class="line">        + [<span class="string">&#x27;st&#x27;</span>, <span class="string">&#x27;nd&#x27;</span>, <span class="string">&#x27;rd&#x27;</span>] + <span class="number">7</span> * [<span class="string">&#x27;th&#x27;</span>] \</span><br><span class="line">        + [<span class="string">&#x27;st&#x27;</span>]</span><br><span class="line"></span><br><span class="line">year  = <span class="built_in">input</span>(<span class="string">&#x27;Year: &#x27;</span>)</span><br><span class="line">month = <span class="built_in">input</span>(<span class="string">&#x27;Month: &#x27;</span>)</span><br><span class="line">day   = <span class="built_in">input</span>(<span class="string">&#x27;Day: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">month_number = <span class="built_in">int</span>(month)</span><br><span class="line">day_number = <span class="built_in">int</span>(day)</span><br><span class="line"></span><br><span class="line">month_name = months[month_number - <span class="number">1</span>]</span><br><span class="line">ordinal = day + endings[day_number - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(month_name + <span class="string">&#x27; &#x27;</span> + ordinal + <span class="string">&#x27;. &#x27;</span> + year)</span><br><span class="line"></span><br><span class="line">-----下面是输入和输出-----</span><br><span class="line">Year: <span class="number">2023</span></span><br><span class="line">Month: <span class="number">1</span></span><br><span class="line">Day: <span class="number">15</span></span><br><span class="line">January 15th. <span class="number">2023</span></span><br></pre></td></tr></table></figure>
<h3 id="分片">分片</h3>
<p>可以通过 <code>string[from:to]</code>
截取字符串的子串（注意不包含尾下标），为空表示取到头或尾</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">numbers[<span class="number">0</span>:<span class="number">1</span>] <span class="comment"># 结果为[1]</span></span><br><span class="line"><span class="comment"># 第一个索引是需要提取的部分的第1个元素的编号，最后的索引是剩余部分的第1个元素的编号</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers[-<span class="number">3</span>:] <span class="comment"># 结果为[8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers[:<span class="number">3</span>] <span class="comment"># 结果为[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>复制整个序列只需将两个索引都置空</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers[:] <span class="comment"># 结果为[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<h3 id="步长">步长</h3>
<p>步长不能为0，但是可以为负数，表示从右向左提取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers[<span class="number">8</span>:<span class="number">3</span>:-<span class="number">1</span>] <span class="comment"># 结果为[9, 8, 7, 6, 5]</span></span><br></pre></td></tr></table></figure>
<p>一个经典的反置字符串的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="序列相加">序列相加</h3>
<p>类似于字符串，序列可以通过 + 号进行拼接</p>
<p><strong>注：只有相同类型的序列才能进行拼接</strong></p>
<h3 id="乘法">乘法</h3>
<p>只占用空间，没有实际含义的元素——None</p>
<p>可以用于列表的初始化</p>
<h3 id="成员资格">成员资格</h3>
<p><code>in</code> 运算符，返回布尔值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>permissions = <span class="string">&#x27;rw&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;w&#x27;</span> <span class="keyword">in</span> permissions</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串">字符串</h2>
<p>单引号、双引号和三个相同引号（单、双）均可以表示字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Let&#x27;s go&quot;</span></span><br><span class="line"><span class="string">&quot;Let&#x27;s go&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&quot;Hello, world!&quot; she said&#x27;</span></span><br><span class="line"><span class="string">&#x27;&quot;Hello, world!&quot; she said&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然这里也可将字符串中的单引号或双引号转义</span></span><br></pre></td></tr></table></figure>
<p><strong>字符串不可变！！！</strong>所以分片赋值是不合法的</p>
<h3 id="长字符串">长字符串</h3>
<p>用三个单引号或者双引号引用跨行字符串（不需要反斜线换行），常用于文档字符串，在特定地点充当注释</p>
<p>救你我于转义字符和特殊符号的水深火热之中，保持所见即所得的真实</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># 文件名：test.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>不同于 C、Java，Python
<strong>不支持单字符类型</strong>，单字符也是作为一个字符串使用</p>
<h3 id="下标">下标</h3>
<p>Python 字串列表有2种取值顺序:</p>
<ul>
<li>从左到右索引默认0开始的，最大范围是字符串长度少1</li>
<li>从右到左索引默认-1开始的，最大范围是字符串开头</li>
</ul>
<p><img src="..\images\python-string-slice.png" /></p>
<p>也即可以通过负下标表示倒数第几个</p>
<h3 id="转义字符">转义字符</h3>
<table>
<thead>
<tr class="header">
<th>转义字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>八进制数，y 代表 0~7 的字符，例如：\012 代表换行。</td>
</tr>
<tr class="even">
<td></td>
<td>十六进制数，以 开头，yy代表的字符，例如：0a代表换行</td>
</tr>
</tbody>
</table>
<p>使用长字符串和原始字符串（可以联合使用）减少绝大多数转义的使用</p>
<h3 id="字符串格式化">字符串格式化</h3>
<p>使用与 C 中 sprintf 函数一样的语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>( <span class="string">&quot;My name is %s and weight is %d kg!&quot;</span> % (<span class="string">&#x27;Zara&#x27;</span>, <span class="number">21</span>) )</span><br><span class="line"></span><br><span class="line"><span class="comment"># My name is Zara and weight is 21 kg!</span></span><br></pre></td></tr></table></figure>
<h4 id="字段宽度和精度">字段宽度和精度</h4>
<p><code>10.2f</code> 字段宽10，精度2</p>
<p>用 <code>*</code>
作为字段宽度或者精度（或二者都用），此时从元组参数中读出数值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%.*s&#x27;</span> % (<span class="number">5</span>, <span class="string">&#x27;Guido van Rossum&#x27;</span>)</span><br><span class="line"><span class="comment"># The result is &#x27;Guido&#x27;</span></span><br></pre></td></tr></table></figure>
<p>加上 <code>+</code> 表示无论正负都标识出符号</p>
<h4 id="船新的格式化方法-str.format">船新的格式化方法——
<strong><code>str.format()</code></strong></h4>
<p>通过 <code>&#123;&#125;</code> 和 <code>:</code> 来代替以前的
<code>%</code>，可以接受不限个参数，位置可以不按顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)    <span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;world hello world&#x27;</span></span><br></pre></td></tr></table></figure>
<p>设置参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;</span>.<span class="built_in">format</span>(name=<span class="string">&quot;菜鸟教程&quot;</span>, url=<span class="string">&quot;www.runoob.com&quot;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过字典设置参数</span></span><br><span class="line">site = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;菜鸟教程&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;www.runoob.com&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;</span>.<span class="built_in">format</span>(**site))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过列表索引设置参数</span></span><br><span class="line">my_list = [<span class="string">&#x27;菜鸟教程&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;&quot;</span>.<span class="built_in">format</span>(my_list))  <span class="comment"># &quot;0&quot; 是必须的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">网站名：菜鸟教程, 地址 www.runoob.com</span><br><span class="line">网站名：菜鸟教程, 地址 www.runoob.com</span><br><span class="line">网站名：菜鸟教程, 地址 www.runoob.com</span><br></pre></td></tr></table></figure>
<p>传入对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AssignValue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">my_value = AssignValue(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;value 为: &#123;0.value&#125;&#x27;</span>.<span class="built_in">format</span>(my_value))  <span class="comment"># &quot;0&quot; 是可选的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">value 为: <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>拼接字符串：+</p>
<h3
id="值转换为字符串的两种机制str-和-repr">值转换为字符串的两种机制：str
和 repr</h3>
<p>str 函数会把值转换为合理形式的字符串，repr 会创建一个字符串，以合法的
Python 表达式的形式来表示值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">repr</span>(<span class="string">&quot;Hello, world!&quot;</span>))</span><br><span class="line"><span class="string">&#x27;Hello, world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">repr</span>(<span class="number">10000L</span>))</span><br><span class="line"><span class="number">10000L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="string">&quot;Hello, world!&quot;</span>))</span><br><span class="line">Hello, world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="number">10000L</span>))</span><br><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure>
<h3 id="原始字符串">原始字符串</h3>
<p><strong>在书写正则表达式的时候特别有用</strong></p>
<p>所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。
原始字符串除在字符串的第一个引号前加上字母"r"（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</p>
<p>以 r 开头，不能以反斜线结尾</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;C:\nowhere&#x27;</span>)</span><br><span class="line">C:\nowhere</span><br></pre></td></tr></table></figure>
<h3 id="unicode-字符串">Unicode 字符串</h3>
<p>在 Python 3.0中所有字符串都是 Unicode 字符串</p>
<h3 id="find-方法">find 方法</h3>
<p>返回最左端索引，否则返回 -1</p>
<p>类似于人工实现的查找方法，注意与 strstr 的区别和联系</p>
<p>可以只提供起始点也可以提供起终点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>subject = <span class="string">&#x27;$$$ Get rich now!!! $$$&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>subject.find(<span class="string">&#x27;$$$&#x27;</span>, <span class="number">1</span>) <span class="comment"># 提供起始点</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>subject.find(<span class="string">&#x27;$$$&#x27;</span>, <span class="number">0</span>, <span class="number">16</span>) <span class="comment"># 提供起终点</span></span><br></pre></td></tr></table></figure>
<h3 id="joinsplit-方法">join、split 方法</h3>
<p>互为逆方法，<code>join</code>
用于在队列中添加元素，<code>split</code> 通过指定分隔符分割字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plus = <span class="string">&#x27;+&#x27;</span></span><br><span class="line">seq = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(plus.join(seq))</span><br><span class="line"></span><br><span class="line"><span class="comment"># The result is one+two+three</span></span><br></pre></td></tr></table></figure>
<p><code>join</code> 需要的队列元素都是字符串</p>
<p><code>split</code> 缺省分隔符是空格</p>
<h3 id="大小写方法">大小写方法</h3>
<p>lower、islower、upper、isupper、title、istitle、capwords、capitalize、swapcase</p>
<h3 id="replace">replace</h3>
<h3 id="translate">translate</h3>
<p>可以替换字符串中的某些部分，可以用于类似语言转换的功能，因此得名</p>
<h2 id="列表listpython的苦力">列表(List)——Python的“苦力”</h2>
<p>数据项不需要具有相同的类型，原因也许是 <code>Reference</code> ？</p>
<h3 id="用-list-由字符串创建列表">用 <code>list</code>
由字符串创建列表</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="元素赋值">元素赋值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">x[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为[1, 2, 1]</span></span><br></pre></td></tr></table></figure>
<p>不能为位置不存在的元素赋值，和C是一样的</p>
<h3 id="删除元素">删除元素</h3>
<p><code>del</code></p>
<h3 id="分片赋值">分片赋值</h3>
<p>在这里分片愈发显示出它的强大特性，甚至可以使用与原序列不等长的序列替换分片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">list</span>(<span class="string">&#x27;Perl&#x27;</span>)</span><br><span class="line">name[<span class="number">1</span>:] = <span class="built_in">list</span>(<span class="string">&#x27;ython&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为[&#x27;P&#x27;, &#x27;y&#x27;, &#x27;t&#x27;, &#x27;h&#x27;, &#x27;o&#x27;, &#x27;n&#x27;]</span></span><br></pre></td></tr></table></figure>
<h3 id="列表方法">列表方法</h3>
<p><code>append</code> ：追加对象</p>
<p><code>count</code> ：统计某个元素出现的次数</p>
<p><code>extend</code> ：用新序列扩展原有的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">a.extend(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The result is [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p><code>index</code></p>
<p><code>insert</code> ：<code>insert(subscript, content)</code></p>
<p><code>pop</code>
：移除一个元素并且返回该元素的值，参数缺省则为最后一个</p>
<blockquote>
<p>这里可以实现栈，至于队列的更好实现方式是，使用 collection 模块中的
deque 对象</p>
</blockquote>
<p><code>remove</code> ：移除第一个匹配项，改变列表但是不返回值</p>
<p><code>reverse</code> ：反转列表，改变列表但是不返回值</p>
<p><code>sort</code></p>
<p>高级排序：<strong><code>sort</code>
方法默认升序排序</strong>，如果想按自定义方法排序，那么可以自定义
<code>compare(x, y)</code> 函数，此函数在 x &lt; y 时返回负数，x &gt; y
时返回正数，相等时返回 0</p>
<p>还有另两个可选的参数——key 和
reverse（通过名字来指定的关键字参数）</p>
<blockquote>
<p>结合 lambda 表达式</p>
</blockquote>
<h2 id="元组tuple不可变序列">元组(Tuple)——不可变序列</h2>
<h3 id="无关闭分隔符">无关闭分隔符</h3>
<p>任意无符号的对象，以逗号隔开，默认为元组</p>
<p>通过括号括起来的，空元组可以用没有内容的两个圆括号表示</p>
<p>一个值的元组：必须加括号，如 <code>(42, )</code>
，很奇怪的语法，不是吗</p>
<p>tuple 函数：以一个序列作为参数并把它转化为元组</p>
<h3 id="基本元组操作">基本元组操作</h3>
<p>仿照其他序列即可，注意元组的元素不能增添和删除，可以通过
<code>del</code>
删除整个元组。也可以通过如下的操作实现两个元组合并成新的元组（肯定不是原地操作）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tup1 = (12, 34.56)</span><br><span class="line">tup2 = (&#x27;abc&#x27;, &#x27;xyz&#x27;)</span><br><span class="line">tup3 = tup1 + tup2</span><br></pre></td></tr></table></figure>
<h3 id="元组的用武之地">元组的用武之地</h3>
<p>在映射（和集合的成员）中当作键使用</p>
<h2
id="字典dictionary当索引不好用时">字典(Dictionary)：当索引不好用时</h2>
<p>字典是 Python 中唯一内建的映射类型</p>
<p>值没有特殊的顺序，可以存储任意类型对象；键可以是数字、字符串甚至是元组，但是必须是不可变的</p>
<h3 id="建立字典">建立字典</h3>
<p>可以利用 dict 函数，通过其他映射或者键值对建立字典</p>
<blockquote>
<p>因为 <code>dict</code> 是 Python 关键字和内置函数，不要用
<code>dict</code> 命名字典</p>
</blockquote>
<p>和 <code>list、tuple、str</code> 一样，<code>dict</code>
也是类型而非真正的函数</p>
<h3 id="字典和列表的重要区别">字典和列表的重要区别</h3>
<ul>
<li>键
<ul>
<li>不能重复</li>
<li>不可变，不能用列表做键</li>
</ul></li>
<li>自动添加
<ul>
<li>列表不能将值关联到不存在的索引上</li>
<li>即使这个键原来不存在，字典也可以自动添加键值对</li>
</ul></li>
<li>成员资格
<ul>
<li>表达式 <code>k in d（字典）</code> 查找的是<strong>键</strong></li>
<li>表达式 <code>v in l（列表）</code> 查找的是<strong>值</strong></li>
</ul></li>
</ul>
<blockquote>
<p>字典中的检查方式更高效，而且事实上两种方式是等效的</p>
<p>如果字典含有指定的键，那么相应的值也是唾手可得</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>phonebook</span><br><span class="line">&#123;<span class="string">&#x27;Beth&#x27;</span>: <span class="string">&#x27;9102&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>: <span class="string">&#x27;2341&#x27;</span>, <span class="string">&#x27;Cecil&#x27;</span>: <span class="string">&#x27;3258&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Cecil &#x27;s number is %(Cecil)s.&quot;</span> % phonebook</span><br></pre></td></tr></table></figure>
<h3 id="字典方法">字典方法</h3>
<h4 id="clear">clear</h4>
<p>清除字典中所有的项</p>
<p>原地方法，无返回值（返回 None）</p>
<h3 id="copy">copy</h3>
<p>shallow copy</p>
<h4 id="deepcopy">deepcopy</h4>
<p><code>from copy import deepcopy</code></p>
<h4 id="fromkeys">fromkeys</h4>
<p>根据给定键和默认值建立字典，默认值缺省为 None</p>
<h4 id="get">get</h4>
<p>访问存在的项时返回键对应的值，访问不存在的项时返回 None</p>
<h4 id="items">items</h4>
<p>items 方法将所有的字典项返回迭代器</p>
<p>列表项为（键，值），返回时<strong>无顺序</strong></p>
<h4 id="keys">keys</h4>
<p>类似同上，只不过这次是将所有的键返回</p>
<h4 id="values">values</h4>
<p>类似同上，只不过这次是将所有的值返回</p>
<h4 id="pop">pop</h4>
<p>获得对应指定键的<strong>值</strong>（主语是值），然后将键值对从字典中移除</p>
<h4 id="popitem">popitem</h4>
<p>类似于 <code>list.pop</code>
，不同的是后者会弹出列表的最后一个元素，而 popitem
会随机弹出元素（很容易理解，字典是无序的）</p>
<p><code>list.pop</code></p>
<p><strong>不用首先获取键列表，用于逐项处理并移除</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;http://www.python.org&#x27;</span>, <span class="string">&#x27;spam&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;Python Web Site&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.popitem</span><br><span class="line">(<span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;http://www.python.org&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;spam&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;Python Web Site&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>但是字典中没有类似 <code>list.append</code> 的方法</p>
<h4 id="setdefault">setdefault</h4>
<p>类似于 <code>list.get</code>
，获得与给定键相关联的值，能够在不含给定键的情况下设定相应的键值</p>
<p><del>懒了，贴个截图</del></p>
<h4 id="update">update</h4>
<p>利用一个字典项更新另一个字典，这个字典项会被添加到字典中，如果键相同就会覆盖</p>
<p>可以用调用 <code>dict</code>
的方法调用（和映射、拥有（键值）对的队列（或者其他可迭代的对象）以及<strong>关键字参数</strong>一起调用）</p>
<h4 id="values-和-itervalues">values 和 itervalues</h4>
<p>类似同上，很自然地，返回值的列表中可以包含相同的元素</p>
<h1 id="四条件循环和其他语句">四、条件、循环和其他语句</h1>
<h2 id="import">import</h2>
<p>两个模块都有 open 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module1</span><br><span class="line"><span class="keyword">import</span> module2</span><br><span class="line">module1.<span class="built_in">open</span>(...)</span><br><span class="line">module2.<span class="built_in">open</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># or try like this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> <span class="built_in">open</span> <span class="keyword">as</span> open1</span><br><span class="line"><span class="keyword">from</span> module2 <span class="keyword">import</span> <span class="built_in">open</span> <span class="keyword">as</span> open2</span><br></pre></td></tr></table></figure>
<p>分层结构后面会提到</p>
<h2 id="赋值语句">赋值语句</h2>
<h3 id="序列解包">序列解包</h3>
<p>将多个值的序列解开放到变量的序列中</p>
<p>在返回元组或者其他序列可迭代对象时尤其有用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>scoundrel = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Robin&#x27;</span>, <span class="string">&#x27;girlfriend&#x27;</span>: <span class="string">&#x27;Marion&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>key, value = scoundrel.popitem()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>key</span><br><span class="line"><span class="string">&#x27;girlfriend&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value</span><br><span class="line"><span class="string">&#x27;Marion&#x27;</span></span><br></pre></td></tr></table></figure>
<p>所解包序列的元素数量要和左边的变量个数一致或是采用 <code>*</code>
运算符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest* = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rest</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>将星号运算符放到左边会得到一个列表</p>
<h3 id="链式赋值">链式赋值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = y = function()</span><br><span class="line"></span><br><span class="line"><span class="comment"># is equivalent to the below statements</span></span><br><span class="line"></span><br><span class="line">x = function()</span><br><span class="line">y = function()</span><br></pre></td></tr></table></figure>
<h3 id="增量赋值">增量赋值</h3>
<p>对于适用这些二元运算符的数据类型</p>
<h2 id="语句块">语句块</h2>
<p>用冒号开头，用相同缩进距离表示语句块结束</p>
<h2 id="条件和条件语句">条件和条件语句</h2>
<p><strong>Python 中所有的值都可以解释为真值</strong></p>
<p>Python 中没有 <code>switch</code>（Nintendo 不打钱！）只能用
<code>elif</code> 实现</p>
<p>标准值 False、None、所有类型的数字
0（包括浮点型、长整型和其他类型）、空序列（比如空字符串、元组和列表）以及空的字典都为假，其他一切都被解释为真</p>
<p>但是 <code>True</code> 只取值为 1！！！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> + <span class="literal">False</span> + <span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The result is 43</span></span><br></pre></td></tr></table></figure>
<p>bool 函数可以用来转换布尔量，不过因为 Python
可以把所有的值都看作布尔值，所以这样也没太大必要</p>
<p>注：尽管 [] ""
都是假值，但是它们并不相等（<code>bool([]) == bool("") == False</code>
<code>[] != ""</code>）</p>
<p>equal to：regard as</p>
<p>equivalent</p>
<p><strong>Python 中不能比较不兼容对象</strong></p>
<p><strong>Python 中比较运算和赋值运算都可以连接</strong>
<code>0 &lt; age &lt; 100</code></p>
<p>同一性运算符：<code>x is y</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">z = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(x == y)</span><br><span class="line"><span class="built_in">print</span>(x == z)</span><br><span class="line"><span class="built_in">print</span>(x <span class="keyword">is</span> y)</span><br><span class="line"><span class="built_in">print</span>(x <span class="keyword">is</span> z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The result is as below:</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>避免将 is
运算符用于比较类似数值和字符串这类的不可变值，这样的结果是不可预测的</p>
<p>字符串和序列比较：按照字典序进行比较（因 locale 不同而有所区别）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;alpha&quot;</span> &lt; <span class="string">&quot;beta&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The result is True</span></span><br></pre></td></tr></table></figure>
<p>Python 中使用 <code>and</code> 和 <code>or</code> 表示C语言中的
<code>&amp;</code> 和 <code>|</code></p>
<p>布尔表达式具有<strong>短路求值</strong>特性</p>
<h2 id="断言">断言</h2>
<p>在错误出现时让程序崩溃</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = -<span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">0</span> &lt; age &lt; <span class="number">100</span>, <span class="string">&#x27;The age must be realistic&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C:\Users\Lee\AppData\Local\Microsoft\WindowsApps\python3<span class="number">.9</span>.exe D:/Programing/Python/Test </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:\Programing\Python\Test&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt; age &lt; <span class="number">100</span>, <span class="string">&#x27;The age must be realistic&#x27;</span></span><br><span class="line">AssertionError: The age must be realistic</span><br></pre></td></tr></table></figure>
<p>条件后添加字符串用于解释断言</p>
<h2 id="循环">循环</h2>
<h3 id="while-else">while-else</h3>
<p>while … else 在循环条件为 false 时执行 else 语句块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">   <span class="built_in">print</span> count, <span class="string">&quot; is  less than 5&quot;</span></span><br><span class="line">   count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> count, <span class="string">&quot; is not less than 5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">is</span> less than <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">is</span> less than <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> less than <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> less than <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">is</span> less than <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> <span class="keyword">not</span> less than <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="for-else">for-else</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>,<span class="number">20</span>):  <span class="comment"># 迭代 10 到 20 之间的数字</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,num): <span class="comment"># 根据因子迭代</span></span><br><span class="line">      <span class="keyword">if</span> num%i == <span class="number">0</span>:      <span class="comment"># 确定第一个因子</span></span><br><span class="line">         j=num/i          <span class="comment"># 计算第二个因子</span></span><br><span class="line">         <span class="built_in">print</span> (<span class="string">&#x27;%d 等于 %d * %d&#x27;</span> % (num,i,j))</span><br><span class="line">         <span class="keyword">break</span>            <span class="comment"># 跳出当前循环</span></span><br><span class="line">   <span class="keyword">else</span>:                  <span class="comment"># 循环的 else 部分</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;%d 是一个质数&#x27;</span> % num)</span><br><span class="line">        </span><br><span class="line"><span class="number">10</span> 等于 <span class="number">2</span> * <span class="number">5</span></span><br><span class="line"><span class="number">11</span> 是一个质数</span><br><span class="line"><span class="number">12</span> 等于 <span class="number">2</span> * <span class="number">6</span></span><br><span class="line"><span class="number">13</span> 是一个质数</span><br><span class="line"><span class="number">14</span> 等于 <span class="number">2</span> * <span class="number">7</span></span><br><span class="line"><span class="number">15</span> 等于 <span class="number">3</span> * <span class="number">5</span></span><br><span class="line"><span class="number">16</span> 等于 <span class="number">2</span> * <span class="number">8</span></span><br><span class="line"><span class="number">17</span> 是一个质数</span><br><span class="line"><span class="number">18</span> 等于 <span class="number">2</span> * <span class="number">9</span></span><br><span class="line"><span class="number">19</span> 是一个质数</span><br></pre></td></tr></table></figure>
<p>循环语句和普通的没有区别，else
中的语句会在循环正常执行完（即循环语句不是通过 break
跳出而中断的）的情况下执行</p>
<h3 id="范围函数-range">范围函数 range</h3>
<p>内建函数，包含下限，不包含上限</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">1</span>, <span class="number">101</span>)</span><br><span class="line">	<span class="built_in">print</span>(number)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Print numbers from 1 to 100</span></span><br></pre></td></tr></table></figure>
<p>在 Python3 中，xrange 函数甚至不再存在</p>
<h3 id="循环遍历字典元素">循环遍历字典元素</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;corresponds to&#x27;</span>, value)</span><br></pre></td></tr></table></figure>
<p>当然，如果顺序很重要，可以将键值保存在单独的列表中，类似这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> sortedlist:</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;corresponds to&#x27;</span>, d[key]) <span class="comment"># d is the dict</span></span><br></pre></td></tr></table></figure>
<h3 id="并行迭代">并行迭代</h3>
<p>zip 函数可以把两个序列压缩在一起，返回一个元组的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;anne&#x27;</span>, <span class="string">&#x27;beth&#x27;</span>, <span class="string">&#x27;george&#x27;</span>, <span class="string">&#x27;damon&#x27;</span>]</span><br><span class="line">ages = [<span class="number">12</span>, <span class="number">45</span>, <span class="number">32</span>, <span class="number">102</span>]</span><br><span class="line"><span class="keyword">for</span> name, age <span class="keyword">in</span> <span class="built_in">zip</span>(names, ages):</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;is&#x27;</span>, age, <span class="string">&#x27;years old&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">anne <span class="keyword">is</span> <span class="number">12</span> years old</span><br><span class="line">beth <span class="keyword">is</span> <span class="number">45</span> years old</span><br><span class="line">george <span class="keyword">is</span> <span class="number">32</span> years old</span><br><span class="line">damon <span class="keyword">is</span> <span class="number">102</span> years old</span><br></pre></td></tr></table></figure>
<p>对于不等长的序列，如你所愿，会在最短的序列结束时停止</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;anne&#x27;</span>, <span class="string">&#x27;beth&#x27;</span>, <span class="string">&#x27;george&#x27;</span>, <span class="string">&#x27;damon&#x27;</span>]</span><br><span class="line">ages = [<span class="number">12</span>, <span class="number">45</span>, <span class="number">32</span>]</span><br><span class="line"><span class="keyword">for</span> name, age <span class="keyword">in</span> <span class="built_in">zip</span>(names, ages):</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;is&#x27;</span>, age, <span class="string">&#x27;years old&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">anne <span class="keyword">is</span> <span class="number">12</span> years old</span><br><span class="line">beth <span class="keyword">is</span> <span class="number">45</span> years old</span><br><span class="line">george <span class="keyword">is</span> <span class="number">32</span> years old</span><br></pre></td></tr></table></figure>
<h3 id="编号迭代">编号迭代</h3>
<p>希望同时迭代序列中的对象并获取当前对象的索引时可以使用内建的
<code>enumerate</code> 函数，在提供索引的地方提供迭代索引-值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index, string <span class="keyword">in</span> <span class="built_in">enumerate</span>(strings):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">in</span> strings:</span><br><span class="line">        strings[index] = <span class="string">&#x27;[censored]&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="翻转和排序迭代">翻转和排序迭代</h3>
<p>reversed、sorted 和 reverse、sort
使用同样的参数，作用于任何序列或可迭代对象上（很好理解，不能迭代的怎么翻转捏）</p>
<p>不原地修改对象，而是返回翻转或排序后的版本</p>
<p>其返回值不用过多关注，可以放心地在 for 循环和 join
方法中使用，但是不能直接使用索引、分片、list 方法（正确的方法：使用 list
类型转换返回的对象）</p>
<h2 id="列表推导式轻量级循环">列表推导式——轻量级循环</h2>
<p>利用其它列表创建新列表（类似集合推导式）</p>
<p>其工作方式类似于 for 循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">9</span>, <span class="number">36</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<h2 id="del">del</h2>
<p>只能删除引用，不能删除值，Python 解释器负责垃圾回收</p>
<h2 id="exec-和-eval">exec 和 eval</h2>
<p>动态地创造 Python 代码，作为语句执行或作为表达式计算</p>
<p>并不常用，有的时候比较顺手<del>，太麻烦了，我回头就看</del></p>
<h1 id="五充电时刻">五、充电时刻</h1>
<p>库和模块的相关知识</p>
<blockquote>
<p><em>充电时刻（batteries included）这个短语最早由 Frank Stajano
创造，用于描述 Python 丰富的标准库</em></p>
</blockquote>
<h2 id="模块-1">模块</h2>
<p>模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python
对象定义和Python语句，帮助程序员有逻辑地组织 Python 代码段。</p>
<p>模块能定义函数，类和变量，模块里也能包含可执行的代码。</p>
<p><strong>例子</strong></p>
<p>下例是个简单的模块 support.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_func</span>(<span class="params">par</span>): </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Hello : &quot;</span>, par</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h2 id="import-1">import</h2>
<p>需要使用 <code>import</code> 语句导入模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">math.floor(<span class="number">32.9</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line">sqrt(<span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<p>这样就不用写模块的名字来调用函数了</p>
<blockquote>
<p>在 python 中可以使用变量来引用函数（或者 Python
中大多数的对象），比如，通过 <code>foo = math.sqrt</code> 进行赋值，则
<code>foo(4)</code> 的结果为 2.0</p>
</blockquote>
<p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。</p>
<p>如想要导入模块 support.py，需要把命令放在脚本的顶端：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> support</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用模块里包含的函数</span></span><br><span class="line">support.print_func(<span class="string">&quot;StrivingLee&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello : StrivingLee</span><br></pre></td></tr></table></figure>
<p>一个模块不管执行多少次import，只会被导入一次</p>
<blockquote>
<p>一个例子：用于统计用量和用于计费的两个模块需要彼此通信才能知道对方的情况以精准计费（想想水费电费之类），这样无限相互调用就会陷入无限递归的死循环</p>
</blockquote>
<h2 id="fromimport">from…import</h2>
<p>from 语句从模块中导入一个指定的部分到当前命名空间中。语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from modname import name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure>
<p>例如，要导入模块 fib 的 fibonacci 函数，使用如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from fib import fibonacci</span><br></pre></td></tr></table></figure>
<p>这个声明不会把整个 fib 模块导入到当前的命名空间中，它只会将 fib 里的
fibonacci 单个引入到执行这个声明的模块的全局符号表。</p>
<h2 id="fromimport-1">from…import*</h2>
<p>把一个模块的所有内容<strong>全都导入</strong>到当前的命名空间也是可行的，只需使用如下声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from modname import *</span><br></pre></td></tr></table></figure>
<p>这种声明虽然方便，但<strong>不该被滥用</strong>。（否则可能引发命名冲突之类的问题）</p>
<h2 id="搜索路径">搜索路径</h2>
<p>当你导入一个模块，Python 解析器对模块位置的搜索顺序是：</p>
<ul>
<li>1、当前目录</li>
<li>2、在 shell 变量 PYTHONPATH 下的每个目录。</li>
<li>3、默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。</li>
</ul>
<p>模块搜索路径存储在 system 模块的 sys.path
变量中。变量里包含当前目录，PYTHONPATH 和由安装过程决定的默认目录。</p>
<h2 id="pythonpath-变量">PYTHONPATH 变量</h2>
<p>作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH
的语法和 shell 变量 PATH 的一样。</p>
<p>在 Windows 系统，典型的 PYTHONPATH 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set PYTHONPATH=c:\python310\lib;</span><br></pre></td></tr></table></figure>
<p>在 UNIX 系统，典型的 PYTHONPATH 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set PYTHONPATH=/usr/local/lib/python</span><br></pre></td></tr></table></figure>
<h2 id="命名空间和作用域">命名空间和作用域</h2>
<p>变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称（键）和它们各自相应的对象（值）的<strong>字典</strong>。</p>
<p>一个 Python
表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则<strong>局部变量会覆盖全局变量</strong>。</p>
<p>每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。</p>
<p>Python
会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。因此，如果要给函数内的全局变量赋值，必须使用
global 语句。<code>global VarName</code> 表示 <code>VarName</code>
是一个全局变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Money = 2000</span><br><span class="line">def AddMoney():</span><br><span class="line">   # 想改正代码就取消以下注释:</span><br><span class="line">   # global Money</span><br><span class="line">   Money = Money + 1</span><br><span class="line"> </span><br><span class="line">print Money</span><br><span class="line">AddMoney()</span><br><span class="line">print Money</span><br></pre></td></tr></table></figure>
<p>在全局命名空间里定义变量 Money。再在函数内给变量 Money 赋值，Python
会假定 Money 是局部变量。然而，我们并没有在访问前声明一个局部变量
Money，结果会出现 UnboundLocalError。将 Money 声明为 <code>global</code>
就能解决这个问题。</p>
<h2 id="dir">dir()</h2>
<p>dir()
函数返回一个由模块中定义的名字（模块里定义的所有模块，变量和函数）组成的有序字符串列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import math</span><br><span class="line">content = dir(math)</span><br><span class="line">print content;</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__name__&#x27;, &#x27;acos&#x27;, &#x27;asin&#x27;, &#x27;atan&#x27;, </span><br><span class="line">&#x27;atan2&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;degrees&#x27;, &#x27;e&#x27;, &#x27;exp&#x27;, </span><br><span class="line">&#x27;fabs&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;frexp&#x27;, &#x27;hypot&#x27;, &#x27;ldexp&#x27;, &#x27;log&#x27;,</span><br><span class="line">&#x27;log10&#x27;, &#x27;modf&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;radians&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, </span><br><span class="line">&#x27;sqrt&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]</span><br></pre></td></tr></table></figure>
<p>在这里，特殊字符串变量 <code>__name__</code>
指向模块的名字，<code>__file__</code> 指向该模块的导入文件名。</p>
<h2 id="globals-和-locals">globals() 和 locals()</h2>
<p>根据调用地方的不同，globals() 和 locals()
函数可被用来返回全局和局部命名空间里的名字。</p>
<p>如果在函数内部调用 locals()，返回的是所有能在该函数里访问的命名。</p>
<p>如果在函数内部调用
globals()，返回的是所有在该函数里能访问的全局名字。</p>
<p>两个函数的返回类型都是字典，可用 keys() 函数摘取名字。</p>
<h2 id="reload-函数">reload() 函数</h2>
<p>需要多次执行模块里顶层部分的代码时可以调用 reload()
函数，它会重新导入之前导入过的模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reload(module_name)</span><br></pre></td></tr></table></figure>
<p>在这里，module_name要直接放<strong>模块的名字</strong>，而不是一个字符串形式。比如想重载
hello 模块，如下：</p>
<blockquote>
<p>这里书上和菜鸟冲突了，书上说 Python3 取消了 reload()</p>
</blockquote>
<h2 id="包">包</h2>
<p>包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的
Python 的应用环境。</p>
<p>简单来说，包就是文件夹，但该文件夹下必须存在
<strong><code>__init__.py</code></strong>
文件（内容可以为空）。<strong><code>__init__.py</code></strong>
用于标识当前文件夹是一个包。</p>
<p>考虑一个在 <strong>package_runoob</strong> 目录下的
**runoob1.py、runoob2.py、__init__.py** 文件，test.py
为测试调用包的代码，目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.py</span><br><span class="line">package_runoob</span><br><span class="line">|-- __init__.py</span><br><span class="line">|-- runoob1.py</span><br><span class="line">|-- runoob2.py</span><br></pre></td></tr></table></figure>
<p>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># package_runoob/runoob1.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">runoob1</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;I&#x27;m in runoob1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># package_runoob/runoob2.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">runoob2</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;I&#x27;m in runoob2&quot;</span></span><br></pre></td></tr></table></figure>
<p>现在，在 <strong>package_runoob</strong> 目录下创建
<strong><code>__init__.py</code></strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># package_runoob/__init__.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;作为主程序运行&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;package_runoob 初始化&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后我们在 <strong>package_runoob</strong>
<strong>同级目录</strong>下创建 test.py 来调用
<strong>package_runoob</strong> 包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="comment"># 导入 Phone 包</span></span><br><span class="line"><span class="keyword">from</span> package_runoob.runoob1 <span class="keyword">import</span> runoob1</span><br><span class="line"><span class="keyword">from</span> package_runoob.runoob2 <span class="keyword">import</span> runoob2</span><br><span class="line">runoob1()</span><br><span class="line">runoob2()</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package_runoob 初始化</span><br><span class="line">I&#x27;m in runoob1</span><br><span class="line">I&#x27;m in runoob2</span><br></pre></td></tr></table></figure>
<p>如上，为了举例，我们只在每个文件里放置了一个函数，但其实你可以放置许多函数。你也可以在这些文件里定义Python的类，然后为这些类建一个包。</p>
<h1 id="六文件io-file方法">六、文件I/O &amp; File方法</h1>
<h2 id="io">I/O</h2>
<h3 id="打印到屏幕">打印到屏幕</h3>
<p>print()
函数把你传递的表达式<strong>转换成一个字符串表达式</strong>，并将结果写到标准输出</p>
<h3 id="读取键盘输入">读取键盘输入</h3>
<h4 id="input函数">input函数</h4>
<p>input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input
可以接收一个Python表达式作为输入，并将运算结果返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;你输入的内容是: &quot;</span>, <span class="built_in">str</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">请输入：[x*<span class="number">5</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>)]</span><br><span class="line">你输入的内容是:  [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br></pre></td></tr></table></figure>
<h1 id="七异常处理">七、异常处理</h1>
<p>异常对象未被处理（或捕获）时，程序终止并将显示一条错误信息（traceback）</p>
<p>异常事实上是某个类的实例，你能以各种方式引发和捕获这些实例，从而逮住错误并采取措施而非放任程序崩溃</p>
<p>python提供了两个非常重要的功能来处理python程序在运行中出现的异常和错误，便于调试python程序。</p>
<ul>
<li>异常处理：try/except</li>
<li>断言(Assertions)</li>
<li></li>
</ul>
<h2 id="异常处理">异常处理</h2>
<p>捕捉异常可以使用 <code>try/except</code> 语句。</p>
<p><code>try/except</code> 语句用来检测 <code>try</code>
语句块中的错误，从而让 <code>except</code>
语句捕获异常信息并处理。如果不想在异常发生时就结束程序，只需在
<code>try</code> 里捕获它</p>
<h3 id="基本语法">基本语法</h3>
<p>以下为简单的 <code>try....except...else</code> 的语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#运行别的代码</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;：</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果在try部分引发了&#x27;name&#x27;异常</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;，&lt;数据&gt;:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果引发了&#x27;name&#x27;异常，获得附加的数据</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果没有异常发生</span></span><br></pre></td></tr></table></figure>
<p>try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，当异常出现时回到这里，先执行try子句，接下来：</p>
<ul>
<li>如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。</li>
<li>如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印默认的出错信息）。</li>
<li>如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。</li>
</ul>
<blockquote>
<p>这里和 Java
的异常处理是基本一致的，认真领会一个剩下的也就简单许多</p>
<p>可以参见：<a
href="https://strivinglee.github.io/2023/01/13/OO%20Pre%20Review/">OO
Pre Review | StrivingLee's Blog</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    fh = <span class="built_in">open</span>(<span class="string">&quot;testfile&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    fh.write(<span class="string">&quot;这是一个测试文件，用于测试异常!!&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Error: 没有找到文件或读取文件失败&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;内容写入文件成功&quot;</span></span><br><span class="line">    fh.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python test.py </span><br><span class="line">内容写入文件成功</span><br><span class="line">$ cat testfile       # 查看写入的内容</span><br><span class="line">这是一个测试文件，用于测试异常!!</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chmod -w testfile <span class="comment"># 取消文件写入权限便于测试</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    fh = <span class="built_in">open</span>(<span class="string">&quot;testfile&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    fh.write(<span class="string">&quot;这是一个测试文件，用于测试异常!!&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Error: 没有找到文件或读取文件失败&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;内容写入文件成功&quot;</span></span><br><span class="line">    fh.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python test.py </span><br><span class="line">Error: 没有找到文件或读取文件失败</span><br></pre></td></tr></table></figure>
<h3 id="不注明异常类型">不注明异常类型</h3>
<p>我们当然可以不带任何异常类型使用except，但是这并不太聪明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 正常的操作</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># 发生异常，执行这块代码</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 如果没有异常执行这块代码</span></span><br></pre></td></tr></table></figure>
<p>这段程序捕获所有的异常，不能识别出具体的异常信息。而我们使用异常处理的目的不就是处理异常嘛，既然已经做了这个工作，何不把它做得更细些，识别出具体的异常呢？<del>hhh
貌似解决了我在 OO Pre Review 里的一个异想天开</del></p>
<h3 id="带多种异常类型">带多种异常类型</h3>
<p>可以使用相同的except语句处理多个异常信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 正常的操作</span></span><br><span class="line"><span class="keyword">except</span>(Exception1[, Exception2[,...ExceptionN]]):</span><br><span class="line">    <span class="comment"># 发生以上多个异常中的一个，执行这块代码</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 如果没有异常执行这块代码</span></span><br></pre></td></tr></table></figure>
<h3 id="try-finally语句">try-finally语句</h3>
<p>无论是否发生异常都将执行 <code>finally</code> 的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">&lt;语句&gt;</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">&lt;语句&gt;    <span class="comment">#退出try时总会执行</span></span><br><span class="line"><span class="keyword">raise</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    fh = <span class="built_in">open</span>(<span class="string">&quot;testfile&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    fh.write(<span class="string">&quot;这是一个测试文件，用于测试异常!!&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: 没有找到文件或读取文件失败&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    fh = <span class="built_in">open</span>(<span class="string">&quot;testfile&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fh.write(<span class="string">&quot;这是一个测试文件，用于测试异常!!&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;关闭文件&quot;</span>)</span><br><span class="line">        fh.close()</span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: 没有找到文件或读取文件失败&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># one is equivalent to the other</span></span><br></pre></td></tr></table></figure>
<p>当在try块中抛出一个异常，立即执行finally块代码。finally块中的所有语句执行后，异常被再次触发，并执行except块代码。</p>
<p>参数的内容不同于异常。（？这句话没太读懂，如果聪明的读者看懂了麻烦转告一下愚钝的笔者）</p>
<h3 id="异常的参数">异常的参数</h3>
<p>异常可以携带参数作为输出的异常信息参数，并可被except语句捕获</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 正常的操作</span></span><br><span class="line"><span class="keyword">except</span> ExceptionType, Argument:</span><br><span class="line">    <span class="comment"># 可以输出 Argument 的值...</span></span><br></pre></td></tr></table></figure>
<p>变量接收的异常值通常包含在异常的语句中。在元组的表单中变量可以接收一个或者多个值。（？）</p>
<p>元组通常包含错误字符串，错误数字，错误位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">temp_convert</span>(<span class="params">var</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(var)</span><br><span class="line">    <span class="keyword">except</span> ValueError, Argument:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;参数没有包含数字\n&quot;</span>, Argument</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">temp_convert(<span class="string">&quot;xyz&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python test.py </span><br><span class="line">参数没有包含数字</span><br><span class="line">invalid literal for int() with base 10: &#x27;xyz&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="raise触发异常">raise触发异常</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> [Exception[, args[, traceback]]]</span><br></pre></td></tr></table></figure>
<p>Exception 是标准异常中任一种异常类型，args 是自已提供的异常参数。</p>
<p>最后一个参数跟踪异常对象是可选的，但很少使用</p>
<p>一个异常可以是一个字符串，类或对象。
Python的内核提供的异常大多数都是实例化的类，这是一个类的实例的参数。</p>
<p>定义一个异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionName</span>(<span class="params">level</span>):</span><br><span class="line">    <span class="keyword">if</span> level &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Invalid level!&quot;</span>, level)</span><br><span class="line">        <span class="comment"># 触发异常后，后面的代码就不会再执行</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>为了能够捕获异常，<code>except</code>
语句必须有用相同的异常来抛出类对象或者字符串（？）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    正常逻辑</span><br><span class="line"><span class="keyword">except</span> Exception, err:</span><br><span class="line">    触发自定义异常    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    其余代码</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mye</span>(<span class="params">level</span>):</span><br><span class="line">    <span class="keyword">if</span> level &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception,<span class="string">&quot;Invalid level!&quot;</span></span><br><span class="line">        <span class="comment"># 触发异常后，后面的代码就不会再执行</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    mye(<span class="number">0</span>)            <span class="comment"># 触发异常</span></span><br><span class="line"><span class="keyword">except</span> Exception, err:</span><br><span class="line">    <span class="built_in">print</span> <span class="number">1</span>,err</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python test.py </span><br><span class="line">1 Invalid level!</span><br></pre></td></tr></table></figure>
<h3 id="用户自定义异常">用户自定义异常</h3>
<p>通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。</p>
<p>以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。</p>
<p>在try语句块中，用户自定义的异常后执行except块语句，变量 e
是用于创建Networkerror类的实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Networkerror</span>(<span class="title class_ inherited__">RuntimeError</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, arg</span>):</span><br><span class="line">        self.args = arg</span><br></pre></td></tr></table></figure>
<p>在你定义以上类后，你可以触发该异常，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Networkerror(<span class="string">&quot;Bad hostname&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Networkerror,e:</span><br><span class="line">    <span class="built_in">print</span> e.args</span><br></pre></td></tr></table></figure>
<blockquote>
<p>菜鸟教程说的不清不楚囫囵吞枣，回头看书把这里补上</p>
</blockquote>
<h2 id="断言-1">断言</h2>
<p>断言的内容请见第四章</p>
<h1 id="八面向对象">八、面向对象</h1>
<p>这部分的基础知识 OO Pre 里提及不少，欢迎来这篇博客转转——(<a
href="https://strivinglee.github.io/2023/01/13/OO%20Pre%20Review/">OO
Pre Review | StrivingLee's Blog</a>)</p>
<h2 id="创建类">创建类</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line">   <span class="string">&#x27;类的帮助信息&#x27;</span>   <span class="comment">#类文档字符串</span></span><br><span class="line">   class_suite  <span class="comment">#类体</span></span><br></pre></td></tr></table></figure>
<p>类的帮助信息可以通过 <code>ClassName.__doc__</code> 查看。</p>
<p>class_suite 由类成员，方法，数据属性组成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">   <span class="string">&#x27;所有员工的基类&#x27;</span></span><br><span class="line">   empCount = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, salary</span>):</span><br><span class="line">      self.name = name</span><br><span class="line">      self.salary = salary</span><br><span class="line">      Employee.empCount += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">displayCount</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="built_in">print</span> <span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">displayEmployee</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&quot;Name : &quot;</span>, self.name,  <span class="string">&quot;, Salary: &quot;</span>, self.salary</span><br></pre></td></tr></table></figure>
<ul>
<li>empCount
变量是一个类变量，它的值将在这个类的<strong>所有实例之间共享</strong>。可以在内部类或外部类使用
Employee.empCount 访问</li>
<li>第一种方法 <code>__init__()</code>
方法是一种特殊的方法，被称为类的<strong>构造函数</strong>或初始化方法，创建这个类的实例时会调用该方法</li>
<li>self 代表类的实例，self
在定义类的方法时是必需的，虽然<strong>在调用时不必传入相应的参数</strong>（见下）</li>
</ul>
<h3 id="self">self</h3>
<p>类的方法与普通的函数只有一个特别的区别——它们必须有额外的<strong>第一个参数</strong>，按照惯例它的名称是
self</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prt</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="built_in">print</span>(self.__class__)</span><br><span class="line"> </span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;__main__.Test instance at 0x10d066878&gt;</span><br><span class="line">__main__.Test</span><br></pre></td></tr></table></figure>
<p>self 代表的是类的实例（当前对象的地址），**self.__class__**
指向类</p>
<p>当然，self 不是关键字，换成 runoob
也可以正常执行<del>，但是愚以为似乎没有必要知道这些</del></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prt</span>(<span class="params">runoob</span>):</span><br><span class="line">        <span class="built_in">print</span>(runoob)</span><br><span class="line">        <span class="built_in">print</span>(runoob.__class__)</span><br><span class="line"> </span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;__main__.Test instance at 0x10d066878&gt;</span><br><span class="line">__main__.Test</span><br></pre></td></tr></table></figure>
<h2 id="创建实例对象">创建实例对象</h2>
<p>在 Python 中没有 <code>new</code>
关键字，类的实例化类似其他语言中的构造函数（区别于 <code>__init__</code>
构造函数）</p>
<p>以下使用类的名称 Employee 来实例化，并通过 <code>__init__</code>
方法接收参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;创建 Employee 类的第一个对象&quot;</span><br><span class="line">emp1 = Employee(&quot;Zara&quot;, 2000)</span><br><span class="line">&quot;创建 Employee 类的第二个对象&quot;</span><br><span class="line">emp2 = Employee(&quot;Manni&quot;, 5000)</span><br></pre></td></tr></table></figure>
<h2 id="访问属性">访问属性</h2>
<p>使用点号 <code>.</code> 来访问对象的属性</p>
<h2 id="添加删除修改类的属性">添加，删除，修改类的属性</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emp1.age = 7  # 添加一个 &#x27;age&#x27; 属性</span><br><span class="line">emp1.age = 8  # 修改 &#x27;age&#x27; 属性</span><br><span class="line">del emp1.age  # 删除 &#x27;age&#x27; 属性</span><br></pre></td></tr></table></figure>
<p>有关属性的函数：</p>
<ul>
<li>getattr(obj, name[, default]) : 访问对象的属性。</li>
<li>hasattr(obj,name) : 检查是否存在该属性。</li>
<li>setattr(obj,name,value) :
设置属性。如果该属性不存在，会创建一个新属性。</li>
<li>delattr(obj, name) : 删除属性。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">hasattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>)    <span class="comment"># 如果存在 &#x27;age&#x27; 属性返回 True。</span></span><br><span class="line"><span class="built_in">getattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>)    <span class="comment"># 返回 &#x27;age&#x27; 属性的值</span></span><br><span class="line"><span class="built_in">setattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>, <span class="number">8</span>) <span class="comment"># 添加属性 &#x27;age&#x27; 值为 8</span></span><br><span class="line"><span class="built_in">delattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>)    <span class="comment"># 删除属性 &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="内置类属性">内置类属性</h2>
<ul>
<li><strong>dict</strong>：类的属性（包含一个字典，由类的数据属性组成）</li>
<li><strong>doc</strong>：类的文档字符串</li>
<li><strong>name</strong>：类名</li>
<li><strong>module</strong>：类定义所在的模块（类的全名是
<code>__main__.className</code>，如果类位于一个导入模块
<code>mymod</code> 中，那么 <code>className.__module__</code> 等于
<code>mymod</code>）</li>
<li><strong>bases</strong>：类的所有父类构成元素（包含了一个由所有父类组成的元组）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">   <span class="string">&#x27;所有员工的基类&#x27;</span></span><br><span class="line">   empCount = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, salary</span>):</span><br><span class="line">      self.name = name</span><br><span class="line">      self.salary = salary</span><br><span class="line">      Employee.empCount += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">displayCount</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="built_in">print</span> <span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">displayEmployee</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&quot;Name : &quot;</span>, self.name,  <span class="string">&quot;, Salary: &quot;</span>, self.salary</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Employee.__doc__:&quot;</span>, Employee.__doc__</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Employee.__name__:&quot;</span>, Employee.__name__</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Employee.__module__:&quot;</span>, Employee.__module__</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Employee.__bases__:&quot;</span>, Employee.__bases__</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Employee.__dict__:&quot;</span>, Employee.__dict__</span><br></pre></td></tr></table></figure>
<p>执行以上代码输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Employee.__doc__: 所有员工的基类</span><br><span class="line">Employee.__name__: Employee</span><br><span class="line">Employee.__module__: __main__</span><br><span class="line">Employee.__bases__: ()</span><br><span class="line">Employee.__dict__: &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;displayCount&#x27;: &lt;function displayCount at 0x10a939c80&gt;, &#x27;empCount&#x27;: 0, &#x27;displayEmployee&#x27;: &lt;function displayEmployee at 0x10a93caa0&gt;, &#x27;__doc__&#x27;: &#x27;\xe6\x89\x80\xe6\x9c\x89\xe5\x91\x98\xe5\xb7\xa5\xe7\x9a\x84\xe5\x9f\xba\xe7\xb1\xbb&#x27;, &#x27;__init__&#x27;: &lt;function __init__ at 0x10a939578&gt;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象销毁垃圾回收">对象销毁(垃圾回收)</h2>
<p>Python 使用引用计数这一简单技术来跟踪和回收垃圾。</p>
<p>在 Python 内部记录着所有使用中的对象各有多少引用。</p>
<p>引用计数是一个内部跟踪变量，对象被创建时也会同时创建一个引用计数，
当这个对象不再需要时（引用计数为 0），Python
将它垃圾回收——由解释器在适当的时机（并不一定立即回收）回收将垃圾对象占用的内存空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">40</span>      <span class="comment"># 创建对象  &lt;40&gt;</span></span><br><span class="line">b = a       <span class="comment"># 增加引用， &lt;40&gt; 的计数</span></span><br><span class="line">c = [b]     <span class="comment"># 增加引用.  &lt;40&gt; 的计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a       <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br><span class="line">b = <span class="number">100</span>     <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br><span class="line">c[<span class="number">0</span>] = -<span class="number">1</span>   <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python
的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充，
垃圾收集器也会留心被分配的总量很大（即未通过引用计数销毁的那些）的对象。
在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。</em></p>
</blockquote>
<p>如析构函数 <code>__del__</code> 在对象销毁的时候调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span><br><span class="line">      self.x = x</span><br><span class="line">      self.y = y</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">      class_name = self.__class__.__name__</span><br><span class="line">      <span class="built_in">print</span> class_name, <span class="string">&quot;销毁&quot;</span></span><br><span class="line"> </span><br><span class="line">pt1 = Point()</span><br><span class="line">pt2 = pt1</span><br><span class="line">pt3 = pt1</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">id</span>(pt1), <span class="built_in">id</span>(pt2), <span class="built_in">id</span>(pt3) <span class="comment"># 打印对象的id</span></span><br><span class="line"><span class="keyword">del</span> pt1</span><br><span class="line"><span class="keyword">del</span> pt2</span><br><span class="line"><span class="keyword">del</span> pt3</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3083401324 3083401324 3083401324</span><br><span class="line">Point 销毁</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>通常你需要在单独的文件中定义一个类</p>
<h2 id="类的继承">类的继承</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 派生类名(基类名)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>在python中继承中的一些特点：</p>
<ul>
<li>1、子类如果需要父类的构造方法，需要显式调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看：<a
href="https://www.runoob.com/w3cnote/python-extends-init.html">python
子类继承父类构造函数说明</a>。</li>
<li>2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self
参数变量，在类中调用普通函数时并不需要带 self 参数</li>
<li>3、Python
总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（自底向上）</li>
</ul>
<p>派生类在声明时，继承的基类列表跟在类名之后，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SubClassName (ParentClass1[, ParentClass2, ...]):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>:        <span class="comment"># 定义父类</span></span><br><span class="line">   parentAttr = <span class="number">100</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&quot;调用父类构造函数&quot;</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">parentMethod</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;调用父类方法&#x27;</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">setAttr</span>(<span class="params">self, attr</span>):</span><br><span class="line">      Parent.parentAttr = attr</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">getAttr</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&quot;父类属性：&quot;</span>, Parent.parentAttr</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Parent</span>): <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&quot;调用子类构造方法&quot;</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">childMethod</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;调用子类方法&#x27;</span></span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 实例化子类</span></span><br><span class="line">c.childMethod()      <span class="comment"># 调用子类的方法</span></span><br><span class="line">c.parentMethod()     <span class="comment"># 调用父类方法</span></span><br><span class="line">c.setAttr(<span class="number">200</span>)       <span class="comment"># 再次调用父类的方法 - 设置属性值</span></span><br><span class="line">c.getAttr()          <span class="comment"># 再次调用父类的方法 - 获取属性值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用子类构造方法</span><br><span class="line">调用子类方法</span><br><span class="line">调用父类方法</span><br><span class="line">父类属性：200</span><br></pre></td></tr></table></figure>
<p><strong>Python 支持多重继承</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A:        # 定义类 A</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">class B:         # 定义类 B</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">class C(A, B):   # 继承类 A 和 B</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p><code>issubclass()</code> 和 <code>isinstance()</code> 方法</p>
<ul>
<li><code>issubclass(sub, sup)</code> -
布尔函数，判断一个类是否是另一个类的子类或者子孙类</li>
<li><code>isinstance(obj, Class)</code> - 布尔函数，判断
<code>obj</code> 是否是 <code>Class</code> 类或其子类的实例对象</li>
</ul>
<h2 id="方法重写">方法重写</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>:        <span class="comment"># 定义父类</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">myMethod</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;调用父类方法&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Parent</span>): <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">myMethod</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;调用子类方法&#x27;</span></span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 子类实例</span></span><br><span class="line">c.myMethod()         <span class="comment"># 子类调用重写方法</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用子类方法</span><br></pre></td></tr></table></figure>
<h2 id="基础重载方法">基础重载方法</h2>
<p>下表列出了一些通用的功能，你可以在自己的类重写：</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">序号</th>
<th style="text-align: left;">方法, 描述 &amp; 简单的调用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;">**__init__ ( self [,args...] )** 构造函数
简单的调用方法: <em>obj = className(args)</em></td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td style="text-align: left;">**__del__( self )** 析构方法，删除一个对象
简单的调用方法 : <em>del obj</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;">3</td>
<td style="text-align: left;">**__repr__( self )**
转化为供解释器读取的形式 简单的调用方法 : <em>repr(obj)</em></td>
</tr>
<tr class="even">
<td style="text-align: left;">4</td>
<td style="text-align: left;">**__str__( self )**
用于将值转化为适于人阅读的形式 简单的调用方法 : <em>str(obj)</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;">5</td>
<td style="text-align: left;">**__cmp__ ( self, x )** 对象比较
简单的调用方法 : <em>cmp(obj, x)</em></td>
</tr>
</tbody>
</table>
<blockquote>
<p>关于 <code>__repr</code> 和 <code>__str__</code>
的比较请见第三章，因为锚点功能貌似不能用，只好这样了</p>
</blockquote>
<h2 id="运算符重载">运算符重载</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b</span>):</span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Vector (%d, %d)&#x27;</span> % (self.a, self.b)</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">      <span class="keyword">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line"> </span><br><span class="line">v1 = Vector(<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>,-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> v1 + v2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vector(7,8)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里说的不清不楚的</p>
</blockquote>
<h2 id="类属性与方法">类属性与方法</h2>
<h3 id="类的私有属性">类的私有属性</h3>
<p>**__private_attrs**：两个下划线开头声明该属性为私有属性，不能在类的外部被使用或直接访问。在类内部的方法中使用时语法为
<code>self.__private_attrs</code>。</p>
<h3 id="类的方法">类的方法</h3>
<p>在类的内部，使用 <strong>def</strong>
关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数
self，且为第一个参数</p>
<h3 id="类的私有方法">类的私有方法</h3>
<p>**__private_method**：两个下划线开头声明该方法为私有方法，不能在类的外部调用。在类的内部调用时语法为
<code>self.__private_methods</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JustCounter</span>:</span><br><span class="line">    __secretCount = <span class="number">0</span>  <span class="comment"># 私有变量</span></span><br><span class="line">    publicCount = <span class="number">0</span>    <span class="comment"># 公开变量</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">self</span>):</span><br><span class="line">        self.__secretCount += <span class="number">1</span></span><br><span class="line">        self.publicCount += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span> self.__secretCount</span><br><span class="line"> </span><br><span class="line">counter = JustCounter()</span><br><span class="line">counter.count()</span><br><span class="line">counter.count()</span><br><span class="line"><span class="built_in">print</span> counter.publicCount</span><br><span class="line"><span class="built_in">print</span> counter.__secretCount  <span class="comment"># 报错，实例不能访问私有变量</span></span><br></pre></td></tr></table></figure>
<p>Python 通过改变名称来包含类名:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">    print counter.__secretCount  # 报错，实例不能访问私有变量</span><br><span class="line">AttributeError: JustCounter instance has no attribute &#x27;__secretCount&#x27;</span><br></pre></td></tr></table></figure>
<p>Python 不允许实例化的类访问私有数据，但你可以使用
**object._className__attrName<strong>（
</strong>对象名._类名__私有属性名** ）访问属性，参考以下实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Runoob:</span><br><span class="line">    __site = &quot;www.runoob.com&quot;</span><br><span class="line"></span><br><span class="line">runoob = Runoob()</span><br><span class="line">print runoob._Runoob__site</span><br></pre></td></tr></table></figure>
<p>执行以上代码，执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure>
<h3 id="下划线说明">下划线说明</h3>
<ul>
<li>**__foo__**: 定义的是特殊方法，一般是系统定义名字 ，类似
<code>__init__()</code> 之类的。</li>
<li>**_foo<strong>: 以单下划线开头的表示的是 <code>protected</code>
类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于
</strong>from module import ***</li>
<li>**__foo**: 双下划线的表示的是 <code>private</code> 类型的变量,
只能是允许这个类本身进行访问了。</li>
</ul>
<h1 id="九魔法方法特性和迭代器">九、魔法方法、特性和迭代器</h1>
<p>构造方法、析构方法</p>
<h2 id="重写普通方法和特殊的构造函数">重写普通方法和特殊的构造函数</h2>
<p>对类 B 的实例调用方法或访问其属性时，如果找不到，将在其超类 A
中查找</p>
<p>重写构造函数时可能遇到一个特殊的问题：必须调用超类的构造函数，否则可能没有对应的成员</p>
<h2 id="使用函数super">使用函数super</h2>
<p>将当前类和当前实例作为参数，调用超类的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.hungry = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.hungry:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Aaaah ...&#x27;</span>)</span><br><span class="line">            self.hungry = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;No thanks!&#x27;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SongBird</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.sound = <span class="string">&#x27;Squawk!&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.sound)</span><br></pre></td></tr></table></figure>
<h2 id="函数property">函数property</h2>
<blockquote>
<p>没读懂，todo</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.width = <span class="number">0</span></span><br><span class="line">        self.height = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_size</span>(<span class="params">self, size</span>):</span><br><span class="line">        self.width, self.height = size</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.width, self.height</span><br><span class="line">    size = <span class="built_in">property</span>(get_size, set_size)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于新式类，应该使用特性而非存取方法</p>
</blockquote>
<h2 id="静态方法和类方法">静态方法和类方法</h2>
<blockquote>
<p>应用并不多，但是确实有用武之地（如工厂函数）</p>
</blockquote>
<h2 id="迭代器协议">迭代器协议</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 9-6-1.py</span></span><br></pre></td></tr></table></figure>
<h2 id="生成器">生成器</h2>
<p>包含 <code>yield</code> 语句的函数</p>
<p>每次生成一个值，可以生成多个，每次使用都冻结，即在此停止执行，等待被重新唤醒。唤醒后从停止的地方继续执行</p>
<h1 id="十一文件">十一、文件</h1>
<blockquote>
<p>与更丰富的外部世界交互</p>
</blockquote>
<h2 id="file对象操作">File对象操作</h2>
<h3 id="open">open()</h3>
<p>内置函数，打开一个文件，<strong>创建一个 file
对象</strong>供相关方法调用它进行读写。</p>
<p><strong>必须先创建 file 对象才能进行后续文件操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file object = open(file_name[, access_mode][, buffering])</span><br></pre></td></tr></table></figure>
<p>各个参数的细节如下：</p>
<ul>
<li>file_name：文件名称的字符串值。</li>
<li>access_mode：打开文件的模式（只读，写入，追加等），默认为只读(r)。</li>
<li>buffering：
<ul>
<li>0：无寄存</li>
<li>1：寄存行</li>
<li>大于1的整数：寄存区的缓冲大小</li>
<li>负值：系统默认寄存区缓冲大小</li>
</ul></li>
</ul>
<p>文件不同打开模式：</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">模式</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">t</td>
<td style="text-align: left;">文本模式 (默认)。</td>
</tr>
<tr class="even">
<td style="text-align: left;">x</td>
<td
style="text-align: left;">写模式，新建一个文件，如果该文件已存在则会报错。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">b</td>
<td style="text-align: left;">二进制模式。</td>
</tr>
<tr class="even">
<td style="text-align: left;">+</td>
<td style="text-align: left;">打开一个文件进行更新(可读可写)。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">U</td>
<td style="text-align: left;">通用换行模式（不推荐）。</td>
</tr>
<tr class="even">
<td style="text-align: left;">r</td>
<td
style="text-align: left;">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rb</td>
<td
style="text-align: left;">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td>
</tr>
<tr class="even">
<td style="text-align: left;">r+</td>
<td
style="text-align: left;">打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rb+</td>
<td
style="text-align: left;">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td>
</tr>
<tr class="even">
<td style="text-align: left;">w</td>
<td
style="text-align: left;">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">wb</td>
<td
style="text-align: left;">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr class="even">
<td style="text-align: left;">w+</td>
<td
style="text-align: left;">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">wb+</td>
<td
style="text-align: left;">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr class="even">
<td style="text-align: left;">a</td>
<td
style="text-align: left;">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ab</td>
<td
style="text-align: left;">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr class="even">
<td style="text-align: left;">a+</td>
<td
style="text-align: left;">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ab+</td>
<td
style="text-align: left;">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody>
</table>
<figure>
<img
src="https://www.runoob.com/wp-content/uploads/2013/11/2112205-861c05b2bdbc9c28.png"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">模式</th>
<th style="text-align: center;">r</th>
<th style="text-align: center;">r+</th>
<th style="text-align: center;">w</th>
<th style="text-align: center;">w+</th>
<th style="text-align: center;">a</th>
<th style="text-align: center;">a+</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">读</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">+</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">+</td>
</tr>
<tr class="even">
<td style="text-align: center;">写</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+</td>
</tr>
<tr class="odd">
<td style="text-align: center;">创建</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+</td>
</tr>
<tr class="even">
<td style="text-align: center;">覆盖</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">指针在开始</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">指针在结尾</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+</td>
</tr>
</tbody>
</table>
<h3 id="file对象的属性">File对象的属性</h3>
<p>前面交代过，一个文件被打开后，你有一个 file
对象，可以得到有关该文件的各种信息</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">属性</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">file.closed</td>
<td
style="text-align: left;">返回true如果文件已被关闭，否则返回false。</td>
</tr>
<tr class="even">
<td style="text-align: left;">file.mode</td>
<td style="text-align: left;">返回被打开文件的访问模式。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">file.name</td>
<td style="text-align: left;">返回文件的名称。</td>
</tr>
<tr class="even">
<td style="text-align: left;">file.softspace</td>
<td
style="text-align: left;">如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;文件名：&quot;</span>, fo.name</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;是否已关闭：&quot;</span>, fo.closed</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;访问模式：&quot;</span>, fo.mode</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;末尾是否强制加空格：&quot;</span>, fo.softspace</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件名：foo.txt</span><br><span class="line">是否已关闭：False</span><br><span class="line">访问模式：w</span><br><span class="line">末尾是否强制加空格：0</span><br></pre></td></tr></table></figure>
<h3 id="close">close()</h3>
<p>File 对象的 close()
方法刷新缓冲区里任何还没写入的信息，并关闭该文件不能再进行写入。</p>
<p>当一个文件对象的引用被重新指定给另一个文件时，Python
会关闭之前的文件。</p>
<p><strong>用 close() 方法关闭文件是一个很好的习惯</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileObject.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;文件名：&quot;</span>, fo.name</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure>
<h3 id="write">write()</h3>
<p>可将任何字符串写入一个<strong>已打开</strong>的文件，不会在字符串的结尾添加换行符('')</p>
<blockquote>
<p>注：Python 字符串也可以是二进制数据</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fileObject.write(string)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">fo.write(<span class="string">&quot;strivinglee.github.io!\nVery good site!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure>
<p>创建foo.txt文件，并将给定内容写入文件，最终关闭文件</p>
<p>如果你打开这个文件，将看到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat foo.txt </span><br><span class="line">strivinglee.github.io!</span><br><span class="line">Very good site!</span><br></pre></td></tr></table></figure>
<h3 id="read">read()</h3>
<p>从已打开的文件开头开始读取一个字符串</p>
<blockquote>
<p>Python 字符串注意点同上</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fileObject.read([count])</span><br></pre></td></tr></table></figure>
<p>缺省则尽可能多地读取更多的内容，很可能是直到文件的末尾</p>
<p>用上面创建的 foo.txt 文件为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = fo.read(<span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;读取的字符串是：&quot;</span>, <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取的字符串是：strivinglee</span><br></pre></td></tr></table></figure>
<h2 id="文件定位">文件定位</h2>
<p>tell() 方法告诉你文件内的当前位置（下一次的读写位置）</p>
<p>seek(offset[, from]) 方法改变当前文件的位置。<code>offset</code>
变量表示要移动的字节数，<code>from</code>
变量指定开始移动字节的参考位置。</p>
<p>from：</p>
<ul>
<li>0：文件开头</li>
<li>1：当前位置</li>
<li>2：文件末尾</li>
</ul>
<p>仍用上面创建的文件foo.txt。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = fo.read(<span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;读取的字符串是：&quot;</span>, <span class="built_in">str</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查找当前位置</span></span><br><span class="line">position = fo.tell()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;当前文件位置：&quot;</span>, position</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 把指针再次重新定位到文件开头</span></span><br><span class="line">position = fo.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">str</span> = fo.read(<span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;重新读取字符串：&quot;</span>, <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取的字符串是：strivinglee</span><br><span class="line">当前文件位置：11</span><br><span class="line">重新读取字符串：strivinglee</span><br></pre></td></tr></table></figure>
<h3 id="rename">rename()</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.rename(current_file_name, new_file_name)</span><br></pre></td></tr></table></figure>
<h3 id="remove">remove()</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.remove(file_name)</span><br></pre></td></tr></table></figure>
<h2 id="目录处理">目录处理</h2>
<p>所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多<strong>方法</strong>能帮你创建，删除和更改目录。</p>
<h3 id="mkdir">mkdir()</h3>
<p>在当前目录下创建新的目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.mkdir(<span class="string">&quot;newdir&quot;</span>) <span class="comment"># 要创建的目录名称</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前目录下创建新目录test</span></span><br><span class="line">os.mkdir(<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="chdir">chdir()</h3>
<p>改变当前的目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.chdir(<span class="string">&quot;newdir&quot;</span>) <span class="comment"># 想设成当前目录的目录名称</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将当前目录改为&quot;/home/newdir&quot;（进入&quot;/home/newdir&quot;目录）</span></span><br><span class="line">os.chdir(<span class="string">&quot;/home/newdir&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="getcwd">getcwd()</h3>
<p>显示当前的工作目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.getcwd()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 给出当前的目录</span></span><br><span class="line"><span class="built_in">print</span> os.getcwd()</span><br></pre></td></tr></table></figure>
<h3 id="rmdir">rmdir()</h3>
<p>删除目录，在删除目录之前，应该先清除它的所有内容。</p>
<p>必须给出目录完全合规的名称，否则会在当前目录下搜索该目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.rmdir(&#x27;dirname&#x27;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"> </span><br><span class="line"># 删除”/tmp/test”目录</span><br><span class="line">os.rmdir( &quot;/tmp/test&quot;  )</span><br></pre></td></tr></table></figure>
<h2 id="文件目录相关的方法">文件、目录相关的方法</h2>
<p>File 对象和 OS
对象提供了很多文件与目录的操作方法，可以参考菜鸟教程给出的教程：</p>
<ul>
<li><a href="https://www.runoob.com/python/file-methods.html">File
对象方法</a>: file 对象提供了操作文件的一系列方法。</li>
<li><a href="https://www.runoob.com/python/os-file-methods.html">OS
对象方法</a>: 提供了处理文件及目录的一系列方法。</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Python</category>
        <category>S4 Summer</category>
        <category>S3 Winter</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode配置latex</title>
    <url>/vscode-configure-latex/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>记录采用 <span class="math inline">\(MixTEX\)</span> 在 <span
class="math inline">\(VSCode\)</span> 搭建 <span
class="math inline">\(\LaTeX\)</span> 环境的过程</p>
</blockquote>
<span id="more"></span>
<h2 id="安装编译器">安装编译器</h2>
<p>原 <code>TexLive</code> 体积过大，采用包管理器进行安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 MikTeX</span></span><br><span class="line">scoop install miktex</span><br></pre></td></tr></table></figure>
<h2 id="配置-vscode">配置 VSCode</h2>
<p>安装 <code>LaTeX Workshop</code> 扩展</p>
<p>加入如下配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;latex-workshop.latex.tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-shell-escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;%DOCFILE%&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;xelatex&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="解决报错">解决报错</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">major issue: So far, you have not checked for MiKTeX updates.</span><br></pre></td></tr></table></figure>
<p>找到MikTex
Console这个程序，右键点击“以管理员身份运行”，然后点击“检查更新”</p>
<blockquote>
<p><em>Ref:</em></p>
<p><em><a href="https://zhuanlan.zhihu.com/p/139210056">搭建 LaTeX
舒适写作环境（VSCode） - 知乎 (zhihu.com)</a></em></p>
</blockquote>
]]></content>
      <categories>
        <category>Tools</category>
        <category>S5</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
        <tag>Path</tag>
      </tags>
  </entry>
  <entry>
    <title>Pro Git Notes</title>
    <url>/Pro-Git-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p><em>Written on 08-09-2022</em></p>
<p>很重要的先导内容，但是 missing 了</p>
</blockquote>
<span id="more"></span>
<p><del>你一定会在我这里看到 Table of Contents</del></p>
<p>[TOC]</p>
<h2 id="起步">起步</h2>
<h3 id="不重要的part">不重要的part</h3>
<h3 id="git-基础但我认为叫git原理更好些">Git
基础（但我认为叫Git原理更好些）</h3>
<p>理解原理有助于使用</p>
<h4 id="直接记录快照">直接记录快照</h4>
<p>其它大部分系统以文件变更列表的方式存储信息。
这类系统将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</p>
<figure>
<img src="https://www.progit.cn/images/deltas.png"
alt="存储每个文件与初始版本的差异。" />
<figcaption
aria-hidden="true">存储每个文件与初始版本的差异。</figcaption>
</figure>
<p>Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在
Git
中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。
Git 对待数据更像是一个 <strong>快照流</strong>。</p>
<figure>
<img src="https://www.progit.cn/images/snapshots.png"
alt="Git 存储项目随时间改变的快照。" />
<figcaption aria-hidden="true">Git
存储项目随时间改变的快照。</figcaption>
</figure>
<h4 id="本地执行操作">本地执行操作</h4>
<p>快而方便，可以进行离线操作</p>
<h4 id="保证完整性">保证完整性</h4>
<p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。
这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在
Git 底层，是构成 Git 哲学不可或缺的部分。
若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p>
<p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40
个十六进制字符（0-9 和 a-f）组成字符串，基于 Git
中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">24b9da6552252987aa493b52f8696cd6d3b00373</span><br></pre></td></tr></table></figure>
<p>Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git
数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<h4 id="只添加数据">只添加数据</h4>
<p>你执行的 Git 操作，几乎只往 Git 数据库中增加数据， 很难让 Git
执行任何不可逆操作，或者让它以任何方式清除数据。 一旦你提交快照到 Git
中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。我们可以尽情做各种尝试，而不怕把事情弄糟。</p>
<h4 id="三种状态">三种状态</h4>
<p>好，请注意。 如果你希望后面的学习更顺利，记住下面这些关于 Git
的概念。 Git
有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。
已提交表示数据已经安全的保存在本地数据库中。
已修改表示修改了文件，但还没保存到数据库中。
已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p>
<p>由此引入 Git 项目的三个工作区域的概念：Git
仓库、工作目录以及暂存区域。</p>
<figure>
<img src="https://www.progit.cn/images/areas.png"
alt="工作目录、暂存区域以及 Git 仓库。" />
<figcaption aria-hidden="true">工作目录、暂存区域以及 Git
仓库。</figcaption>
</figure>
<p>Git 仓库是 Git 用来保存项目的元数据和对象数据库的地方。 <strong>这是
Git
中最重要的部分</strong>，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p>
<p>工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git
仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p>
<p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git
仓库目录中。 有时候也被称作`‘索引’'，不过一般说法还是叫暂存区域。</p>
<p>基本的 Git 工作流程如下：</p>
<ol type="1">
<li>在工作目录中修改文件。</li>
<li>暂存文件，将文件的快照放入暂存区域。</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li>
</ol>
<p>如果 Git 目录中保存着特定版本的文件，就属于已提交状态。
如果作了修改并已放入暂存区域，就属于已暂存状态。
如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 在<a
href="https://www.progit.cn/#_git_basics_chapter">Git
基础</a>一章，你会进一步了解这些状态的细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。</p>
<h4 id="the-three-states">The Three States</h4>
<p>Pay attention now — here is the main thing to remember about Git if
you want the rest of your learning process to go smoothly. Git has three
main states that your files can reside in: <em>modified</em>,
<em>staged</em>, and <em>committed</em>:</p>
<ul>
<li>Modified means that you have changed the file but have not committed
it to your database yet.</li>
<li>Staged means that you have marked a modified file in its current
version to go into your next commit snapshot.</li>
<li>Committed means that the data is safely stored in your local
database.</li>
</ul>
<p>This leads us to the three main sections of a Git project:
<strong>the working tree, the staging area, and the Git
directory</strong>.The working tree is a single checkout of one version
of the project. These files are pulled out of the compressed database in
the Git directory and placed on disk for you to use or modify.</p>
<p>The staging area is a file, generally contained in your Git
directory, that stores information about what will go into your next
commit. Its technical name in Git parlance is the “index”, but the
phrase “staging area” works just as well.</p>
<p>The Git directory is where Git stores the metadata and object
database for your project. This is the most important part of Git, and
it is what is copied when you <em>clone</em> a repository from another
computer.</p>
<p>The basic Git workflow goes something like this:</p>
<ol type="1">
<li>You modify files in your working tree.</li>
<li>You selectively stage just those changes you want to be part of your
next commit, which adds <em>only</em> those changes to the staging
area.</li>
<li>You do a commit, which takes the files as they are in the staging
area and stores that snapshot permanently to your Git directory.</li>
</ol>
<p>If a particular version of a file is in the Git directory, it’s
considered <em>committed</em>. If it has been modified and was added to
the staging area, it is <em>staged</em>. And if it was changed since it
was checked out but has not been staged, it is <em>modified</em>. In <a
href="https://git-scm.com/book/en/v2/ch00/ch02-git-basics-chapter">Git
Basics</a>, you’ll learn more about these states and how you can either
take advantage of them or skip the staged part entirely.</p>
<blockquote>
<p>这段文字太重要了，<del>中译本又译得太好让人不忍卒读</del>，所以我把中英版本都留在这里了。总结下来就是几个知识点：</p>
<p>① 有三个地方存放文件：working tree、the staging area、Git
directory（按照“从弱到强”的顺序）</p>
<ul>
<li>对三个地方的介绍</li>
</ul>
<p>②
file有三个状态：modified、staged、commited（按照“从弱到强”的顺序）</p>
<ul>
<li>对三种状态的介绍</li>
</ul>
</blockquote>
<h3 id="命令行">命令行</h3>
<p>见其他文章</p>
<h3 id="初次运行-git-前的配置">初次运行 Git 前的配置</h3>
<blockquote>
<p>笔者注：我感觉这才是Git Missing
Semester，这解答了我很多疑问（比如config --global
user）并且指引了解决问题的方法</p>
</blockquote>
<p>既然已经在系统上安装了 Git，你会想要做几件事来定制你的 Git 环境。
每台计算机上只需要配置一次，程序升级时会保留配置信息。
你可以在任何时候再次通过运行命令来修改它们。</p>
<p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git
外观和行为的配置变量。 这些变量存储在三个不同的位置：</p>
<ol type="1">
<li><code>/etc/gitconfig</code> 文件:
包含系统上每一个用户及他们仓库的通用配置。 如果使用带有
<code>--system</code> 选项的 <code>git config</code>
时，它会从此文件读写配置变量。</li>
<li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code>
文件：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git
读写此文件。</li>
<li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（就是
<code>.git/config</code>）：针对该仓库。</li>
</ol>
<p>每一个级别覆盖上一级别的配置，所以 <code>.git/config</code>
的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p>
<p>在 Windows 系统中，Git 会查找 <code>$HOME</code> 目录下（一般情况下是
<code>C:\Users\$USER</code>）的 <code>.gitconfig</code> 文件。 Git
同样也会寻找 <code>/etc/gitconfig</code> 文件，但只限于 MSys
的根目录下，即安装 Git 时所选的目标位置。</p>
<h4 id="用户信息">用户信息</h4>
<p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。
这样做很重要，因为每一个 Git
的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;John Doe&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email johndoe@example.com</span></span><br></pre></td></tr></table></figure>
<p>再次强调，如果使用了 <code>--global</code>
选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git
都会使用那些信息。
当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有
<code>--global</code> 选项的命令来配置。</p>
<p>很多 GUI 工具都会在第一次运行时帮助你配置这些信息。</p>
<h4 id="文本编辑器">文本编辑器</h4>
<p>既然用户信息已经设置完毕，你可以配置默认文本编辑器了，当 Git
需要你输入信息时会调用它。 如果未配置，Git
会使用操作系统默认的文本编辑器，通常是 Vim。
如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core.editor emacs</span></span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>WARNING</th>
<th>Vim 和 Emacs 是像 Linux 与 Mac 等基于 Unix
的系统上开发者经常使用的流行的文本编辑器。
如果你对这些编辑器都不是很了解或者你使用的是 Windows
系统，那么可能需要搜索如何在 Git 中配置你最常用的编辑器。
如果你不设置编辑器并且不知道 Vim 或 Emacs
是什么，当它们运行起来后你可能会被弄糊涂、不知所措。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="检查配置信息">检查配置信息</h4>
<p>如果想要检查你的配置，可以使用 <code>git config --list</code>
命令来列出所有 Git 当时能找到的配置。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --list</span></span><br><span class="line">user.name=John Doe</span><br><span class="line">user.email=johndoe@example.com</span><br><span class="line">color.status=auto</span><br><span class="line">color.branch=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">color.diff=auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>你可能会看到重复的变量名，因为 Git
会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与
<code>~/.gitconfig</code>）。 这种情况下，Git
会使用它找到的每一个变量的最后一个配置。</p>
<p>你可以通过输入 <code>git config &lt;key&gt;</code>： 来检查 Git
的某一项配置</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.name</span></span><br><span class="line">John Doe</span><br></pre></td></tr></table></figure>
<h3 id="获取帮助">获取帮助</h3>
<p>若你使用 Git 时需要获取帮助，有三种方法可以找到 Git
命令的使用手册：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">help</span> &lt;verb&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git &lt;verb&gt; --<span class="built_in">help</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man git-&lt;verb&gt;</span></span><br></pre></td></tr></table></figure>
<p>例如，要想获得 config 命令的手册，执行</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">help</span> config</span></span><br></pre></td></tr></table></figure>
<p>这些命令很棒，因为你随时随地可以使用而无需联网。
如果你觉得手册或者本书的内容还不够用，你可以尝试在 Freenode IRC 服务器（
irc.freenode.net ）的 <code>#git</code> 或 <code>#github</code>
频道寻求帮助。 这些频道经常有上百人在线，他们都精通 Git
并且乐于助人。</p>
<h2 id="git-基础">Git 基础</h2>
<p><strong>本章是最重要的一章，涵盖使用 Git
完成各种工作中将要使用的各种基本命令。</strong>
在学习完本章之后，你应该能够配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit)更改。
本章也将向你演示如何配置 Git
来忽略指定的文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。</p>
<h3 id="获取-git-仓库">获取 Git 仓库</h3>
<p>有两种取得 Git 项目仓库的方法。
第一种是在现有项目或目录下导入所有文件到 Git 中；
第二种是从一个服务器克隆一个现有的 Git 仓库。</p>
<h4 id="在现有目录中初始化仓库">在现有目录中初始化仓库</h4>
<p>如果你打算使用 Git
来对现有的项目进行管理，你只需要进入该项目目录并输入：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br></pre></td></tr></table></figure>
<p>该命令将创建一个名为 <code>.git</code>
的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是
Git 仓库的骨干。
但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。
(参见 <a href="https://www.progit.cn/#_git_internals">Git 内部原理</a>
来了解更多关于到底 <code>.git</code> 文件夹中包含了哪些文件的信息。)</p>
<p>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git
仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。 你可通过
<code>git add</code> 命令来实现对指定文件的跟踪，然后执行
<code>git commit</code> 提交：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add *.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add LICENSE</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;initial project version&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>稍后我们再逐一解释每一条指令的意思。
现在，你已经得到了一个实际维护（或者说是跟踪）着若干个文件的 Git
仓库。</p>
<h4 id="克隆现有的仓库">克隆现有的仓库</h4>
<p>如果你想获得一份已经存在了的 Git
仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，就要用到
<code>git clone</code> 命令。 Git 克隆的是该 Git
仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要的文件。
当你执行 <code>git clone</code> 命令的时候，默认配置下远程 Git
仓库中的每一个文件的每一个版本都将被拉取下来。
事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库（虽然可能会丢失某些服务器端的挂钩设置，但是所有版本的数据仍在，详见
<a href="https://www.progit.cn/#_git_on_the_server">在服务器上搭建
Git</a> ）。</p>
<p>克隆仓库的命令格式是 <code>git clone [url]</code> 。 比如，要克隆 Git
的可链接库 libgit2，可以用下面的命令：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2</span></span><br></pre></td></tr></table></figure>
<p>这会在当前目录下创建一个名为 “libgit2”
的目录，并在这个目录下初始化一个 <code>.git</code>
文件夹，从远程仓库拉取下所有数据放入 <code>.git</code>
文件夹，然后从中读取最新版本的文件的拷贝。</p>
<p>自定义本地仓库的名字的命令：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit</span></span><br></pre></td></tr></table></figure>
<p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为
<code>mylibgit</code>。</p>
<p>Git 支持多种数据传输协议。 详见<a
href="https://www.progit.cn/#_git_on_the_server">在服务器上搭建
Git</a></p>
<h3 id="记录更新到仓库">记录更新到仓库</h3>
<p>现在我们手上有了一个真实项目的 Git
仓库，并从这个仓库中取出了所有文件的工作拷贝。
接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p>
<p>请记住，<strong>你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。</strong>
已跟踪的文件是指那些<strong>被纳入了版本控制</strong>的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能是未修改，已修改或已放入暂存区。
工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。
<strong>初次克隆</strong>某个仓库的时候，工作目录中的所有文件都属于<strong>已跟踪文件</strong>，并处于未修改状态。</p>
<p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git
将它们标记为已修改文件。
我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用
Git 时文件的生命周期如下：</p>
<figure>
<img src="https://www.progit.cn/images/lifecycle.png"
alt="Git 下文件生命周期图。" />
<figcaption aria-hidden="true">Git 下文件生命周期图。</figcaption>
</figure>
<p>Figure 8. 文件的状态变化周期</p>
<blockquote>
<p>虽然图是down的（划去），但是这个太精辟了，一张图就解释了所有的内容！！！吹爆！！！</p>
</blockquote>
<h4 id="检查当前文件状态">检查当前文件状态</h4>
<p>查看哪些文件处于什么状态的主要手段是 <code>git status</code> 命令。
如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p>这说明你现在的工作目录<strong>相当干净</strong>。换句话说，所有已跟踪文件在上次提交后都未被更改过。
此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则
Git 会在这里列出来。
最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。
现在，分支名是 “master”,这是默认的分支名。 我们在 <a
href="https://www.progit.cn/#_git_branching">Git 分支</a>
会详细讨论分支和引用。</p>
<p>现在，让我们在项目下创建一个新的 README 文件。
如果之前并不存在这个文件，使用 <code>git status</code>
命令，你将看到一个新的未跟踪文件：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;My Project&#x27;</span> &gt; README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">    README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>
<p>在状态报告中可以看到新建的 README 文件出现在
<code>Untracked files</code> 下面。 未跟踪的文件意味着 Git
在之前的快照（提交）中没有这些文件；<strong>Git
不会自动将之纳入跟踪范围</strong>，除非你明明白白地告诉它“我需要跟踪该文件”，
<strong>这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来</strong>。
不过现在的例子中，我们确实想要跟踪管理 README 这个文件。</p>
<h4 id="跟踪新文件">跟踪新文件</h4>
<p>使用命令 <code>git add</code> 开始跟踪一个文件。 所以，要跟踪 README
文件，运行：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br></pre></td></tr></table></figure>
<p>此时再运行 <code>git status</code> 命令，会看到 README
文件已被跟踪，并处于暂存状态：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br></pre></td></tr></table></figure>
<p>只要在 <code>Changes to be committed</code>
这行下面的，就说明是已暂存状态。
如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。
你可能会想起之前我们使用 <code>git init</code> 后就运行了
<code>git add (files)</code> 命令，开始跟踪当前目录下的文件。
<code>git add</code>
命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的<strong>所有文件</strong>。</p>
<h4 id="暂存已修改文件">暂存已修改文件</h4>
<p>现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为
<code>CONTRIBUTING.md</code> 的已被跟踪的文件，然后运行
<code>git status</code> 命令，会看到下面内容：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>文件 <code>CONTRIBUTING.md</code> 出现在
<code>Changes not staged for commit</code>
这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。
要暂存这次更新，需要运行 <code>git add</code> 命令。
这是个多功能命令：<strong>可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等</strong>。
<strong>将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适</strong>。
现在让我们运行 <code>git add</code>
将"CONTRIBUTING.md"放到暂存区，然后再看看 <code>git status</code>
的输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。
假设此时，你想要在 <code>CONTRIBUTING.md</code> 里再加条注释，
重新编辑存盘后，准备好提交。 不过且慢，再运行 <code>git status</code>
看看：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>怎么回事？ 现在 <code>CONTRIBUTING.md</code>
文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git
只不过暂存了你运行 <code>git add</code> 命令时的版本，
如果你现在提交，<code>CONTRIBUTING.md</code> 的版本是你最后一次运行
<code>git add</code> 命令时的那个版本，而不是你运行
<code>git commit</code> 时，在工作目录中的当前版本。 所以，运行了
<code>git add</code> 之后又作了修订的文件，需要重新运行
<code>git add</code> 把最新版本重新暂存起来：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<h4 id="状态简览">状态简览</h4>
<p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。
如果你使用 <code>git status -s</code> 命令或
<code>git status --short</code> 命令，你将得到一种更为紧凑的格式输出。
运行 <code>git status -s</code> ，状态报告输出如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -s</span></span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure>
<p>新添加的未跟踪文件前面有 <code>??</code>
标记，新添加到暂存区中的文件前面有 <code>A</code>
标记，修改过的文件前面有 <code>M</code> 标记。 你可能注意到了
<code>M</code> 有两个可以出现的位置（即第三行的 <code>MM</code>
，这是两个位置，笔者注），出现在右边的 <code>M</code>
表示该文件被修改了但是还没放入暂存区，出现在靠左边的 <code>M</code>
表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示：
<code>README</code>
文件在工作区被修改了但是还没有将修改后的文件放入暂存区,<code>lib/simplegit.rb</code>
文件被修改了并将修改后的文件放入了暂存区。 而 <code>Rakefile</code>
在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p>
<h4 id="忽略文件">忽略文件</h4>
<p>一般我们总会有些文件无需纳入 Git
的管理，也不希望它们总出现在未跟踪文件列表。
通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。
在这种情况下，我们可以创建一个名为 <code>.gitignore</code>
的文件，列出要忽略的文件模式。 来看一个实际的例子：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> .gitignore</span></span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure>
<p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code>
结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉
Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如
Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者
pid 目录，以及自动生成的文档等等。 <strong>要养成一开始就设置好
.gitignore 文件的习惯，以免将来误提交这类无用的文件。</strong></p>
<p>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell
所使用的简化了的<strong>正则表达式</strong>。
星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code>
匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个
b，要么匹配一个
c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如
<code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。
使用两个星号（<code>*</code>)
表示匹配任意中间目录，比如<code>a/**/z</code> 可以匹配 <code>a/z</code>,
<code>a/b/z</code> 或 <code>a/b/c/z</code>等。</p>
<blockquote>
<p>注：</p>
<p><strong>Shell</strong>：Shell 是一个用 C
语言编写的应用程序，它是用户使用 Linux
的桥梁。提供了一个访问操作系统内核服务的界面。Shell
既是一种命令语言，又是一种程序设计语言。比如Git Bash（？）</p>
<p><strong>正则表达式</strong>：</p>
</blockquote>
<p>我们再看一个 .gitignore 文件的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># no .a files</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># but do track lib.a, even though you&#x27;re ignoring .a files above</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"># only ignore the TODO file in the current directory, not subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># ignore all files in the build/ directory</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># ignore doc/notes.txt, but not doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># ignore all .pdf files in the doc/ directory</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>TIP</th>
<th>GitHub 有一个十分详细的针对数十种项目及语言的
<code>.gitignore</code> 文件列表，你可以在
https://github.com/github/gitignore 找到它.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="查看已暂存和未暂存的修改">查看已暂存和未暂存的修改</h4>
<p>如果 <code>git status</code>
命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用
<code>git diff</code> 命令。 稍后我们会详细介绍
<code>git diff</code>，你可能通常会用它来回答这两个问题：当前做的哪些更新还没有暂存？
有哪些更新已经暂存起来准备好了下次提交？ 尽管 <code>git status</code>
已经通过在相应栏下列出文件名的方式回答了这个问题，<code>git diff</code>
将通过文件补丁的格式显示<strong>具体哪些行</strong>发生了改变。</p>
<blockquote>
<p>笔者注：显示了具体内容</p>
</blockquote>
<p>假如再次修改 README 文件后暂存，然后编辑 <code>CONTRIBUTING.md</code>
文件后先不暂存， 运行 <code>status</code> 命令将会看到：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入
<code>git diff</code>：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff</span></span><br><span class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</span><br><span class="line">index 8ebb991..643e24f 100644</span><br><span class="line">--- a/CONTRIBUTING.md</span><br><span class="line">+++ b/CONTRIBUTING.md</span><br><span class="line">@@ -65,7 +65,8 @@ branch directly, things can get messy.</span><br><span class="line"> Please include a nice description of your changes when you submit your PR;</span><br><span class="line"> if we have to read the whole diff to figure out why you&#x27;re contributing</span><br><span class="line"> in the first place, you&#x27;re less likely to get feedback and have your change</span><br><span class="line">-merged in.</span><br><span class="line">+merged in. Also, split your changes into comprehensive chunks if your patch is</span><br><span class="line">+longer than a dozen lines.</span><br><span class="line"></span><br><span class="line"> If you are starting to work on a particular area, feel free to submit a PR</span><br><span class="line"> that highlights your work in progress (and note in the PR title that it&#x27;s</span><br></pre></td></tr></table></figure>
<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，
也就是修改之后还没有暂存起来的变化内容。</p>
<p>若要查看已暂存的将要添加到下次提交里的内容，可以用
<code>git diff --staged</code> 命令。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged</span></span><br><span class="line">diff --git a/README b/README</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..03902a1</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/README</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+My Project</span><br></pre></td></tr></table></figure>
<p>请注意，git diff
本身只显示<strong>尚未暂存的改动</strong>，而不是自上次提交以来所做的所有改动。
所以有时候你一下子暂存了所有更新过的文件后，运行 <code>git diff</code>
后却什么也没有，就是这个原因。</p>
<p>像之前说的，暂存 <code>CONTRIBUTING.md</code> 后再编辑，运行
<code>git status</code> 会看到暂存前后的两个版本。
如果我们的环境（终端输出）看起来如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;# test line&#x27;</span> &gt;&gt; CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>现在运行 <code>git diff</code> 看暂存前后的变化：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff</span></span><br><span class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</span><br><span class="line">index 643e24f..87f08c8 100644</span><br><span class="line">--- a/CONTRIBUTING.md</span><br><span class="line">+++ b/CONTRIBUTING.md</span><br><span class="line">@@ -119,3 +119,4 @@ at the</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash"><span class="comment"># Starter Projects</span></span></span><br><span class="line"></span><br><span class="line"> See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).</span><br><span class="line">+# test line</span><br></pre></td></tr></table></figure>
<p>然后用 <code>git diff --staged</code> 查看已经暂存起来的变化：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged</span></span><br><span class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</span><br><span class="line">index 8ebb991..643e24f 100644</span><br><span class="line">--- a/CONTRIBUTING.md</span><br><span class="line">+++ b/CONTRIBUTING.md</span><br><span class="line">@@ -65,7 +65,8 @@ branch directly, things can get messy.</span><br><span class="line"> Please include a nice description of your changes when you submit your PR;</span><br><span class="line"> if we have to read the whole diff to figure out why you&#x27;re contributing</span><br><span class="line"> in the first place, you&#x27;re less likely to get feedback and have your change</span><br><span class="line">-merged in.</span><br><span class="line">+merged in. Also, split your changes into comprehensive chunks if your patch is</span><br><span class="line">+longer than a dozen lines.</span><br><span class="line"></span><br><span class="line"> If you are starting to work on a particular area, feel free to submit a PR</span><br><span class="line"> that highlights your work in progress (and note in the PR title that it&#x27;s</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>Git Diff 的插件版本在本书中，我们使用 <code>git diff</code>
来分析文件差异。
但是，如果你喜欢通过图形化的方式或其它格式输出方式的话，可以使用
<code>git difftool</code> 命令来用 Araxis ，emerge 或 vimdiff 等软件输出
diff 分析结果。 使用 <code>git difftool --tool-help</code>
命令来看你的系统支持哪些 Git Diff 插件。</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h4 id="提交更新">提交更新</h4>
<p>现在的暂存区域已经准备妥当可以提交了。
在此之前，请一定要确认还有什么修改过的或新建的文件还没有
<code>git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。
这些修改过的文件只保留在本地磁盘。 <strong>所以，每次准备提交前，先用
<code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令
<code>git commit</code>：</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br></pre></td></tr></table></figure>
<p>这种方式会启动文本编辑器以便输入本次提交的说明。 (默认会启用 shell
的环境变量 <code>$EDITOR</code> 所指定的软件，一般都是 vim 或
emacs。当然也可以按照 <a
href="https://www.progit.cn/#_getting_started">起步</a> 介绍的方式，使用
<code>git config --global core.editor</code>
命令设定你喜欢的编辑软件。）</p>
<p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#	new file:   README</span><br><span class="line">#	modified:   CONTRIBUTING.md</span><br><span class="line">#</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">&quot;.git/COMMIT_EDITMSG&quot; 9L, 283C</span><br></pre></td></tr></table></figure>
<p>可以看到，默认的提交消息包含最后一次运行 <code>git status</code>
的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。
你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。
(如果想要更详细的对修改了哪些内容的提示，可以用 <code>-v</code>
选项，这会将你所做的改变的 diff
输出放到编辑器中从而使你知道本次提交具体做了哪些修改。）
退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。</p>
<p>另外，你也可以在 <code>commit</code> 命令后添加 <code>-m</code>
选项，将提交信息与命令放在同一行，如下所示：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;Story 182: Fix benchmarks for speed&quot;</span></span></span><br><span class="line">[master 463dc4f] Story 182: Fix benchmarks for speed</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure>
<p>好，现在你已经创建了第一个提交！
可以看到，提交后它会告诉你，当前是在哪个分支（<code>master</code>）提交的，本次提交的完整
SHA-1
校验和是什么（<code>463dc4f</code>），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p>
<p>请记住，提交时记录的是放在暂存区域的快照。
任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。
每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<h4 id="跳过使用暂存区域">跳过使用暂存区域</h4>
<p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。
Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给
<code>git commit</code> 加上 <code>-a</code> 选项，Git
就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过
<code>git add</code> 步骤：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;added new benchmarks&#x27;</span></span></span><br><span class="line">[master 83e38c7] added new benchmarks</span><br><span class="line"> 1 file changed, 5 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure>
<p>看到了吗？提交之前不再需要 <code>git add</code>
文件“CONTRIBUTING.md”了。</p>
<h4 id="移除文件">移除文件</h4>
<p>要从 Git
中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从<strong>暂存区域移除</strong>），然后提交。
可以用 <code>git rm</code>
命令完成此项工作，并<strong>连带从工作目录中删除指定的文件</strong>，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code>
时就会在 “Changes not staged for commit” 部分（也就是
<em>未暂存清单</em>）看到：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> PROJECTS.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    PROJECTS.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>然后再运行 <code>git rm</code> 记录此次移除文件的操作：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> PROJECTS.md</span></span><br><span class="line">rm &#x27;PROJECTS.md&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    deleted:    PROJECTS.md</span><br></pre></td></tr></table></figure>
<p>下一次提交时，该文件就不再纳入版本管理了。
如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项
<code>-f</code>（译注：即 force 的首字母）。
这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被
Git 恢复。</p>
<p>另外一种情况是，我们想<strong>把文件从 Git
仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中</strong>。
换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加
<code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆
<code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。
为达到这一目的，使用 <code>--cached</code> 选项：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> --cached README</span></span><br></pre></td></tr></table></figure>
<p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用
<code>glob</code> 模式。 比方说：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> <span class="built_in">log</span>/\*.<span class="built_in">log</span></span></span><br></pre></td></tr></table></figure>
<p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git
有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。
此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code>
的所有文件。 类似的比如：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> \*~</span></span><br></pre></td></tr></table></figure>
<p>该命令为删除以 <code>~</code> 结尾的所有文件。</p>
<h4 id="移动文件">移动文件</h4>
<p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git
中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。
不过 Git
非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p>
<p>既然如此，当你看到 Git 的 <code>mv</code> 命令时一定会困惑不已。 要在
Git 中对文件改名，可以这么做：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">mv</span> file_from file_to</span></span><br></pre></td></tr></table></figure>
<p>它会恰如预期般正常工作。
实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure>
<p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> README.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br></pre></td></tr></table></figure>
<p>如此分开操作，Git
也会意识到这是一次改名，所以不管何种方式结果都一样。
两者唯一的区别是，<code>mv</code>
是一条命令而另一种方式需要三条命令，直接用 <code>git mv</code>
轻便得多。
不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p>
<h3 id="查看提交历史">查看提交历史</h3>
<p>在提交了若干更新，又或者克隆了某个项目之后，你也许想<strong>回顾下提交历史</strong>。
完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。</p>
<p>接下来的例子会用我专门用于演示的 simplegit 项目，
运行下面的命令获取该项目源代码：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/schacon/simplegit-progit</span><br></pre></td></tr></table></figure>
<p>然后在此项目中运行 git log，应该会看到下面的输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>
<p>默认不用任何参数的话，<code>git log</code>
会按提交时间列出所有的更新，最近的更新排在最上面。
正如你所看到的，这个命令会列出每个提交的 SHA-1
校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<p><code>git log</code> 有许多选项可以帮助你搜寻你所要找的提交，
接下来我们介绍些最常用的。</p>
<p>一个常用的选项是 <code>-p</code>，用来显示每次提交的内容差异。
你也可以加上 <code>-2</code> 来仅显示最近两次提交：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -p -2</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require &#x27;rake/gempackagetask&#x27;</span><br><span class="line"> spec = Gem::Specification.new do |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   &quot;simplegit&quot;</span><br><span class="line">-    s.version   =   &quot;0.1.0&quot;</span><br><span class="line">+    s.version   =   &quot;0.1.1&quot;</span><br><span class="line">     s.author    =   &quot;Scott Chacon&quot;</span><br><span class="line">     s.email     =   &quot;schacon@gee-mail.com&quot;</span><br><span class="line">     s.summary   =   &quot;A simple gem for using Git in Ruby code.&quot;</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index a0a60ae..47c6340 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -18,8 +18,3 @@ class SimpleGit</span><br><span class="line">     end</span><br><span class="line"></span><br><span class="line"> end</span><br><span class="line">-</span><br><span class="line">-if $0 == __FILE__</span><br><span class="line">-  git = SimpleGit.new</span><br><span class="line">-  puts git.show</span><br><span class="line">-end</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure>
<p>该选项除了显示基本信息之外，<strong>还附带了每次 commit
的变化</strong>。 当进行代码审查，或者快速浏览某个搭档提交的 commit
所带来的变化的时候，这个参数就非常有用了。 你也可以为
<code>git log</code> 附带一系列的总结性选项。
比如说，如果你想看到每次提交的简略的统计信息，你可以使用
<code>--stat</code> 选项：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line"> Rakefile | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line"> lib/simplegit.rb | 5 -----</span><br><span class="line"> 1 file changed, 5 deletions(-)</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> README           |  6 ++++++</span><br><span class="line"> Rakefile         | 23 +++++++++++++++++++++++</span><br><span class="line"> lib/simplegit.rb | 25 +++++++++++++++++++++++++</span><br><span class="line"> 3 files changed, 54 insertions(+)</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，<code>--stat</code>
选项在每次提交的下面列出额所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。
在每次提交的最后还有一个总结。</p>
<p>另外一个常用的选项是 <code>--pretty</code>。
这个选项可以指定使用不同于默认格式的方式展示提交历史。
这个选项有一些内建的子选项供你使用。 比如用 <code>oneline</code>
将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有
<code>short</code>，<code>full</code> 和 <code>fuller</code>
可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949 changed the version number</span><br><span class="line">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test</span><br><span class="line">a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</span><br></pre></td></tr></table></figure>
<p>但最有意思的是 format，可以定制要显示的记录格式。
这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着 Git
的更新而发生改变：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h - %an, %ar : %s&quot;</span></span></span><br><span class="line">ca82a6d - Scott Chacon, 6 years ago : changed the version number</span><br><span class="line">085bb3b - Scott Chacon, 6 years ago : removed unnecessary test</span><br><span class="line">a11bef0 - Scott Chacon, 6 years ago : first commit</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.progit.cn/#pretty_format"><code>git log --pretty=format</code>
常用的选项</a> 列出了常用的格式占位符写法及其代表的意义。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">选项</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>%H</code></td>
<td style="text-align: left;">提交对象（commit）的完整哈希字串</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%h</code></td>
<td style="text-align: left;">提交对象的简短哈希字串</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%T</code></td>
<td style="text-align: left;">树对象（tree）的完整哈希字串</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%t</code></td>
<td style="text-align: left;">树对象的简短哈希字串</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%P</code></td>
<td style="text-align: left;">父对象（parent）的完整哈希字串</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%p</code></td>
<td style="text-align: left;">父对象的简短哈希字串</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%an</code></td>
<td style="text-align: left;">作者（author）的名字</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%ae</code></td>
<td style="text-align: left;">作者的电子邮件地址</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%ad</code></td>
<td style="text-align: left;">作者修订日期（可以用 --date=
选项定制格式）</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%ar</code></td>
<td style="text-align: left;">作者修订日期，按多久以前的方式显示</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%cn</code></td>
<td style="text-align: left;">提交者（committer）的名字</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%ce</code></td>
<td style="text-align: left;">提交者的电子邮件地址</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%cd</code></td>
<td style="text-align: left;">提交日期</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%cr</code></td>
<td style="text-align: left;">提交日期，按多久以前的方式显示</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%s</code></td>
<td style="text-align: left;">提交说明</td>
</tr>
</tbody>
</table>
<p>你一定奇怪 <em>作者</em> 和 <em>提交者</em> 之间究竟有何差别，
其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。
所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。
我们会在 <a href="https://www.progit.cn/#_distributed_git">分布式
Git</a> 再详细介绍两者之间的细微差别。</p>
<p>当 oneline 或 format 与另一个 <code>log</code> 选项
<code>--graph</code> 结合使用时尤其有用。
这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> --graph</span></span><br><span class="line">* 2d3acf9 ignore errors from SIGCHLD on trap</span><br><span class="line">*  5e3ee11 Merge branch &#x27;master&#x27; of git://github.com/dustin/grit</span><br><span class="line">|\</span><br><span class="line">| * 420eac9 Added a method for getting the current branch.</span><br><span class="line">* | 30e367c timeout code and tests</span><br><span class="line">* | 5a09431 add timeout protection to grit</span><br><span class="line">* | e1193f8 support for heads with slashes in them</span><br><span class="line">|/</span><br><span class="line">* d6016bc require time for xmlschema</span><br><span class="line">*  11d191e Merge branch &#x27;defunkt&#x27; into local</span><br></pre></td></tr></table></figure>
<p>这种输出类型会在我们下一章学完分支与合并以后变得更加有趣。</p>
<p>以上只是简单介绍了一些 <code>git log</code> 命令支持的选项。 <a
href="https://www.progit.cn/#log_options"><code>git log</code>
的常用选项</a>
列出了我们目前涉及到的和没涉及到的选项，以及它们是如何影响 log
命令的输出的：</p>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">选项</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>-p</code></td>
<td style="text-align: left;">按补丁格式显示每个更新之间的差异。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--stat</code></td>
<td style="text-align: left;">显示每次更新的文件修改统计信息。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--shortstat</code></td>
<td style="text-align: left;">只显示 --stat
中最后的行数修改添加移除统计。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--name-only</code></td>
<td style="text-align: left;">仅在提交信息后显示已修改的文件清单。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--name-status</code></td>
<td style="text-align: left;">显示新增、修改、删除的文件清单。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--abbrev-commit</code></td>
<td style="text-align: left;">仅显示 SHA-1 的前几个字符，而非所有的 40
个字符。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--relative-date</code></td>
<td style="text-align: left;">使用较短的相对时间显示（比如，“2 weeks
ago”）。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--graph</code></td>
<td style="text-align: left;">显示 ASCII 图形表示的分支合并历史。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--pretty</code></td>
<td
style="text-align: left;">使用其他格式显示历史提交信息。可用的选项包括
oneline，short，full，fuller 和 format（后跟指定格式）。</td>
</tr>
</tbody>
</table>
<h4 id="限制输出长度">限制输出长度</h4>
<p>除了定制输出格式的选项之外，<code>git log</code>
还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。
之前你已经看到过 <code>-2</code> 了，它只显示最近的两条提交，
实际上，这是 <code>-&lt;n&gt;</code> 选项的写法，其中的 <code>n</code>
可以是任何整数，表示仅显示最近的若干条提交。
不过实践中我们是不太用这个选项的，Git
在输出所有提交时会自动调用分页程序，所以你一次只会看到一页的内容。</p>
<p>另外还有按照时间作限制的选项，比如 <code>--since</code> 和
<code>--until</code> 也很有用。
例如，下面的命令列出所有最近两周内的提交：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --since=2.weeks</span></span><br></pre></td></tr></table></figure>
<p>这个命令可以在多种格式下工作，比如说具体的某一天
<code>"2008-01-15"</code>，或者是相对地多久以前
<code>"2 years 1 day 3 minutes ago"</code>。</p>
<p>还可以给出若干搜索条件，列出符合的提交。 用 <code>--author</code>
选项显示指定作者的提交，用 <code>--grep</code>
选项搜索提交说明中的关键字。
（请注意，如果要得到同时满足这两个选项搜索条件的提交，就必须用
<code>--all-match</code>
选项。否则，满足任意一个条件的提交都会被匹配出来）</p>
<p>另一个非常有用的筛选选项是
<code>-S</code>，可以列出那些添加或移除了某些字符串的提交。
比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -Sfunction_name</span></span><br></pre></td></tr></table></figure>
<p>最后一个很实用的 <code>git log</code> 选项是路径（path），
如果只关心某些文件或者目录的历史提交，可以在 git log
选项的最后指定它们的路径。
因为是放在最后位置上的选项，所以用两个短划线（--）隔开之前的选项和后面限定的路径名。</p>
<p>在 <a href="https://www.progit.cn/#limit_options">限制
<code>git log</code> 输出的选项</a> 中列出了常用的选项</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">选项</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>-(n)</code></td>
<td style="text-align: left;">仅显示最近的 n 条提交</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--since</code>,
<code>--after</code></td>
<td style="text-align: left;">仅显示指定时间之后的提交。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--until</code>,
<code>--before</code></td>
<td style="text-align: left;">仅显示指定时间之前的提交。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--author</code></td>
<td style="text-align: left;">仅显示指定作者相关的提交。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--committer</code></td>
<td style="text-align: left;">仅显示指定提交者相关的提交。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--grep</code></td>
<td style="text-align: left;">仅显示含指定关键字的提交</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-S</code></td>
<td style="text-align: left;">仅显示添加或移除了某个关键字的提交</td>
</tr>
</tbody>
</table>
<p>来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio
Hamano 提交的但未合并的测试文件，可以用下面的查询命令：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=<span class="string">&quot;%h - %s&quot;</span> --author=gitster --since=<span class="string">&quot;2008-10-01&quot;</span> \</span></span><br><span class="line"><span class="language-bash">   --before=<span class="string">&quot;2008-11-01&quot;</span> --no-merges -- t/</span></span><br><span class="line">5610e3b - Fix testcase failure when extended attributes are in use</span><br><span class="line">acd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;() API</span><br><span class="line">f563754 - demonstrate breakage of detached checkout with symbolic link HEAD</span><br><span class="line">d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths</span><br><span class="line">51a94af - Fix &quot;checkout --track -b newbranch&quot; on detached HEAD</span><br><span class="line">b0ad11e - pull: allow &quot;git pull origin $something:$current_branch&quot; into an unborn branch</span><br></pre></td></tr></table></figure>
<p>在近 40000 条提交中，上面的输出仅列出了符合条件的 6 条记录。</p>
<h3 id="撤消操作">撤消操作</h3>
<p>在任何一个阶段，你都有可能想要撤消某些操作。
这里，我们将会学习几个撤消你所做修改的基本工具。
<strong>注意，有些撤消操作是不可逆的。</strong> 这是在使用 Git
的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。
此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure>
<p>这个命令会将暂存区中的文件提交。
如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p>
<p>文本编辑器启动后，可以看到之前的提交信息。
编辑后保存会覆盖原来的提交信息。</p>
<p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;initial commit&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add forgotten_file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure>
<p>最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</p>
<h4 id="取消暂存的文件">取消暂存的文件</h4>
<p>接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。
这些命令在修改文件状态的同时，也会提示如何撤消操作。
例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了
<code>git add *</code> 暂存了它们两个。 如何只取消暂存两个中的一个呢？
<code>git status</code> 命令提示了你：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add *</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>在 “Changes to be committed” 文字正下方，提示使用
<code>git reset HEAD &lt;file&gt;...</code> 来取消暂存。
所以，我们可以这样来取消暂存 <code>CONTRIBUTING.md</code> 文件：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD CONTRIBUTING.md</span></span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	CONTRIBUTING.md</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>这个命令有点儿奇怪，但是起作用了。 <code>CONTRIBUTING.md</code>
文件已经是修改未暂存的状态了。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>虽然在调用时加上 <code>--hard</code> 选项<strong>可以</strong>令
<code>git reset</code>
成为一个危险的命令（译注：可能导致工作目录中所有当前进度丢失！），但本例中工作目录内的文件并不会被修改。
<u>不加选项地调用 <code>git reset</code> 并不危险 —
它只会修改暂存区域。</u></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>到目前为止这个神奇的调用就是你需要对 <code>git reset</code>
命令全部的了解。我们将会在 <a
href="https://www.progit.cn/#_git_reset">重置揭密</a> 中了解
<code>reset</code> 的更多细节以及如何掌握它做一些真正有趣的事。</p>
<h4 id="撤消对文件的修改">撤消对文件的修改</h4>
<p>如果你并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改怎么办？
你该如何方便地撤消修改 -
将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？
幸运的是，<code>git status</code> 也告诉了你应该如何做。
在最后一个例子中，未暂存区域是这样：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>它非常清楚地告诉了你如何撤消之前所做的修改。
让我们来按照提示执行：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure>
<p>可以看到那些修改已经被撤消了。</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>IMPORTANT</th>
<th>你需要知道 <code>git checkout -- [file]</code>
是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 -
你只是拷贝了另一个文件来覆盖它。
除非你确实清楚不想要那个文件了，否则不要使用这个命令。</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在
<a href="https://www.progit.cn/#_git_branching">Git 分支</a>
介绍保存进度与分支；这些通常是更好的做法。</p>
<p>记住，在 Git 中任何 <em>已提交的</em> 东西几乎总是可以恢复的。
甚至那些被删除的分支中的提交或使用 <code>--amend</code>
选项覆盖的提交也可以恢复（阅读 <a
href="https://www.progit.cn/#_data_recovery">数据恢复</a>
了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。</p>
<h3 id="远程仓库的使用">远程仓库的使用</h3>
<p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。
远程仓库是指托管在因特网或其他网络中的你的项目的版本库。
你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。
与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。
管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。
在本节中，我们将介绍一部分远程管理的技能。</p>
<h4 id="查看远程仓库">查看远程仓库</h4>
<p>如果想查看你已经配置的远程仓库服务器，可以运行
<code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。
如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git
给你克隆的仓库服务器的默认名字：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/schacon/ticgit</span></span><br><span class="line">Cloning into &#x27;ticgit&#x27;...</span><br><span class="line">remote: Reusing existing pack: 1857, done.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (772/772), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ticgit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git
保存的简写与其对应的 URL。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin	https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure>
<p>如果你的远程仓库不止一个，该命令会将它们全部列出。
例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> grit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (fetch)</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (push)</span><br><span class="line">cho45     https://github.com/cho45/grit (fetch)</span><br><span class="line">cho45     https://github.com/cho45/grit (push)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (fetch)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (push)</span><br><span class="line">koke      git://github.com/koke/grit.git (fetch)</span><br><span class="line">koke      git://github.com/koke/grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (push)</span><br></pre></td></tr></table></figure>
<p>这样我们可以轻松拉取其中任何一个用户的贡献。
此外，我们大概还会有某些远程仓库的推送权限，虽然我们目前还不会在此介绍。</p>
<p>注意这些远程仓库使用了不同的协议；我们将会在 <a
href="https://www.progit.cn/#_git_on_the_server">在服务器上搭建 Git</a>
中了解关于它们的更多信息。</p>
<h4 id="添加远程仓库">添加远程仓库</h4>
<p>我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。
运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code>
添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add pb https://github.com/paulboone/ticgit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin	https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit (push)</span><br><span class="line">pb	https://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pb	https://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure>
<p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。
例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行
<code>git fetch pb</code>：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch pb</span></span><br><span class="line">remote: Counting objects: 43, done.</span><br><span class="line">remote: Compressing objects: 100% (36/36), done.</span><br><span class="line">remote: Total 43 (delta 10), reused 31 (delta 5)</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure>
<p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到
-
你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。
（我们将会在 <a href="https://www.progit.cn/#_git_branching">Git
分支</a> 中详细介绍什么是分支以及如何使用分支。）</p>
<h4 id="从远程仓库中抓取与拉取">从远程仓库中抓取与拉取</h4>
<p>就如刚才所见，从远程仓库中获得数据，可以执行：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch [remote-name]</span></span><br></pre></td></tr></table></figure>
<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。
执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p>如果你使用 <code>clone</code>
命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin”
为简写。 所以，<code>git fetch origin</code>
会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意
<code>git fetch</code> 命令会将数据拉取到你的本地仓库 -
它并不会自动合并或修改你当前的工作。
当准备好时你必须手动将其合并入你的工作。</p>
<p>如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 <a
href="https://www.progit.cn/#_git_branching">Git 分支</a>
了解更多信息），可以使用 <code>git pull</code>
命令来自动的抓取然后合并远程分支到当前分支。
这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，<code>git clone</code>
命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master
分支（或不管是什么名字的默认分支）。 运行 <code>git pull</code>
通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<h4 id="推送到远程仓库">推送到远程仓库</h4>
<p>当你想分享你的项目时，必须将其推送到上游。
这个命令很简单：<code>git push [remote-name] [branch-name]</code>。
当你想要将 master 分支推送到 <code>origin</code>
服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master</span></span><br></pre></td></tr></table></figure>
<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。
当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。
你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 阅读 <a
href="https://www.progit.cn/#_git_branching">Git 分支</a>
了解如何推送到远程仓库服务器的详细信息。</p>
<h4 id="查看远程仓库-1">查看远程仓库</h4>
<p>如果想要查看某一个远程仓库的更多信息，可以使用
<code>git remote show [remote-name]</code> 命令。
如果想以一个特定的缩写名运行这个命令，例如
<code>origin</code>，会得到像下面类似的信息：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit</span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                               tracked</span><br><span class="line">    dev-branch                           tracked</span><br><span class="line">  Local branch configured for &#x27;git pull&#x27;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#x27;git push&#x27;:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure>
<p>它同样会列出远程仓库的 URL 与跟踪分支的信息。
这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git
pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master
分支。 它也会列出拉取到的所有远程引用。</p>
<p>这是一个经常遇到的简单例子。 如果你是 Git
的重度使用者，那么还可以通过 <code>git remote show</code>
看到更多的信息。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  URL: https://github.com/my-org/complex-project</span><br><span class="line">  Fetch URL: https://github.com/my-org/complex-project</span><br><span class="line">  Push  URL: https://github.com/my-org/complex-project</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                           tracked</span><br><span class="line">    dev-branch                       tracked</span><br><span class="line">    markdown-strip                   tracked</span><br><span class="line">    issue-43                         new (next fetch will store in remotes/origin)</span><br><span class="line">    issue-45                         new (next fetch will store in remotes/origin)</span><br><span class="line">    refs/remotes/origin/issue-11     stale (use &#x27;git remote prune&#x27; to remove)</span><br><span class="line">  Local branches configured for &#x27;git pull&#x27;:</span><br><span class="line">    dev-branch merges with remote dev-branch</span><br><span class="line">    master     merges with remote master</span><br><span class="line">  Local refs configured for &#x27;git push&#x27;:</span><br><span class="line">    dev-branch                     pushes to dev-branch                     (up to date)</span><br><span class="line">    markdown-strip                 pushes to markdown-strip                 (up to date)</span><br><span class="line">    master                         pushes to master                         (up to date)</span><br></pre></td></tr></table></figure>
<p>这个命令列出了当你在特定的分支上执行 <code>git push</code>
会自动地推送到哪一个远程分支。
它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行
<code>git pull</code> 时哪些分支会自动合并。</p>
<h4 id="远程仓库的移除与重命名">远程仓库的移除与重命名</h4>
<p>如果想要重命名引用的名字可以运行 <code>git remote rename</code>
去修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为
<code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote rename pb paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure>
<p>值得注意的是这同样也会修改你的远程分支名字。 那些过去引用
<code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p>
<p>如果因为一些原因想要移除一个远程仓库 -
你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了
- 可以使用 <code>git remote rm</code> ：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote <span class="built_in">rm</span> paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<h3 id="打标签">打标签</h3>
<p>像其他版本控制系统（VCS）一样，Git
可以给历史中的某一个提交打上标签，以示重要。
比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。
在本节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。</p>
<h4 id="列出标签">列出标签</h4>
<p>在 Git 中列出已有的标签是非常简单直观的。 只需要输入
<code>git tag</code>：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br></pre></td></tr></table></figure>
<p>这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。</p>
<p>你也可以使用特定的模式查找标签。 例如，Git
自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5
系列感兴趣，可以运行：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -l <span class="string">&#x27;v1.8.5*&#x27;</span></span></span><br><span class="line">v1.8.5</span><br><span class="line">v1.8.5-rc0</span><br><span class="line">v1.8.5-rc1</span><br><span class="line">v1.8.5-rc2</span><br><span class="line">v1.8.5-rc3</span><br><span class="line">v1.8.5.1</span><br><span class="line">v1.8.5.2</span><br><span class="line">v1.8.5.3</span><br><span class="line">v1.8.5.4</span><br><span class="line">v1.8.5.5</span><br></pre></td></tr></table></figure>
<h4 id="创建标签">创建标签</h4>
<p>Git
使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p>
<p>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</p>
<p>然而，附注标签是存储在 Git 数据库中的一个完整对象。
它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用
GNU Privacy Guard （GPG）签名与验证。
通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p>
<h4 id="附注标签">附注标签</h4>
<p>在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行
<code>tag</code> 命令时指定 <code>-a</code> 选项：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.4 -m <span class="string">&#x27;my version 1.4&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure>
<p><code>-m</code> 选项指定了一条将会存储在标签中的信息。
如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。</p>
<p>通过使用 <code>git show</code>
命令可以看到标签信息与对应的提交信息：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.4</span></span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:19:12 2014 -0700</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure>
<p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p>
<h4 id="轻量标签">轻量标签</h4>
<p>另一种给提交打标签的方式是使用轻量标签。
轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。
创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或
<code>-m</code> 选项，只需要提供标签名字：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag v1.4-lw</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br></pre></td></tr></table></figure>
<p>这时，如果在标签上运行
<code>git show</code>，你不会看到额外的标签信息。
命令只会显示出提交信息：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.4-lw</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure>
<h4 id="后期打标签">后期打标签</h4>
<p>你也可以对过去的提交打标签。 假设提交历史是这样的：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#x27;experiment&#x27;</span><br><span class="line">a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</span><br><span class="line">0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</span><br><span class="line">6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#x27;experiment&#x27;</span><br><span class="line">0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function</span><br><span class="line">4682c3261057305bdd616e23b64b0857d832627b added a todo file</span><br><span class="line">166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br></pre></td></tr></table></figure>
<p>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile”
提交。 你可以在之后补上标签。
要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.2 9fceb02</span></span><br></pre></td></tr></table></figure>
<p>可以看到你已经在那次提交上打上标签了：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.2</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.2</span></span><br><span class="line">tag v1.2</span><br><span class="line">Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Feb 9 15:32:16 2009 -0800</span><br><span class="line"></span><br><span class="line">version 1.2</span><br><span class="line">commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sun Apr 27 20:43:35 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="共享标签">共享标签</h4>
<p>默认情况下，<code>git push</code>
命令并不会传送标签到远程仓库服务器上。
在创建完标签后你必须显式地推送标签到共享服务器上。
这个过程就像共享远程分支一样 - 你可以运行
<code>git push origin [tagname]</code>。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin v1.5</span></span><br><span class="line">Counting objects: 14, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (12/12), done.</span><br><span class="line">Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.</span><br><span class="line">Total 14 (delta 3), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure>
<p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的
<code>git push</code> 命令。
这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --tags</span></span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.4 -&gt; v1.4</span><br><span class="line"> * [new tag]         v1.4-lw -&gt; v1.4-lw</span><br></pre></td></tr></table></figure>
<p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p>
<h4 id="检出标签">检出标签</h4>
<p>在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。
如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用
<code>git checkout -b [branchname] [tagname]</code>
在特定的标签上创建一个新分支：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b version2 v2.0.0</span></span><br><span class="line">Switched to a new branch &#x27;version2&#x27;</span><br></pre></td></tr></table></figure>
<p>当然，如果在这之后又进行了一次提交，<code>version2</code>
分支会因为改动向前移动了，那么 <code>version2</code> 分支就会和
<code>v2.0.0</code> 标签稍微有些不同，这时就应该当心了。</p>
<h3 id="git-别名">Git 别名</h3>
<p>在我们结束本章 Git 基础之前，正好有一个小技巧可以使你的 Git
体验更简单、容易、熟悉：别名。
我们不会在之后的章节中引用到或假定你使用过它们，但是你大概应该知道如何使用它们。</p>
<p>Git 并不会在你输入部分命令时自动推断出你想要的命令。
如果不想每次都输入完整的 Git 命令，可以通过 <code>git config</code>
文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.co checkout</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.br branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.ci commit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.st status</span></span><br></pre></td></tr></table></figure>
<p>这意味着，当要输入 <code>git commit</code> 时，只需要输入
<code>git ci</code>。 随着你继续不断地使用
Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。</p>
<p>在创建你认为应该存在的命令时这个技术会很有用。
例如，为了解决取消暂存文件的易用性问题，可以向 Git
中添加你自己的取消暂存别名：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.unstage <span class="string">&#x27;reset HEAD --&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>这会使下面的两个命令等价：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git unstage fileA</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD -- fileA</span></span><br></pre></td></tr></table></figure>
<p>这样看起来更清楚一些。 通常也会添加一个 <code>last</code>
命令，像这样：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.last <span class="string">&#x27;log -1 HEAD&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>这样，可以轻松地看到最后一次提交：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git last</span></span><br><span class="line">commit 66938dae3329c7aebe598c2246a8e6af90d04646</span><br><span class="line">Author: Josh Goebel &lt;dreamer3@example.com&gt;</span><br><span class="line">Date:   Tue Aug 26 19:48:51 2008 +0800</span><br><span class="line"></span><br><span class="line">    test for current head</span><br><span class="line"></span><br><span class="line">    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出，Git 只是简单地将别名替换为对应的命令。
然而，你可能想要执行外部命令，而不是一个 Git 子命令。
如果是那样的话，可以在命令前面加入 <code>!</code> 符号。
如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将
<code>git visual</code> 定义为 <code>gitk</code> 的别名：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.visual <span class="string">&#x27;!gitk&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>现在，你可以完成所有基本的 Git
本地操作－创建或者克隆一个仓库、做更改、暂存并提交这些更改、浏览你的仓库从创建到现在的所有更改的历史。
下一步，本书将介绍 Git 的杀手级特性：分支模型。</p>
<h2 id="git-分支">Git 分支</h2>
<p>在很多版本控制系统中，使用分支常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p>
<p>有人把 Git 的分支模型称为它的`‘必杀技特性’'。 Git
创建新分支速度快，切换便捷。 与许多其它版本控制系统不同，Git
<strong>鼓励</strong>在工作流程中频繁地使用分支与合并。
理解和精通这一特性，你便会意识到 Git
是如此的强大而又独特，并且从此真正改变你的开发方式。</p>
<h3 id="分支简介">分支简介</h3>
<p>为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git
是如何保存数据的。</p>
<p>或许你还记得 <a
href="https://www.progit.cn/#_getting_started">起步</a> 的内容，Git
保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。</p>
<p>在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git
保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。
但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及<strong>指向它的父对象的指针</strong>。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，</p>
<p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。
暂存操作会为每一个文件计算校验和（使用我们在 <a
href="https://www.progit.cn/#_getting_started">起步</a> 中提到的 SHA-1
哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob
对象来保存它们），最终将校验和加入到暂存区域等待提交：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README test.rb LICENSE</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;The initial commit of my project&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>当使用 <code>git commit</code> 进行提交操作时，Git
会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git
仓库中这些校验和保存为树对象。 随后，Git
便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git
就可以在需要的时候重现此次保存的快照。</p>
<p>现在，Git 仓库中有<strong>五个对象</strong>：三个 blob
对象（保存着文件快照）、一个树对象（记录着目录结构和 blob
对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p>
<figure>
<img src="https://www.progit.cn/images/commit-and-tree.png"
alt="首次提交对象及其树结构。" />
<figcaption aria-hidden="true">首次提交对象及其树结构。</figcaption>
</figure>
<p>Figure 9. 首次提交对象及其树结构</p>
<p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p>
<figure>
<img src="https://www.progit.cn/images/commits-and-parents.png"
alt="提交对象及其父对象。" />
<figcaption aria-hidden="true">提交对象及其父对象。</figcaption>
</figure>
<p>Figure 10. 提交对象及其父对象</p>
<p><strong>Git 的分支，其实本质上仅仅是指向提交对象的可变指针</strong>。
Git 的默认分支名字是 <code>master</code>。
在多次提交操作之后，你其实已经有一个指向最后那个提交对象的
<code>master</code> 分支。 它会在每次的提交操作中自动向前移动。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>Git 的 “master” 分支并不是一个特殊分支。
它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master
分支，是因为 <code>git init</code>
命令默认创建它，并且大多数人都懒得去改动它。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure>
<img src="https://www.progit.cn/images/branch-and-history.png"
alt="分支及其提交历史。" />
<figcaption aria-hidden="true">分支及其提交历史。</figcaption>
</figure>
<p>Figure 11. 分支及其提交历史</p>
<h4 id="分支创建">分支创建</h4>
<p>Git 是怎么创建新分支的呢？
很简单，<strong>它只是为你创建了一个可以移动的新的指针</strong>。
比如，创建一个 testing 分支， 你需要使用 <code>git branch</code>
命令：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch testing</span></span><br></pre></td></tr></table></figure>
<p><strong>这会在当前所在的提交对象上创建一个指针</strong>。</p>
<figure>
<img src="https://www.progit.cn/images/two-branches.png"
alt="两个指向相同提交历史的分支。" />
<figcaption aria-hidden="true">两个指向相同提交历史的分支。</figcaption>
</figure>
<p>Figure 12. 两个指向相同提交历史的分支</p>
<p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为
<code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如
Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git
中，它是一个指针，指向当前所在的本地分支（译注：<strong>将
<code>HEAD</code> 想象为当前分支的别名</strong>）。 在本例中，你仍然在
<code>master</code> 分支上。 因为 <code>git branch</code>
命令<strong>仅仅 <em>创建</em></strong>
一个新分支，并不会自动切换到新分支中去。</p>
<figure>
<img src="https://www.progit.cn/images/head-to-master.png"
alt="HEAD 指向当前所在的分支。" />
<figcaption aria-hidden="true">HEAD 指向当前所在的分支。</figcaption>
</figure>
<p>Figure 13. HEAD 指向当前所在的分支</p>
<p>你可以简单地使用 <code>git log</code>
命令查看各个分支当前所指的对象。 提供这一功能的参数是
<code>--decorate</code>。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --decorate</span></span><br><span class="line">f30ab (HEAD, master, testing) add feature #32 - ability to add new</span><br><span class="line">34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">98ca9 initial commit of my project</span><br></pre></td></tr></table></figure>
<p>正如你所见，当前 “master” 和 “testing” 分支均指向校验和以
<code>f30ab</code> 开头的提交对象。</p>
<h4 id="分支切换">分支切换</h4>
<p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。
我们现在切换到新创建的 <code>testing</code> 分支去：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout testing</span></span><br></pre></td></tr></table></figure>
<p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p>
<figure>
<img src="https://www.progit.cn/images/head-to-testing.png"
alt="HEAD 指向当前所在的分支。" />
<figcaption aria-hidden="true">HEAD 指向当前所在的分支。</figcaption>
</figure>
<p>Figure 14. HEAD 指向当前所在的分支</p>
<p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim test.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;made a change&#x27;</span></span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/advance-testing.png"
alt="HEAD 分支随着提交操作自动向前移动。" />
<figcaption aria-hidden="true">HEAD
分支随着提交操作自动向前移动。</figcaption>
</figure>
<p>Figure 15. HEAD 分支随着提交操作自动向前移动</p>
<p>如图所示，你的 <code>testing</code> 分支向前移动了，但是
<code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code>
时所指的对象。 这就有意思了，现在我们切换回 <code>master</code>
分支看看：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/checkout-master.png"
alt="检出时 HEAD 随之移动。" />
<figcaption aria-hidden="true">检出时 HEAD 随之移动。</figcaption>
</figure>
<p>Figure 16. 检出时 HEAD 随之移动</p>
<p><strong>这条命令做了两件事</strong>。 一是使 HEAD 指回
<code>master</code> 分支，二是将工作目录恢复成 <code>master</code>
分支所指向的快照内容。
也就是说，你现在做修改的话，项目将始于一个较旧的版本。
本质上来讲，这就是忽略 <code>testing</code>
分支所做的修改，以便于向另一个方向进行开发。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>分支切换会改变你工作目录中的文件。在切换分支时，一定要注意你工作目录里的文件会被改变。
如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。
如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>我们不妨再稍微做些修改并提交：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim test.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;made other changes&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>现在，这个项目的提交历史已经产生了分叉（参见 <a
href="https://www.progit.cn/#divergent_history">项目分叉历史</a>）。
因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回
master 分支进行了另外一些工作。
上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。
而所有这些工作，你需要的命令只有
<code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p>
<figure>
<img src="https://www.progit.cn/images/advance-master.png"
alt="项目分叉历史。" />
<figcaption aria-hidden="true">项目分叉历史。</figcaption>
</figure>
<p>Figure 17. 项目分叉历史</p>
<p>你可以简单地使用 <code>git log</code> 命令查看分叉历史。 运行
<code>git log --oneline --decorate --graph --all</code>
，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --decorate --graph --all</span></span><br><span class="line">* c2b9e (HEAD, master) made other changes</span><br><span class="line">| * 87ab2 (testing) made a change</span><br><span class="line">|/</span><br><span class="line">* f30ab add feature #32 - ability to add new formats to the</span><br><span class="line">* 34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">* 98ca9 initial commit of my project</span><br></pre></td></tr></table></figure>
<p>由于 Git 的分支<strong>实质上仅是包含所指对象校验和（长度为 40 的
SHA-1 值字符串）的文件</strong>，所以它的创建和销毁都异常高效。
创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1
个换行符），如此的简单能不快吗？</p>
<p>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。
完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。而在
Git 中，任何规模的项目都能在瞬间创建新分支。
同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。
这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。</p>
<p>接下来，让我们看看你为什么应该这样做。</p>
<h3 id="分支的新建与合并">分支的新建与合并</h3>
<p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。
你将经历如下步骤：</p>
<ol type="1">
<li>开发某个网站。</li>
<li>为实现某个新的需求，创建一个分支。</li>
<li>在这个分支上开展工作。</li>
</ol>
<p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。
你将按照如下方式来处理：</p>
<ol type="1">
<li>切换到你的线上分支（production branch）。</li>
<li>为这个紧急任务新建一个分支，并在其中修复它。</li>
<li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li>
<li>切换回你最初工作的分支上，继续工作。</li>
</ol>
<h4 id="新建分支">新建分支</h4>
<p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p>
<figure>
<img src="https://www.progit.cn/images/basic-branching-1.png"
alt="一个简单的提交历史。" />
<figcaption aria-hidden="true">一个简单的提交历史。</figcaption>
</figure>
<p>Figure 18. 一个简单提交历史</p>
<p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。
想要新建一个分支并同时切换到那个分支上，你可以运行一个带有
<code>-b</code> 参数的 <code>git checkout</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b iss53</span></span><br><span class="line">Switched to a new branch &quot;iss53&quot;</span><br></pre></td></tr></table></figure>
<p>它是下面两条命令的简写：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch iss53</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout iss53</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/basic-branching-2.png"
alt="创建一个新分支指针。" />
<figcaption aria-hidden="true">创建一个新分支指针。</figcaption>
</figure>
<p>Figure 19. 创建一个新分支指针</p>
<p>你继续在 #53 问题上工作，并且做了一些提交。
在此过程中，<code>iss53</code>
分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的
<code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim index.html</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;added a new footer [issue 53]&#x27;</span></span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/basic-branching-3.png"
alt="iss53 分支随着工作的进展向前推进。" />
<figcaption aria-hidden="true">iss53
分支随着工作的进展向前推进。</figcaption>
</figure>
<p>Figure 20. iss53 分支随着工作的进展向前推进</p>
<p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git
的帮助，你不必把这个紧急问题和 <code>iss53</code>
的修改混在一起，你也不需要花大力气来还原关于 53#
问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。
你所要做的仅仅是切换回 <code>master</code> 分支。</p>
<p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止
Git 切换到该分支。
最好的方法是，在你切换分支之前，保持好一个干净的状态。
有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit
amending）），我们会在 <a
href="https://www.progit.cn/#_git_stashing">储藏与清理</a>
中看到关于这两个命令的介绍。
现在，我们假设你已经把你的修改全部提交了，这时你可以切换回
<code>master</code> 分支了：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure>
<p>这个时候，你的工作目录和你在开始 #53
问题之前一模一样，现在你可以专心修复紧急问题了。
<strong>请牢记：当你切换分支的时候，Git
会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。</strong>
Git
会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p>
<p>接下来，你要修复这个紧急问题。
让我们建立一个针对该紧急问题的分支（hotfix
branch），在该分支上工作直到问题解决：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b hotfix</span></span><br><span class="line">Switched to a new branch &#x27;hotfix&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim index.html</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;fixed the broken email address&#x27;</span></span></span><br><span class="line">[hotfix 1fb7853] fixed the broken email address</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/basic-branching-4.png"
alt="基于 master 分支的紧急问题分支（hotfix branch）。" />
<figcaption aria-hidden="true">基于 <code>master</code>
分支的紧急问题分支（hotfix branch）。</figcaption>
</figure>
<p>Figure 21. 基于 <code>master</code> 分支的紧急问题分支
<code>hotfix branch</code></p>
<p>你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的
<code>master</code> 分支来部署到线上。 你可以使用 <code>git merge</code>
命令来达到上述目的：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge hotfix</span></span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>
<p>在合并的时候，你应该注意到了"快进<strong>（fast-forward）</strong>"这个词。
由于当前 <code>master</code> 分支所指向的提交是你当前提交（有关 hotfix
的提交）的直接上游，所以 Git 只是简单的将指针向前移动。
换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么
Git
在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做
“快进（fast-forward）”。</p>
<p>现在，最新的修改已经在 <code>master</code>
分支所指向的提交快照中，你可以着手发布该修复了。</p>
<figure>
<img src="https://www.progit.cn/images/basic-branching-5.png"
alt="master 被快进到 hotfix。" />
<figcaption aria-hidden="true"><code>master</code> 被快进到
<code>hotfix</code>。</figcaption>
</figure>
<p>Figure 22. <code>master</code> 被快进到 <code>hotfix</code></p>
<p>关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。
<strong>然而，你应该先删除 <code>hotfix</code>
分支，因为你已经不再需要它了 —— <code>master</code>
分支已经指向了同一个位置。</strong> 你可以使用带 <code>-d</code> 选项的
<code>git branch</code> 命令来删除分支：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d hotfix</span></span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure>
<p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53
问题的那个分支（iss53 分支）。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout iss53</span></span><br><span class="line">Switched to branch &quot;iss53&quot;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim index.html</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;finished the new footer [issue 53]&#x27;</span></span></span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/basic-branching-6.png"
alt="继续在 iss53 分支上的工作。" />
<figcaption aria-hidden="true">继续在 <code>iss53</code>
分支上的工作。</figcaption>
</figure>
<p>Figure 23. 继续在 <code>iss53</code> 分支上的工作</p>
<p>你在 <code>hotfix</code> 分支上所做的工作并没有包含到
<code>iss53</code> 分支中。 如果你需要拉取 <code>hotfix</code>
所做的修改，你可以使用 <code>git merge master</code> 命令<strong>将
<code>master</code> 分支合并入 <code>iss53</code> 分支，或者你也可以等到
<code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code>
分支</strong>。</p>
<h4 id="分支的合并">分支的合并</h4>
<p>假设你已经修正了 #53 问题，并且打算将你的工作合并入
<code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到
<code>master</code> 分支，这和之前你合并 <code>hotfix</code>
分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行
<code>git merge</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge iss53</span></span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>这和你之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。
在这种情况下，<strong>你的开发历史从一个更早的地方开始分叉开来</strong>（diverged）。
因为，<code>master</code> 分支所在提交并不是 <code>iss53</code>
分支所在提交的直接祖先，Git 不得不做一些额外的工作。
出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code>
和
<code>C5</code>）以及这两个分支的工作祖先（<code>C2</code>），做一个简单的<strong>三方合并</strong>。</p>
<figure>
<img src="https://www.progit.cn/images/basic-merging-1.png"
alt="一次典型合并中所用到的三个快照。" />
<figcaption
aria-hidden="true">一次典型合并中所用到的三个快照。</figcaption>
</figure>
<p>Figure 24. 一次典型合并中所用到的三个快照</p>
<p>和之前将分支指针向前推进所不同的是，Git
将此次三方合并的结果做了一个新的快照<strong>并且自动创建一个新的提交指向它</strong>。
这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p>
<figure>
<img src="https://www.progit.cn/images/basic-merging-2.png"
alt="一个合并提交。" />
<figcaption aria-hidden="true">一个合并提交。</figcaption>
</figure>
<p>Figure 25. 一个合并提交</p>
<p>需要指出的是，Git
会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的
CVS 系统或者 Subversion （1.5
版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。
Git 的这个优势使其在合并操作上比其他系统要简单很多。</p>
<p>既然你的修改已经合并进来了，你已经不再需要 <code>iss53</code>
分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d iss53</span></span><br></pre></td></tr></table></figure>
<h4 id="遇到冲突时的分支合并">遇到冲突时的分支合并</h4>
<p>有时候合并操作不会如此顺利。
<strong>如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git
就没法干净的合并它们。</strong> 如果你对 #53 问题的修改和有关
<code>hotfix</code>
的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge iss53</span></span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git
会暂停下来，等待你去解决合并产生的冲突。
你可以在合并冲突后的任意时刻使用 <code>git status</code>
命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git
会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。
出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">=======</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line"> please contact us at support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure>
<p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code>
分支所在的位置，因为你在运行 merge
命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code>
的上半部分），而 <code>iss53</code> 分支所指示的版本在
<code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由
<code>=======</code>
分割的两部分中的一个，或者你也可以自行合并这些内容。
例如，你可以通过把这段内容换成下面的样子来解决冲突：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述的冲突解决方案仅保留了其中一个分支的修改，并且
<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和
<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。
在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code>
命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git
就会将它们标记为冲突已解决。</p>
<p>如果你想使用图形化工具来解决冲突，你可以运行
<code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git mergetool</span></span><br><span class="line"></span><br><span class="line">This message is displayed because &#x27;merge.tool&#x27; is not configured.</span><br><span class="line">See &#x27;git mergetool --tool-help&#x27; or &#x27;git help config&#x27; for more details.</span><br><span class="line">&#x27;git mergetool&#x27; will now attempt to use one of the following tools:</span><br><span class="line">opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge</span><br><span class="line">Merging:</span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line">Normal merge conflict for &#x27;index.html&#x27;:</span><br><span class="line">  &#123;local&#125;: modified file</span><br><span class="line">  &#123;remote&#125;: modified file</span><br><span class="line">Hit return to start merge resolution tool (opendiff):</span><br></pre></td></tr></table></figure>
<p>如果你想使用除默认工具（在这里 Git 使用 <code>opendiff</code>
做为默认的合并工具，因为作者在 Mac
上运行该程序）外的其他合并工具，你可以在 “下列工具中（one of the
following tools）” 这句后面看到所有支持的合并工具。
然后输入你喜欢的工具名字就可以了。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>如果你需要更加高级的工具来解决复杂的合并冲突，我们会在 <a
href="https://www.progit.cn/#_advanced_merging">高级合并</a>
介绍更多关于分支合并的内容。</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>等你退出合并工具之后，Git 会询问刚才的合并是否成功。
如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行
<code>git status</code> 来确认所有的合并冲突都已被解决：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use &quot;git commit&quot; to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line"></span><br><span class="line">    modified:   index.html</span><br></pre></td></tr></table></figure>
<p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入
<code>git commit</code> 来完成合并提交。
默认情况下提交信息看起来像下面这个样子：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Merge branch &#x27;iss53&#x27;</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">    index.html</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># It looks like you may be committing a merge.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If this is not correct, please remove the file</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	.git/MERGE_HEAD</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and try again.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">with <span class="string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">All conflicts fixed but you are still merging.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Changes to be committed:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	modified:   index.html</span></span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure>
<p>如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息，添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。</p>
<h3 id="分支管理">分支管理</h3>
<p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p>
<p><code>git branch</code> 命令不只是可以创建与删除分支。
如果不加任何参数运行它，会得到当前所有分支的一个列表：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>
<p>注意 <code>master</code> 分支前的 <code>*</code>
字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code>
指针所指向的分支）。 这意味着如果在这时候提交，<code>master</code>
分支将会随着新的工作向前移动。
如果需要查看每一个分支的最后一次提交，可以运行
<code>git branch -v</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -v</span></span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch &#x27;iss53&#x27;</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure>
<p><code>--merged</code> 与 <code>--no-merged</code>
这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。
如果要查看哪些分支已经合并到当前分支，可以运行
<code>git branch --merged</code>：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --merged</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>
<p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。
<strong>在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用
<code>git branch -d</code>
删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</strong></p>
<p>查看所有包含未合并工作的分支，可以运行
<code>git branch --no-merged</code>：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --no-merged</span></span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>
<p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用
<code>git branch -d</code> 命令删除它时会失败：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d testing</span></span><br><span class="line">error: The branch &#x27;testing&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D testing&#x27;.</span><br></pre></td></tr></table></figure>
<p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用
<code>-D</code> 选项强制删除它。</p>
<h3 id="分支开发工作流">分支开发工作流</h3>
<p>现在你已经学会新建和合并分支，那么你可以或者应该用它来做些什么呢？
在本节，我们会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出这些典型的工作模式，你可以根据项目实际情况选择一种用用看。</p>
<h4 id="长期分支">长期分支</h4>
<p>因为 Git
使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。
也就是说，在整个项目开发周期的不同阶段，<strong>你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中</strong>。</p>
<p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在
<code>master</code>
分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。
他们还有一些名为 <code>develop</code> 或者 <code>next</code>
的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入
<code>master</code> 分支了。
这样，在确保这些已完成的特性分支（短期分支，比如之前的
<code>iss53</code> 分支）能够通过所有测试，并且不会引入更多 bug
之后，就可以合并入主干分支中，等待下一次的发布。</p>
<p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。
稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p>
<figure>
<img src="https://www.progit.cn/images/lr-branches-1.png"
alt="渐进稳定分支的线性图。" />
<figcaption aria-hidden="true">渐进稳定分支的线性图。</figcaption>
</figure>
<p>Figure 26. 渐进稳定分支的线性图</p>
<p>通常把他们想象成流水线（work
silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p>
<figure>
<img src="https://www.progit.cn/images/lr-branches-2.png"
alt="渐进稳定分支的工作流（“silo”）视图。" />
<figcaption
aria-hidden="true">渐进稳定分支的工作流（“silo”）视图。</figcaption>
</figure>
<p>Figure 27. 渐进稳定分支的流水线（“silo”）视图</p>
<p>你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个
<code>proposed</code>（建议） 或
<code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入
<code>next</code> 或者 <code>master</code> 分支。
这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。
再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</p>
<h4 id="特性分支">特性分支</h4>
<p>特性分支对任何规模的项目都适用。
特性分支是一种短期分支，<strong>它被用来实现单一特性或其相关工作</strong>。
也许你从来没有在其他的版本控制系统（<code>VCS</code>）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。
然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。</p>
<p>你已经在上一节中你创建的 <code>iss53</code> 和 <code>hotfix</code>
特性分支中看到过这种用法。 你在上一节用到的特性分支（<code>iss53</code>
和 <code>hotfix</code>
分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。
这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。
你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p>
<p>考虑这样一个例子，你在 <code>master</code> 分支上工作到
<code>C1</code>，这时为了解决一个问题而新建 <code>iss91</code> 分支，在
<code>iss91</code> 分支上工作到
<code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个
<code>iss91v2</code> 分支试图用另一种方法解决那个问题，接着你回到
<code>master</code>
分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 <code>C10</code>
的时候新建一个 <code>dumbidea</code> 分支，并在上面做些实验。
你的提交历史看起来像下面这个样子：</p>
<figure>
<img src="https://www.progit.cn/images/topic-branches-1.png"
alt="拥有多个特性分支的提交历史。" />
<figcaption aria-hidden="true">拥有多个特性分支的提交历史。</figcaption>
</figure>
<p>Figure 28. 拥有多个特性分支的提交历史</p>
<p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在
<code>iss91v2</code> 分支中方案；另外，你将 <code>dumbidea</code>
分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃
<code>iss91</code> 分支（即丢弃 <code>C5</code> 和 <code>C6</code>
提交），然后把另外两个分支合并入主干分支。
最终你的提交历史看起来像下面这个样子：</p>
<figure>
<img src="https://www.progit.cn/images/topic-branches-2.png"
alt="合并了 dumbidea 和 iss91v2 分支之后的提交历史。" />
<figcaption aria-hidden="true">合并了 <code>dumbidea</code> 和
<code>iss91v2</code> 分支之后的提交历史。</figcaption>
</figure>
<p>Figure 29. 合并了 <code>dumbidea</code> 和 <code>iss91v2</code>
分支之后的提交历史</p>
<p>我们将会在 <a href="https://www.progit.cn/#_distributed_git">分布式
Git</a>
中向你揭示更多有关分支工作流的细节，因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching
scheme）。</p>
<p>请牢记，当你做这么多操作的时候，这些分支全部都存于本地。
当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 ——
没有与服务器发生交互。</p>
<h3 id="远程分支">远程分支</h3>
<p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过
<code>git ls-remote (remote)</code>
来显式地获得远程引用的完整列表，或者通过
<code>git remote show (remote)</code> 获得远程分支的更多信息。
然而，一个更常见的做法是利用远程跟踪分支。</p>
<p>远程跟踪分支是远程分支状态的引用。
它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。
远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。</p>
<p>它们以 <code>(remote)/(branch)</code> 形式命名。
例如，如果你想要看你最后一次与远程仓库 <code>origin</code> 通信时
<code>master</code> 分支的状态，你可以查看 <code>origin/master</code>
分支。 你与同事合作解决一个问题并且他们推送了一个 <code>iss53</code>
分支，你可能有自己的本地 <code>iss53</code>
分支；但是在服务器上的分支会指向 <code>origin/iss53</code> 的提交。</p>
<p>这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在
<code>git.ourcompany.com</code> 的 Git 服务器。 如果你从这里克隆，Git 的
<code>clone</code> 命令会为你自动将其命名为
<code>origin</code>，拉取它的所有数据，创建一个指向它的
<code>master</code> 分支的指针，并且在本地将其命名为
<code>origin/master</code>。 Git 也会给你一个与 origin 的
<code>master</code> 分支在指向同一个地方的本地 <code>master</code>
分支，这样你就有工作的基础。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>“origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master”
一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行
<code>git init</code>
时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行
<code>git clone</code> 时默认的远程仓库名字。 如果你运行
<code>git clone -o booyah</code>，那么你默认的远程分支名字将会是
<code>booyah/master</code>。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure>
<img src="https://www.progit.cn/images/remote-branches-1.png"
alt="克隆之后的服务器与本地仓库。" />
<figcaption aria-hidden="true">克隆之后的服务器与本地仓库。</figcaption>
</figure>
<p>Figure 30. 克隆之后的服务器与本地仓库</p>
<p>如果你在本地的 <code>master</code>
分支做了一些工作，然而在同一时间，其他人推送提交到
<code>git.ourcompany.com</code> 并更新了它的 <code>master</code>
分支，那么你的提交历史将向不同的方向前进。 也许，只要你不与 origin
服务器连接，你的 <code>origin/master</code> 指针就不会移动。</p>
<figure>
<img src="https://www.progit.cn/images/remote-branches-2.png"
alt="本地与远程的工作可以分叉。" />
<figcaption aria-hidden="true">本地与远程的工作可以分叉。</figcaption>
</figure>
<p>Figure 31. 本地与远程的工作可以分叉</p>
<p>如果要同步你的工作，运行 <code>git fetch origin</code> 命令。
这个命令查找 “origin” 是哪一个服务器（在本例中，它是
<code>git.ourcompany.com</code>），从中抓取本地没有的数据，并且更新本地数据库，移动
<code>origin/master</code> 指针指向新的、更新后的位置。</p>
<figure>
<img src="https://www.progit.cn/images/remote-branches-3.png"
alt="git fetch 更新你的远程仓库引用。" />
<figcaption aria-hidden="true"><code>git fetch</code>
更新你的远程仓库引用。</figcaption>
</figure>
<p>Figure 32. <code>git fetch</code> 更新你的远程仓库引用</p>
<p>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git
服务器，仅用于你的 sprint 小组的开发工作。 这个服务器位于
<code>git.team1.ourcompany.com</code>。 你可以运行
<code>git remote add</code>
命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 <a
href="https://www.progit.cn/#_git_basics_chapter">Git 基础</a>
中详细说明。 将这个远程仓库命名为 <code>teamone</code>，将其作为整个 URL
的缩写。</p>
<figure>
<img src="https://www.progit.cn/images/remote-branches-4.png"
alt="添加另一个远程仓库。" />
<figcaption aria-hidden="true">添加另一个远程仓库。</figcaption>
</figure>
<p>Figure 33. 添加另一个远程仓库</p>
<p>现在，可以运行 <code>git fetch teamone</code> 来抓取远程仓库
<code>teamone</code> 有而本地没有的数据。 因为那台服务器上现有的数据是
<code>origin</code> 服务器上的一个子集，所以 Git
并不会抓取数据而是会设置远程跟踪分支 <code>teamone/master</code> 指向
<code>teamone</code> 的 <code>master</code> 分支。</p>
<figure>
<img src="https://www.progit.cn/images/remote-branches-5.png"
alt="远程跟踪分支 teamone/master。" />
<figcaption aria-hidden="true">远程跟踪分支
<code>teamone/master</code>。</figcaption>
</figure>
<p>Figure 34. 远程跟踪分支 <code>teamone/master</code></p>
<h4 id="推送">推送</h4>
<p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。
本地的分支并不会自动与远程仓库同步 - 你必须显式地推送想要分享的分支。
这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p>
<p>如果希望和别人一起在名为 <code>serverfix</code>
的分支上工作，你可以像推送第一个分支那样推送它。 运行
<code>git push (remote) (branch)</code>:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin serverfix</span></span><br><span class="line">Counting objects: 24, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.</span><br><span class="line">Total 24 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure>
<p>这里有些工作被简化了。 Git 自动将 <code>serverfix</code>
分支名字展开为
<code>refs/heads/serverfix:refs/heads/serverfix</code>，那意味着，“推送本地的
serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 <a
href="https://www.progit.cn/#_git_internals">Git 内部原理</a> 的
<code>refs/heads/</code> 部分，但是现在可以先把它放在儿。 你也可以运行
<code>git push origin serverfix:serverfix</code>，它会做同样的事 -
相当于它说，“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix
分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。
如果并不想让远程仓库上的分支叫做 <code>serverfix</code>，可以运行
<code>git push origin serverfix:awesomebranch</code> 来将本地的
<code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code>
分支。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>如何避免每次输入密码如果你正在使用 HTTPS URL 来推送，Git
服务器会询问用户名与密码。
默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，你可以设置一个
“credential cache”。
最简单的方式就是将其保存在内存中几分钟，可以简单地运行
<code>git config --global credential.helper cache</code>
来设置它。想要了解更多关于不同验证缓存的可用选项，查看 <a
href="https://www.progit.cn/#_credential_caching">凭证存储</a>。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支
<code>origin/serverfix</code>，指向服务器的 <code>serverfix</code>
分支的引用：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch origin</span></span><br><span class="line">remote: Counting objects: 7, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix    -&gt; origin/serverfix</span><br></pre></td></tr></table></figure>
<p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。
换一句话说，这种情况下，不会有一个新的 <code>serverfix</code> 分支 -
只有一个不可以修改的 <code>origin/serverfix</code> 指针。</p>
<p>可以运行 <code>git merge origin/serverfix</code>
将这些工作合并到当前所在的分支。 如果想要在自己的 <code>serverfix</code>
分支上工作，可以将其建立在远程跟踪分支之上：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b serverfix origin/serverfix</span></span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure>
<p>这会给你一个用于工作的本地分支，并且起点位于
<code>origin/serverfix</code>。</p>
<h4 id="跟踪分支">跟踪分支</h4>
<p>从一个远程跟踪分支检出一个本地分支会自动创建一个叫做
“跟踪分支”（有时候也叫做 “上游分支”）。
跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入
<code>git pull</code>，Git
能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪
<code>origin/master</code> 的 <code>master</code> 分支。
然而，如果你愿意的话可以设置其他的跟踪分支 -
其他远程仓库上的跟踪分支，或者不跟踪 <code>master</code> 分支。
最简单的就是之前看到的例子，运行
<code>git checkout -b [branch] [remotename]/[branch]</code>。
这是一个十分常用的操作所以 Git 提供了 <code>--track</code>
快捷方式：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout --track origin/serverfix</span></span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure>
<p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地增加一个不同名字的本地分支的上一个命令：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b sf origin/serverfix</span></span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;sf&#x27;</span><br></pre></td></tr></table></figure>
<p>现在，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code>
拉取。</p>
<p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用
<code>-u</code> 或 <code>--set-upstream-to</code> 选项运行
<code>git branch</code> 来显式地设置。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -u origin/serverfix</span></span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>NOTE</th>
<th>上游快捷方式当设置好跟踪分支后，可以通过 <code>@&#123;upstream&#125;</code> 或
<code>@&#123;u&#125;</code> 快捷方式来引用它。 所以在 <code>master</code>
分支时并且它正在跟踪 <code>origin/master</code> 时，如果愿意的话可以使用
<code>git merge @&#123;u&#125;</code> 来取代
<code>git merge origin/master</code>。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的
<code>-vv</code> 选项。
这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -vv</span></span><br><span class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure>
<p>这里可以看到 <code>iss53</code> 分支正在跟踪
<code>origin/iss53</code> 并且 “ahead” 是
2，意味着本地有两个提交还没有推送到服务器上。 也能看到
<code>master</code> 分支正在跟踪 <code>origin/master</code>
分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪
<code>teamone</code> 服务器上的 <code>server-fix-good</code>
分支并且领先 2 落后
1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。
最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p>
<p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。
这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。
如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。
可以像这样做：<code>$ git fetch --all; git branch -vv</code></p>
<h4 id="拉取">拉取</h4>
<p>当 <code>git fetch</code>
命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。
它只会获取数据然后让你自己合并。 然而，有一个命令叫作
<code>git pull</code> 在大多数情况下它的含义是一个
<code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。
如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过
<code>clone</code> 或 <code>checkout</code>
命令为你创建的，<code>git pull</code>
都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p>
<p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用
<code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p>
<h4 id="删除远程分支">删除远程分支</h4>
<p>假设你已经通过远程分支做完所有的工作了 -
也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的
<code>master</code> 分支（或任何其他稳定代码分支）。 可以运行带有
<code>--delete</code> 选项的 <code>git push</code>
命令来删除一个远程分支。 如果想要从服务器上删除 <code>serverfix</code>
分支，运行下面的命令：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete serverfix</span></span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure>
<p>基本上这个命令做的只是从服务器上移除这个指针。 Git
服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<h3 id="变基">变基</h3>
<p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code>
以及 <code>rebase</code>。
在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p>
<h4 id="变基的基本操作">变基的基本操作</h4>
<p>请回顾之前在 <a
href="https://www.progit.cn/#_basic_merging">分支的合并</a>
中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p>
<figure>
<img src="https://www.progit.cn/images/basic-rebase-1.png"
alt="分叉的提交历史。" />
<figcaption aria-hidden="true">分叉的提交历史。</figcaption>
</figure>
<p>Figure 35. 分叉的提交历史</p>
<p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。
它会把两个分支的最新快照（<code>C3</code> 和
<code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p>
<figure>
<img src="https://www.progit.cn/images/basic-rebase-2.png"
alt="通过合并操作来整合分叉了的历史。" />
<figcaption
aria-hidden="true">通过合并操作来整合分叉了的历史。</figcaption>
</figure>
<p>Figure 36. 通过合并操作来整合分叉了的历史</p>
<p>其实，还有一种方法：你可以提取在 <code>C4</code>
中引入的补丁和修改，然后在 <code>C3</code> 的基础上应用一次。 在 Git
中，这种操作就叫做 <em>变基</em>。 你可以使用 <code>rebase</code>
命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p>
<p>在上面这个例子中，运行：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout experiment</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master</span></span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br></pre></td></tr></table></figure>
<p>它的原理是首先找到这两个分支（即当前分支
<code>experiment</code>、变基操作的目标基底分支
<code>master</code>）的最近共同祖先
<code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底
<code>C3</code>,
最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit
id，以便理解，下同）</p>
<figure>
<img src="https://www.progit.cn/images/basic-rebase-3.png"
alt="将 C4 中的修改变基到 C3 上。" />
<figcaption aria-hidden="true">将 <code>C4</code> 中的修改变基到
<code>C3</code> 上。</figcaption>
</figure>
<p>Figure 37. 将 <code>C4</code> 中的修改变基到 <code>C3</code> 上</p>
<p>现在回到 <code>master</code> 分支，进行一次快进合并。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge experiment</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/basic-rebase-4.png"
alt="master 分支的快进合并。" />
<figcaption aria-hidden="true">master 分支的快进合并。</figcaption>
</figure>
<p>Figure 38. master 分支的快进合并</p>
<p>此时，<code>C4'</code> 指向的快照就和上面使用 <code>merge</code>
命令的例子中 <code>C5</code> 指向的快照一模一样了。
这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。
你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p>
<p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。
在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到
<code>origin/master</code> 上，然后再向主项目提交修改。
这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p>
<p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。
变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>
<h4 id="更有趣的变基例子">更有趣的变基例子</h4>
<p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。
就像 <a
href="https://www.progit.cn/#rbdiag_e">从一个特性分支里再分出一个特性分支的提交历史</a>
中的例子那样。 你创建了一个特性分支
<code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和
<code>C4</code>。 然后从 <code>C3</code> 上创建了特性分支
<code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和
<code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了
<code>C10</code>。</p>
<figure>
<img src="https://www.progit.cn/images/interesting-rebase-1.png"
alt="从一个特性分支里再分出一个特性分支的提交历史。" />
<figcaption
aria-hidden="true">从一个特性分支里再分出一个特性分支的提交历史。</figcaption>
</figure>
<p>Figure 39. 从一个特性分支里再分出一个特性分支的提交历史</p>
<p>假设你希望将 <code>client</code>
中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code>
中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用
<code>git rebase</code> 命令的 <code>--onto</code> 选项，选中在
<code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即
<code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code>
分支上重放：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase --onto master server client</span></span><br></pre></td></tr></table></figure>
<p>以上命令的意思是：“取出 <code>client</code> 分支，找出处于
<code>client</code> 分支和 <code>server</code>
分支的共同祖先之后的修改，然后把它们在 <code>master</code>
分支上重放一遍”。 这理解起来有一点复杂，不过效果非常酷。</p>
<figure>
<img src="https://www.progit.cn/images/interesting-rebase-2.png"
alt="截取特性分支上的另一个特性分支，然后变基到其他分支。" />
<figcaption
aria-hidden="true">截取特性分支上的另一个特性分支，然后变基到其他分支。</figcaption>
</figure>
<p>Figure 40. 截取特性分支上的另一个特性分支，然后变基到其他分支</p>
<p>现在可以快进合并 <code>master</code> 分支了。（如图 <a
href="https://www.progit.cn/#rbdiag_g">快进合并 master
分支，使之包含来自 client 分支的修改</a>）：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge client</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/interesting-rebase-3.png"
alt="快进合并 master 分支，使之包含来自 client 分支的修改。" />
<figcaption aria-hidden="true">快进合并 master 分支，使之包含来自 client
分支的修改。</figcaption>
</figure>
<p>Figure 41. 快进合并 master 分支，使之包含来自 client 分支的修改</p>
<p>接下来你决定将 <code>server</code> 分支中的修改也整合进来。 使用
<code>git rebase [basebranch] [topicbranch]</code>
命令可以直接将特性分支（即本例中的
<code>server</code>）变基到目标分支（即
<code>master</code>）上。这样做能省去你先切换到 <code>server</code>
分支，再对其执行变基命令的多个步骤。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master server</span></span><br></pre></td></tr></table></figure>
<p>如图 <a href="https://www.progit.cn/#rbdiag_h">将 server
中的修改变基到 master 上</a> 所示，<code>server</code>
中的代码被“续”到了 <code>master</code> 后面。</p>
<figure>
<img src="https://www.progit.cn/images/interesting-rebase-4.png"
alt="将 server 中的修改变基到 master 上。" />
<figcaption aria-hidden="true">将 server 中的修改变基到 master
上。</figcaption>
</figure>
<p>Figure 42. 将 server 中的修改变基到 master 上</p>
<p>然后就可以快进合并主分支 master 了：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge server</span></span><br></pre></td></tr></table></figure>
<p>至此，<code>client</code> 和 <code>server</code>
分支中的修改都已经整合到主分支里了，你可以删除这两个分支，最终提交历史会变成图
<a href="https://www.progit.cn/#rbdiag_i">最终的提交历史</a>
中的样子：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d client</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d server</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://www.progit.cn/images/interesting-rebase-5.png"
alt="最终的提交历史。" />
<figcaption aria-hidden="true">最终的提交历史。</figcaption>
</figure>
<p>Figure 43. 最终的提交历史</p>
<h4 id="变基的风险">变基的风险</h4>
<p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p>
<p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p>
<p>如果你遵循这条金科玉律，就不会出差错。
否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>
<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。
如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用
<code>git rebase</code>
命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>
<p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。
假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。
你的提交历史如图所示：</p>
<figure>
<img src="https://www.progit.cn/images/perils-of-rebasing-1.png"
alt="克隆一个仓库，然后在它的基础上进行了一些开发。" />
<figcaption
aria-hidden="true">克隆一个仓库，然后在它的基础上进行了一些开发。</figcaption>
</figure>
<p>Figure 44. 克隆一个仓库，然后在它的基础上进行了一些开发</p>
<p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。
你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p>
<figure>
<img src="https://www.progit.cn/images/perils-of-rebasing-2.png"
alt="抓取别人的提交，合并到自己的开发分支。" />
<figcaption
aria-hidden="true">抓取别人的提交，合并到自己的开发分支。</figcaption>
</figure>
<p>Figure 45. 抓取别人的提交，合并到自己的开发分支</p>
<p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用
<code>git push --force</code> 命令覆盖了服务器上的提交历史。
之后你从服务器抓取更新，会发现多出来一些新的提交。</p>
<figure>
<img src="https://www.progit.cn/images/perils-of-rebasing-3.png"
alt="有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。" />
<figcaption
aria-hidden="true">有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。</figcaption>
</figure>
<p>Figure 46.
有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</p>
<p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code>
命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p>
<figure>
<img src="https://www.progit.cn/images/perils-of-rebasing-4.png"
alt="你将相同的内容又合并了一次，生成了一个新的提交。" />
<figcaption
aria-hidden="true">你将相同的内容又合并了一次，生成了一个新的提交。</figcaption>
</figure>
<p>Figure 47. 你将相同的内容又合并了一次，生成了一个新的提交</p>
<p>此时如果你执行 <code>git log</code>
命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。
此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。
很明显对方并不想在提交历史中看到 <code>C4</code> 和
<code>C6</code>，因为之前就是他把这两个提交通过变基丢弃的。</p>
<h4 id="用变基解决变基">用变基解决变基</h4>
<p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git
还有一些高级魔法可以帮到你。
如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p>
<p>实际上，Git 除了对整个提交计算 SHA-1
校验和以外，也对本次提交所引入的修改计算了校验和—— 即 “patch-id”。</p>
<p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下
Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p>
<p>举个例子，如果遇到前面提到的 <a
href="https://www.progit.cn/#_pre_merge_rebase_work">有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</a>
那种情境，如果我们不是执行合并，而是执行
<code>git rebase teamone/master</code>, Git 将会：</p>
<ul>
<li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li>
<li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li>
<li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和
C3，因为 C4 其实就是 C4'）</li>
<li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li>
</ul>
<p>从而我们将得到与 <a
href="https://www.progit.cn/#_merge_rebase_work">你将相同的内容又合并了一次，生成了一个新的提交</a>
中不同的结果，如图 <a
href="https://www.progit.cn/#_rebase_rebase_work">在一个被变基然后强制推送的分支上再次执行变基</a>
所示。</p>
<figure>
<img src="https://www.progit.cn/images/perils-of-rebasing-5.png"
alt="在一个被变基然后强制推送的分支上再次执行变基。" />
<figcaption
aria-hidden="true">在一个被变基然后强制推送的分支上再次执行变基。</figcaption>
</figure>
<p>Figure 48. 在一个被变基然后强制推送的分支上再次执行变基</p>
<p>要想上述方案有效，还需要对方在变基时确保 C4' 和 C4 是几乎一样的。
否则变基操作将无法识别，并新建另一个类似 C4
的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p>
<p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code>
命令而不是直接 <code>git pull</code>。
又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再
<code>git rebase teamone/master</code>。</p>
<p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项
<code>--rebase</code>，你可以执行这条语句
<code>git config --global pull.rebase true</code> 来更改
<code>pull.rebase</code> 的默认配置。</p>
<p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，就不会有事。
假如在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。</p>
<p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行
<code>git pull --rebase</code>
命令，这样尽管不能避免伤痛，但能有所缓解。</p>
<h4 id="变基-vs.-合并">变基 vs. 合并</h4>
<p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。
在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p>
<p>有一种观点认为，仓库的提交历史即是
<strong>记录实际发生过什么</strong>。
它是针对历史的文档，本身就有价值，不能乱改。
从这个角度看来，改变提交历史是一种亵渎，你使用_谎言_掩盖了实际发生过的事情。
如果由合并产生的提交历史是一团糟怎么办？
既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p>
<p>另一种观点则正好相反，他们认为提交历史是
<strong>项目过程中发生的事</strong>。
没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。
持这一观点的人会使用 rebase 及 filter-branch
等工具来编写故事，怎么方便后来的读者就怎么写。</p>
<p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。
Git
是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。
既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p>
<p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>
<h3 id="总结-1">总结</h3>
<p>我们已经讲完了 Git 分支与合并的基础知识。
你现在应该能自如地创建并切换至新分支、在不同分支之间切换以及合并本地分支。
你现在应该也能通过推送你的分支至共享服务以分享它们、使用共享分支与他人协作以及在共享之前使用变基操作合并你的分支。
下一章，我们将要讲到，如果你想要运行自己的 Git
仓库托管服务器，你需要知道些什么。</p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Tools</category>
        <category>S3</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>WangDao OS Chapter2</title>
    <url>/WD-OS-Chap2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>枯燥无味的王道考研 OS 第二章 进程与线程 知识点罗列</p>
</blockquote>
<span id="more"></span>
<h2 id="进程的概念组成特征">进程的概念、组成、特征</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230124175307299.png"
alt="2.1-总" />
<figcaption aria-hidden="true">2.1-总</figcaption>
</figure>
<h3 id="进程的概念">进程的概念</h3>
<p>程序是静态的，进程是动态的，是程序的一次执行过程</p>
<p>QQ.exe 和启动 QQ</p>
<h3 id="进程的组成">进程的组成</h3>
<blockquote>
<p>准确来说是进程实体的组成</p>
</blockquote>
<h4 id="pcb">PCB</h4>
<p>PCB(Process Control
Block)：进程控制块，保存操作系统管理各个并发进程时所需要的信息</p>
<p><strong>PCB 是进程存在的唯一标志</strong>，进程创建时操作系统会创建
PCB，进程结束时操作系统会回收 PCB</p>
<p><strong>供给操作系统使用</strong></p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230124174652024.png"
alt="2.1.2.1-PCB组成" />
<figcaption aria-hidden="true">2.1.2.1-PCB组成</figcaption>
</figure>
<h4 id="程序段数据段">程序段、数据段</h4>
<p>程序段：程序代码（指令序列）</p>
<p>数据段：运行过程中产生的各种数据（如定义的变量）</p>
<p><strong>供给进程自身使用</strong>，与进程自身运行逻辑有关</p>
<h4 id="进程实体">进程实体</h4>
<p>进程实体（进程映像）由PCB、程序段、数据段组成，反应了进程在某一时刻的状态</p>
<p>所以可以这样定义进程：<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</strong></p>
<blockquote>
<p>调度指上 CPU 运行</p>
</blockquote>
<p>进程是动态的，进程实体（进程映像）是静态的。</p>
<h3 id="进程的特征">进程的特征</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230124175212607.png"
alt="2.1.3" />
<figcaption aria-hidden="true">2.1.3</figcaption>
</figure>
<p>其中，动态性是进程<strong>最基本</strong>的特征</p>
<h2 id="进程的状态与转换">进程的状态与转换</h2>
<figure>
<img
src="C:\Users\Lee/AppData/Roaming/Typora/typora-user-images/image-20230124201936453.png"
alt="2.2总" />
<figcaption aria-hidden="true">2.2总</figcaption>
</figure>
<h3 id="进程的状态">进程的状态</h3>
<p>创建态：进程正在被创建，操作系统为进程分配资源，初始化 PCB</p>
<p>就绪态：进程已经创建完成具备运行条件，但是没有空闲
CPU，暂时不能运行</p>
<p>运行态：进程正在 CPU 上运行，CPU 执行进程对应的程序</p>
<p>阻塞态：进程运行过程中，在等待某个事件的发生而无法继续运行，操作系统会让进程下
CPU 进入阻塞态</p>
<p>终止态：操作系统让进程下 CPU，并回收内存空间与该进程的 PCB</p>
<h3 id="进程的状态转换">进程的状态转换</h3>
<figure>
<img
src="C:\Users\Lee/AppData/Roaming/Typora/typora-user-images/image-20230124201325614.png"
alt="2.2.2丁字裤模型" />
<figcaption aria-hidden="true">2.2.2丁字裤模型</figcaption>
</figure>
<p>PCB 中也有一个变量 state 对应进程的当前状态</p>
<h3 id="进程的组织">进程的组织</h3>
<h4 id="链接">链接</h4>
<p>按照进程状态将 PCB 分为多个队列，指针指向当前处于某状态的进程</p>
<p>如就绪队列指针指向当前处于就绪态的进程</p>
<p>单核 CPU 同一时刻只能有一个进程处于运行态，多核 CPU
可有多个进程同时处于运行态</p>
<h4 id="索引">索引</h4>
<p>按照进程状态的不同建立索引表</p>
<h2 id="进程控制">进程控制</h2>
<p>简而言之就是实现进程状态的转换</p>
<h3 id="相关原语">相关原语</h3>
<p>原语通过“关中断指令”和“开中断指令”两个<strong>特权指令</strong>实现原子性</p>
<p>CPU
在正常情况下每执行完一条指令都会例行检查是否有中断信号，而关中断之后便不再进行该检查</p>
<figure>
<img
src="C:\Users\Lee/AppData/Roaming/Typora/typora-user-images/image-20230124202446434.png"
alt="2.3.1创建" />
<figcaption aria-hidden="true">2.3.1创建</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee/AppData/Roaming/Typora/typora-user-images/image-20230124202503059.png"
alt="2.3.1终止" />
<figcaption aria-hidden="true">2.3.1终止</figcaption>
</figure>
<p>将任意状态的进程转变为终止态最终消失</p>
<p>正常结束：进程调用 exit 系统调用请求终止</p>
<p>异常结束：除 0，非法使用特权指令等被操作系统杀掉</p>
<p>外界干预：任务管理器用户杀掉</p>
<figure>
<img
src="C:\Users\Lee/AppData/Roaming/Typora/typora-user-images/image-20230124202905434.png"
alt="2.3.1阻塞和唤醒" />
<figcaption aria-hidden="true">2.3.1阻塞和唤醒</figcaption>
</figure>
<p>阻塞和唤醒的原因应为同一件事</p>
<figure>
<img
src="C:\Users\Lee/AppData/Roaming/Typora/typora-user-images/image-20230124202955702.png"
alt="2.3.1切换" />
<figcaption aria-hidden="true">2.3.1切换</figcaption>
</figure>
<p>正确完成切换的前提是先在寄存器中保存进程的运行环境（必要的寄存器信息）</p>
<p>进程控制原语的三点共同点：</p>
<ol type="1">
<li><p>更新 PCB 中的信息</p></li>
<li><p>将 PCB 装入合适的队列</p></li>
<li><p>分配和回收资源</p></li>
</ol>
<h2 id="进程通信ipc">进程通信（IPC）</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230126055115286.png"
alt="2.4总" />
<figcaption aria-hidden="true">2.4总</figcaption>
</figure>
<p>两个进程之间产生数据交互</p>
<p>因为进程是分配系统资源的单位，所以各进程拥有的内存地址空间相互独立</p>
<h3 id="共享存储">共享存储</h3>
<p>基于数据结构、基于共享空间</p>
<h3 id="消息传递">消息传递</h3>
<p>以格式化的信息（Message）为单位，通过发送消息、接收消息两个原语进行数据交换</p>
<h3 id="管道通信">管道通信</h3>
<p>“管道”是一个特殊的共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区</p>
<p>采用半双工通信，单向传输，各进程互斥地访问管道</p>
<p>管道写满，写进程阻塞；管道读空，读进程阻塞</p>
<h2 id="线程概念-多线程模型">线程概念 多线程模型</h2>
<h3 id="线程的概念及属性优点">线程的概念及属性、优点</h3>
<p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此引入“线程”增加并发度。</p>
<p>可以把线程理解为“轻量级进程”。线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</p>
<p>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内</p>
<p>也可以并发处理各种任务（如QQ视频、文字聊天、传文件）</p>
<p>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。线程则作为处理机的分配单元。</p>
<h3 id="线程的属性">线程的属性</h3>
<h3 id="线程的实现方式">线程的实现方式</h3>
<p>用户级线程（User-Level Thread, ULT）和内核级线程（Kernel-Level
Thread, KLT）</p>
<p>从代码的角度看，线程其实就是一段代码逻辑。</p>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 32%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>ULT</th>
<th>KLT</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>线程的管理工作由谁来完成？</td>
<td>应用程序</td>
<td>OS kernel</td>
</tr>
<tr class="even">
<td>线程切换时 CPU 状态</td>
<td>用户态</td>
<td>核心态</td>
</tr>
<tr class="odd">
<td>操作系统是否能意识到用户级线程的存在？</td>
<td>否，只有用户看来是多线程</td>
<td>是，OS 通过 TCB 对线程进行管理</td>
</tr>
<tr class="even">
<td>优点</td>
<td>不需变态，开销小，效率高</td>
<td>并发能力强，可在多核处理机上并行运行</td>
</tr>
<tr class="odd">
<td>缺点</td>
<td>并发度低，不能在多核处理机上并行运行</td>
<td>需变态，开销大，效率低</td>
</tr>
</tbody>
</table>
<p>注：TCB 类比 PCB，线程控制块</p>
<p>可以看到二者互为优缺点</p>
<h3 id="多线程模型">多线程模型</h3>
<p>在<strong>支持内核级线程 KLT
的系统中</strong>，根据用户级线程和内核级线程的映射关系，划分出几种多线程模型</p>
<p>前面的数目是 ULT，后面的数目是 KLT</p>
<p>一对一有 KLT 的缺点，多对一有 ULT 的缺点，多对多综合了</p>
<p>多对多模型：n 个ULT 映射到 m 个 KLT（n &gt;= m）。每个 ULT 对应 m 个
KLT</p>
<p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用线程库
户进程占用太多内核级线程，开销太大的缺点。</p>
<p>可以这么理解：</p>
<p>用户级线程是“代码逻辑”的载体</p>
<p>内核级线程是“运行机会”的载体</p>
<p>一段“代码逻辑”只有获得了“运行机会”才能被 CPU <del>CPU</del>执行</p>
<figure>
<img src="image-20230126063144860.png" alt="image-20230126063144860" />
<figcaption aria-hidden="true">image-20230126063144860</figcaption>
</figure>
<h2 id="线程的组织与控制">线程的组织与控制</h2>
<p><img src="TCB%20与线程表.png" /></p>
<h2 id="调度的基本概念">调度的基本概念</h2>
<p>调度研究用某种规则决定处理任务顺序的问题</p>
<p>高级调度（作业调度）。按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。</p>
<p>低级调度（进程调度/处理机调度）——
按照某种策略从就绪队列中选取一个进程，将处理机分配给它。</p>
<p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p>
<p>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</p>
<p>暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列</p>
<p>中级调度（内存调度）——按照某种策略决定将哪个处于挂起状态的进程重新调入内存。</p>
<p>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</p>
<p>暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）</p>
<p>挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p>
<p>注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。</p>
<p>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p>
<figure>
<img src="三层调度的对比.png" alt="三层调度的对比" />
<figcaption aria-hidden="true">三层调度的对比</figcaption>
</figure>
<h2 id="进程调度的基本概念">进程调度的基本概念</h2>
<figure>
<img src="image-20230126073913377.png" alt="image-20230126073913377" />
<figcaption aria-hidden="true">image-20230126073913377</figcaption>
</figure>
<h2 id="调度器闲逛进程">调度器、闲逛进程</h2>
<h3 id="调度器">调度器</h3>
<p>调度程序决定：</p>
<p>让谁运行？——调度算法</p>
<p>运行多长时间？——时间片大小</p>
<p>调度时机——什么事件会触发“调度程序” ？</p>
<p>• 创建新进程</p>
<p>• 进程退出</p>
<p>• 运行进程阻塞</p>
<p>• I/O中断发生（可能唤醒某些阻塞进程）</p>
<p>• 非抢占式调度策略，只有运行进程阻塞或</p>
<p>退出才触发调度程序工作</p>
<p>• 抢占式调度策略，每个时钟中断或k个时钟</p>
<p>中断会触发调度程序工作</p>
<figure>
<img src="image-20230126074912039.png" alt="image-20230126074912039" />
<figcaption aria-hidden="true">image-20230126074912039</figcaption>
</figure>
<h3 id="闲逛进程">闲逛进程</h3>
<p>没有其他就绪进程时，运行闲逛进程</p>
<p>闲逛进程的特性：</p>
<p>• 优先级最低</p>
<p>•
可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</p>
<p>• 能耗低</p>
<h2 id="调度算法一">调度算法（一）</h2>
<p>算法的学习思路</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 32%" />
<col style="width: 32%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>FCFS</th>
<th>SJF</th>
<th>HRRN</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>算法思想</td>
<td>公平</td>
<td>平均等待时间、平均周转时间、平均带权周转时间最少</td>
<td>综合考虑作业/进程的等待时间和要求服务的时间</td>
</tr>
<tr class="even">
<td>算法规则</td>
<td>按照作业/进程到达的先后顺序进行服务</td>
<td>要求服务时间最短的作业/进程优先得到服务</td>
<td>选择响应比最高的作业/进程为其服务</td>
</tr>
<tr class="odd">
<td>作业调度 还是 进程调度</td>
<td>均可。用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</td>
<td>均可。用于进程调度时称为“短进程优先（SPF, Shortest Process
First）算法”</td>
<td>均可</td>
</tr>
<tr class="even">
<td>是否可抢占</td>
<td>非抢占式</td>
<td>非抢占式，抢占式为最短剩余时间优先算法（SRTN, Shortest Remaining
Time Next）</td>
<td>非抢占式</td>
</tr>
<tr class="odd">
<td>优点</td>
<td>公平、算法实现简单</td>
<td>“最短的”平均等待时间、平均周转时间</td>
<td></td>
</tr>
<tr class="even">
<td>缺点</td>
<td>对长作业有利，对短作业不利</td>
<td>对短作业有利，对长作业不利</td>
<td></td>
</tr>
<tr class="odd">
<td>是否会导致饥饿</td>
<td>不会</td>
<td>会（一直是短作业/进程会使长作业/进程饥饿）</td>
<td>不会</td>
</tr>
</tbody>
</table>
<p>饥饿（某进程/作业长期得不到服务）</p>
<p>先来先服务（FCFS, First Come First Serve）</p>
<p>短作业优先（SJF, Shortest Job First）</p>
<p>高响应比优先（HRRN, Highest Response Ratio Next）</p>
<p>常用的计算量如下： <span class="math display">\[
周转时间 = 完成时间 - 到达时间 \\
带权周转时间 = 周转时间/运行时间 \\
等待时间 = 周转时间 – 运行时间 \\
对于有计算和I/O操作的进程，其等待时间 = 周转时间 - 运行时间 -
I/O操作的时间 \\
响应比 = \frac{等待时间+要求服务时间}{要求服务时间}
\]</span> FCFS
算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题</p>
<p>SJF
算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题</p>
<p>能不能设计一个算法，既考虑到各个作业的等待时间，也能兼顾运行时间呢？——高响应比优先算法</p>
<p>对于 SRTN
算法，每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度</p>
<p>这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。而适合用于交互式系统的调度算法将在下个小节介绍</p>
<h2 id="调度算法二">调度算法（二）</h2>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 33%" />
<col style="width: 28%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>时间片轮转</th>
<th>优先级调度算法</th>
<th>HRRN</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>算法思想</td>
<td>公平</td>
<td>区分紧急程度</td>
<td>综合考虑作业/进程的等待时间和要求服务的时间</td>
</tr>
<tr class="even">
<td>算法规则</td>
<td>按照进程到达就绪队列的顺序，轮流让各个进程执行一个时间片</td>
<td>要求优先级最高的作业/进程优先得到服务</td>
<td>选择响应比最高的作业/进程为其服务</td>
</tr>
<tr class="odd">
<td>作业调度 还是 进程调度</td>
<td>进程调度</td>
<td>作业调度、进程调度、I/O调度均可</td>
<td>均可</td>
</tr>
<tr class="even">
<td>是否可抢占</td>
<td>抢占式，通过时钟中断通知</td>
<td>均有，抢占式需要在就绪队列变化时检查是否发生抢占</td>
<td>非抢占式</td>
</tr>
<tr class="odd">
<td>优点</td>
<td>公平、响应快、适用分时操作系统</td>
<td>适用于实时操作系统，可以灵活调整</td>
<td></td>
</tr>
<tr class="even">
<td>缺点</td>
<td>进程切换产生系统开销、不区分任务的紧急程度</td>
<td>持续的高优先级进程到来会导致饥饿</td>
<td></td>
</tr>
<tr class="odd">
<td>是否会导致饥饿</td>
<td>不会</td>
<td>会（一直是高优先级进程会使低优先级进程饥饿）</td>
<td>不会</td>
</tr>
</tbody>
</table>
<p>RR
算法常用于分时操作系统，更注重“响应时间”，因而此处不计算周转时间</p>
<p>时间片没用完但是运行完了也会主动放弃处理机发生调度</p>
<p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则 RR
算法退化为 FCFS 算法，并且会增大进程响应时间。因此时间片不能太大</p>
<p>另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小</p>
<p>FCFS算法的优点是公平</p>
<p>SJF 算法的优点是能尽快处理完短作业，平均等待/周转时间等参数很优秀</p>
<p>法</p>
<p>时间片轮转调度算法可以让各个进程得到及时的响应</p>
<p>优先级调度算法可以灵活地调整各种进程被服务的机会</p>
<p>能否对其他算法做个折中权衡？得到一个综合表现优秀平衡的算法呢？——多级反馈队列调度算法</p>
<p>交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的‘响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。</p>
<h2 id="调度算法三">调度算法（三）</h2>
<p>系统中按进程类型设置多个队列，进程创建成功后插入某个队列</p>
<p>!(image-20230128213255504.png)</p>
<p>队列之间可采取固定优先级，或时间片划分</p>
<p>固定优先级：高优先级空时低优先级进程才能被调度</p>
<p>时间片划分：如三个队列分配时间50%、40%、10%</p>
<h2 id="进程同步-进程互斥">进程同步 进程互斥</h2>
<p>进程具有异步性，操作系统要提供“进程同步机制”来解决异步问题</p>
<p>进程的“并发”需要“共享”的支持</p>
<p><strong>临界资源：一个时间段内只允许一个进程使用的资源</strong></p>
<p>对临界资源的访问，必须互斥地进行。也叫做间接制约关系</p>
<p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	entry section;</span><br><span class="line">    critical section;</span><br><span class="line">    <span class="built_in">exit</span> section;</span><br><span class="line">    remainder section;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入区：检查能否进入并上锁</p>
<p>临界区：访问临界资源的代码</p>
<p>退出区：解锁</p>
<p>剩余区：其他处理</p>
<p><strong>四个重要原则：空闲让进、忙则等待、有限等待、让权等待</strong></p>
<ol type="1">
<li><p>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</p></li>
<li><p>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</p></li>
<li><p>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</p></li>
<li><p>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</p></li>
</ol>
<h2 id="进程互斥的软件实现方法">进程互斥的软件实现方法</h2>
<figure>
<img src="image-20230128215145390.png" alt="image-20230128215145390" />
<figcaption aria-hidden="true">image-20230128215145390</figcaption>
</figure>
<p>代码示例：</p>
<p>单标志法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; <span class="comment">// turn是当前允许进入临界区的进程号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P0 process</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1 process</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>双标志先检查法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]; <span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P0 process</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]); <span class="comment">//P1想要进入</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1 process</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>先“检查”后“上锁”，进入区的“检查”和“上锁” 两个处理不是一气呵成的</p>
<p>双标志后检查法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]; <span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P0 process</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]); <span class="comment">//P1想要进入</span></span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1 process</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>Peterson算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]; <span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P0 process</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>); <span class="comment">//P1想要进入</span></span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1 process</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>Peterson
算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</p>
<h2 id="进程互斥的硬件实现方法">进程互斥的硬件实现方法</h2>
<figure>
<img src="image-20230129064919699.png" alt="image-20230129064919699" />
<figcaption aria-hidden="true">image-20230129064919699</figcaption>
</figure>
<p>TSL</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span> <span class="params">(<span class="type">bool</span> *lock)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> pre;</span><br><span class="line">    pre = lock*;</span><br><span class="line">    *lock = <span class="literal">true</span>; <span class="comment">// true表示加锁</span></span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">// 你读读就会明白</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现互斥</span></span><br><span class="line"><span class="keyword">while</span> (TestAndSet (&amp;lock));</span><br><span class="line">critical section;</span><br><span class="line">lock = <span class="literal">false</span>; <span class="comment">// unlock</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>Swap</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">swap (<span class="type">bool</span> *a, <span class="type">bool</span> *b) &#123;</span><br><span class="line">    <span class="type">bool</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现互斥</span></span><br><span class="line"><span class="type">bool</span> pre = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (pre == <span class="literal">true</span>)</span><br><span class="line">    swap (&amp;lock, &amp;pre);</span><br><span class="line">critical section;</span><br><span class="line">lock = <span class="literal">false</span>; <span class="comment">// unlock</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<h2 id="互斥锁">互斥锁</h2>
<p>解决临界区最简单的工具就是互斥锁（mutex
lock）。进程在进入临界区时获得锁；退出时释放锁。函数 acquire()
获得锁，release() 释放锁。</p>
<p>每个互斥锁有一个布尔变量 available
表示锁是否可用。如果锁是可用的，调用 acquire()
会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">acquire() &#123;</span><br><span class="line">    <span class="keyword">while</span> (!available); <span class="comment">// 忙等待</span></span><br><span class="line">    available = <span class="literal">false</span>; <span class="comment">// 获得锁</span></span><br><span class="line">&#125; <span class="comment">// entry section</span></span><br><span class="line">release() &#123;</span><br><span class="line">    available = <span class="literal">true</span>; <span class="comment">// 释放锁</span></span><br><span class="line">&#125; <span class="comment">// exit section</span></span><br></pre></td></tr></table></figure>
<p>acquire() release()
的执行是<strong>原子操作</strong>，因此互斥锁通常采用硬件机制来实现。
<strong>互斥锁的主要缺点是忙等待</strong>，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用
acquire()。当多个进程共享同一 CPU 时，就浪费了 CPU
周期。因此，互斥锁通常用于<strong>多处理器系统</strong>，一个线程可以在一个处理器上等待，不影响其他线程的执行。
需要连续循环忙等的互斥锁，都可称为自旋锁（spin
lock），如TSL指令、swap指令、单标志法</p>
<p>所以可以得出锁的特性：</p>
<p>• 需忙等，进程时间片用完才下处理机，违反“让权等待”</p>
<p>•
优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</p>
<p>•
常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</p>
<p>• 不太适用于单处理机系统，忙等的过程中不可能解锁</p>
<h2 id="信号量机制">信号量机制</h2>
<figure>
<img src="image-20230129073214410.png" alt="image-20230129073214410" />
<figcaption aria-hidden="true">image-20230129073214410</figcaption>
</figure>
<p>Dijkstra！</p>
<p>前面遗留的问题：不能同时进行</p>
<p>如果把进入区、退出区的操作都用“原语”实现就能解决</p>
<p><strong>用户进程</strong>可以通过使用操作系统提供的一对原语来对信号量进行操作</p>
<p>信号量其实就是一个变量
，可以用一个信号量来表示系统中某种资源的数量。与整数变量不同的是，对信号量的操作只有三种，初始化、P操作、V操作</p>
<p>比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。</p>
<p>一对原语：wait(S) 原语和 signal(S)
原语，可以把原语理解为我们自己写的函数，函数名分别为 wait 和
signal，括号里的信号量 S 其实就是函数调用时传入的一个参数。简称为
P、V操作，分别写为 P(S)、V(S)</p>
<p>整型信号量：</p>
<p>Eg ：某计算机系统中有一台打印机…</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(<span class="type">int</span> S)</span> &#123; <span class="comment">// 相当于进入区</span></span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>); <span class="comment">// 资源数不够则循环等待</span></span><br><span class="line">    S--; <span class="comment">// 资源数足够则占用一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(<span class="type">int</span> S)</span> &#123; <span class="comment">// 相当于退出区</span></span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process P0</span></span><br><span class="line">wait(S);</span><br><span class="line"><span class="comment">// use the printer, critical section</span></span><br><span class="line">signal(S);</span><br><span class="line"></span><br><span class="line"><span class="comment">// process P1</span></span><br><span class="line">wait(S);</span><br><span class="line"><span class="comment">// use the printer, critical section</span></span><br><span class="line">signal(S);</span><br></pre></td></tr></table></figure>
<p>整型信号量存在“忙等”问题，可以用记录型数据结构表示信号量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span> <span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(semaphore S)</span> &#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt; <span class="number">0</span>)</span><br><span class="line">        block (S.L);</span><br><span class="line">    <span class="comment">// 如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(semaphore S)</span> &#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span>)</span><br><span class="line">        wakeup(S.L);</span><br><span class="line">    <span class="comment">// 释放资源后，若还有别的进程在等待这种资源，则使用wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认为记录型信号量</p>
<h2
id="用信号量机制实现进程互斥同步前驱关系">用信号量机制实现进程互斥、同步、前驱关系</h2>
<figure>
<img src="image-20230129222621004.png" alt="image-20230129222621004" />
<figcaption aria-hidden="true">image-20230129222621004</figcaption>
</figure>
<p>本节核心内容：信号量的值 =
这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）</p>
<h3 id="互斥关系">互斥关系</h3>
<p>不同的临界资源需要设置不同的互斥信号量。</p>
<p>P、V操作必须成对出现。缺少P(mutex) 就不能保证临界资源的互斥访问。缺少
V(mutex) 会导致资源永不被释放，等待进程永不被唤醒。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    P(mutex);</span><br><span class="line">    critical section;</span><br><span class="line">    V(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    P(mutex);</span><br><span class="line">    critical section;</span><br><span class="line">    V(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步关系">同步关系</h3>
<p>进程同步问题：让本来异步并发的进程互相配合，有序推进。</p>
<ol type="1">
<li><p>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</p></li>
<li><p>设置同步信号量 S, 初始为 0</p></li>
<li><p>在“前操作”之后执行 V(S)</p></li>
<li><p>在“后操作”之前执行 P(S)</p></li>
</ol>
<h3 id="前驱关系">前驱关系</h3>
<p>本质上是多级同步关系</p>
<h2 id="生产者消费者问题">生产者消费者问题</h2>
<p>背景：系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）</p>
<p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p>
<p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</p>
<p>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</p>
<p>缓冲区是临界资源，各进程必须<strong>互斥</strong>地访问。</p>
<p>分析关系、确定PV操作、设置信号量初值</p>
<p>实现互斥是在同一进程中进行一对PV操作</p>
<p>实现两进程的同步关系，是在其中一个进程中执行P，另一进程中执行V</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = n;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">producer () &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        produce a product;</span><br><span class="line">        P(empty); <span class="comment">// 消耗一个空闲缓冲区</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        put the product into the buffer;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full); <span class="comment">// 增加一个产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer () &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(full); <span class="comment">// 消耗一个产品（非空缓冲区）</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        get a product from the buffer;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty); <span class="comment">// 增加一个空闲缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现互斥的P操作一定要在实现同步的P操作之后。</p>
<p>V操作不会导致进程阻塞，因此两个V操作顺序可以交换。</p>
<p><strong>本节易错点</strong>：实现互斥和实现同步的两个P操作的先后顺序（死锁问题）</p>
<h2 id="多生产者-多消费者">多生产者-多消费者</h2>
<p>后面有点难了，感觉王道不太够用了，先鸽了后面补</p>
]]></content>
      <categories>
        <category>OS</category>
        <category>S3 Winter</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>WangDao</tag>
      </tags>
  </entry>
  <entry>
    <title>WangDao OS Chapter3</title>
    <url>/WD-OS-Chap3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>王道考研 OS 的枯燥无味的 第三章 内存管理 知识点罗列</p>
</blockquote>
<span id="more"></span>
<h2 id="内存的基础知识">内存的基础知识</h2>
<p>按xx编址，一个地址对应的存储单元对应的是1xx</p>
<p>比如按字节编址</p>
<p>程序执行前需要先放到内存中才能被CPU处理</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230301211427483.png"
alt="image-20230301211427483" />
<figcaption aria-hidden="true">image-20230301211427483</figcaption>
</figure>
<h2 id="内存管理的概念">内存管理的概念</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230301211633198.png"
alt="image-20230301211633198" />
<figcaption aria-hidden="true">image-20230301211633198</figcaption>
</figure>
<p>重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</p>
<h2
id="覆盖与交换内存空间的扩充方式">覆盖与交换（内存空间的扩充方式）</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230301212008948.png"
alt="image-20230301212008948" />
<figcaption aria-hidden="true">image-20230301212008948</figcaption>
</figure>
<p>暂时换出外存等待的进程状态为挂起状态（挂起态，suspend）</p>
<p>文件区空间：离散分配方式</p>
<p>对换区空间：连续分配方式</p>
<p>对换区的I/O速度更快</p>
<p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停</p>
<p>PCB会常驻内存，不会被换出外存</p>
<h2 id="连续分配管理方式">连续分配管理方式</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230302080121468.png"
alt="image-20230302080121468" />
<figcaption aria-hidden="true">image-20230302080121468</figcaption>
</figure>
<p>三种连续分配管理都无外部碎片</p>
<h2 id="动态内存分配方法">动态内存分配方法</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230302084959938.png"
alt="image-20230302084959938" />
<figcaption aria-hidden="true">image-20230302084959938</figcaption>
</figure>
<p>​</p>
<h2 id="基本分页存储管理的基本概念">基本分页存储管理的基本概念</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230302085922698.png"
alt="image-20230302085922698" />
<figcaption aria-hidden="true">image-20230302085922698</figcaption>
</figure>
<p>页号可以隐藏存储（如用hash来保存）</p>
<p>然进程的各个页面是离散存放的，但是页面内部是连续存放的</p>
<p>页号 = 逻辑地址/页面长度</p>
<p>页内偏移量 = 逻辑地址 % 页面长度</p>
<h2 id="基本地址变换结构">基本地址变换结构</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230303145710216.png"
alt="image-20230303145710216" />
<figcaption aria-hidden="true">image-20230303145710216</figcaption>
</figure>
<p>过程再整理下</p>
<h2 id="具有快表的地址变换机构">具有快表的地址变换机构</h2>
<p>是基本地址变换机构的改进版本</p>
<h2 id="两级页表">两级页表</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230303150047904.png"
alt="image-20230303150047904" />
<figcaption aria-hidden="true">image-20230303150047904</figcaption>
</figure>
<h2 id="基本分段存储管理方式">基本分段存储管理方式</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230303150248805.png"
alt="image-20230303150248805" />
<figcaption aria-hidden="true">image-20230303150248805</figcaption>
</figure>
<h2 id="段页式管理">段页式管理</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230303150603552.png"
alt="image-20230303150603552" />
<figcaption aria-hidden="true">image-20230303150603552</figcaption>
</figure>
<h2 id="虚拟内存的基本概念">虚拟内存的基本概念</h2>
<p>在传统存储管理方式的基础上引入了交换技术、覆盖技术，使得内存利用率有所提升，并且能从逻辑上扩充内存容量</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230303150658994.png"
alt="image-20230303150658994" />
<figcaption aria-hidden="true">image-20230303150658994</figcaption>
</figure>
<p>虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的</p>
<p>虚拟内存的实际容量 = min（内存和外存容量之和，CPU寻址范围）</p>
<h2 id="请求分页管理方式">请求分页管理方式</h2>
<h2 id="页面置换算法">页面置换算法</h2>
<p>好多，详见 PPT，不做总结了，直接贴图吧（不是）</p>
<h2 id="页面分配策略">页面分配策略</h2>
]]></content>
      <categories>
        <category>OS</category>
        <category>S3 Winter</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>WangDao</tag>
      </tags>
  </entry>
  <entry>
    <title>《满江红》观影感受</title>
    <url>/MJH-talks/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>说说我个人对《满江红》的一点看法</p>
</blockquote>
<span id="more"></span>
<p>首先要肯定，这部贺岁大戏确实花了心思在里面。取景比较考究，一众演员演技在线，用配乐演进和人物穿巷串联情节。</p>
<p>不过作为张艺谋执导的电影，似乎还有不少地方做的不尽人意。</p>
<p>剧情发展不合理。先说何立之死，何立心狠手辣，城府颇深，称得上有勇有谋。他既能知道刘喜和桃姑娘的关系，能猜出瑶琴是半路加入，便也不至于在临门一脚时匆匆靠近瑶琴打坏了一手稳赢的牌。瑶琴和张大都有枷锁，一把长刀在侧，到手的鸭子怎么看怎么不会飞，这里的发展更像是匆忙草草收尾了事，好让观众挨住隐隐的如厕之意。再者，于情于理没有让张大死的必要。于情，瑶琴守护大义守护真爱半路加入行动，张大本不必死，本可代岳将军见秦桧剐见山河收见国耻平，孙均性情中人，坐视侄儿死在眼前死不瞑目，坐视瑶琴让张大活下去的奉献化为乌有，更太过冷血乖戾，孙均一向鲁莽，喜好速战速决，甚至为秦桧挡下一刀，转变之大让人匪夷所思；于理，只有蓝玉一人在秦桧之侧，短刃也插在张大身上，枷锁解开身上亦无伤，孙均反手便可手刃秦桧昭告天下，退一万步来看，至少挟秦桧背满江红的夙愿可轻松实现，似乎也不必等待蓝绿二人均在时冒险逼迫，彼时二人利刃在手风险数倍，战场出生入死的将军更懂这个道理。最后，孙均一身伤痕，哪有力气纵马远去？不怕一身老伤皮开肉绽吗？</p>
<p>剧情设定本就荒诞。以我对南宋将军的粗浅了解，似乎岳将军并不太在乎遗言是否能流传万古，他应该更在乎百姓的平安和故土的平复，就像辛稼轩本意也不在写词不在种树，“却将万字平戎策，换得东家种树书”，谁他妈要种树，老子要平戎定虏。能有人手刃秦桧厉兵秣马率军出征，岳将军九泉之下也可安息；放秦桧狗贼一条狗命，让他遗臭万年，who
cares？谁他妈在乎秦桧是谁，老子只想看故国收复。确实有比生死重要百倍千倍的东西，但是这东西应该不只是岳将军的一首遗言。不得不说这里对岳将军的理解有些以己度人了，这里有种《1874》里“与你畅游战地”一般扯淡的浪漫。以及替身这件事，至少我个人感觉有些荒谬。</p>
<p>总之，作为贺岁片，导演来分一杯羹，观众看个乐呵看个感动，能想起这位千年前的故人想起这首无人不知无人不晓的不朽词篇，便也还算，说得过去吧。</p>
]]></content>
      <categories>
        <category>生活记录</category>
        <category>S3 Winter</category>
      </categories>
      <tags>
        <tag>观后感</tag>
      </tags>
  </entry>
  <entry>
    <title>如何阅读一本书</title>
    <url>/reading-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>经典教育学读书教程《如何阅读一本书》读书笔记</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>希望在一个月内读完——23.6.9</p>
<p>6——23.9.15</p>
</blockquote>
<h2 id="第一篇-阅读的层次">第一篇 阅读的层次</h2>
<h3 id="第一章-阅读的活力与艺术">第一章 阅读的活力与艺术</h3>
<blockquote>
<p>目标读者：把阅读当作获取知识，增进理解的途径的人</p>
</blockquote>
<ul>
<li>Too much information 和 too little
information都是对理解力的阻碍，很不幸，media在做这件事</li>
<li>media 提供给你一种精细包装的information</li>
</ul>
<h4 id="主动的阅读">主动的阅读</h4>
<ul>
<li>读书是一件主动的事，并且越主动效果越好</li>
<li>听众的”接收“更应该像是棒球赛中的catcher，作者和读者的交流是相互的</li>
</ul>
<h4 id="阅读的目标">阅读的目标</h4>
<ul>
<li>真正的阅读：不借助外力，借助内心的力量玩味书中字句慢慢提升自己</li>
</ul>
<blockquote>
<p>本书主要关注提升理解力的阅读，关注完全依赖书本身的学习</p>
</blockquote>
<h3 id="第二章-阅读的层次">第二章 阅读的层次</h3>
<blockquote>
<p>阅读的层次是渐进的，低层次阅读包含于高层次阅读</p>
</blockquote>
<ul>
<li><p><strong>基础阅读 (Elementary Reading)</strong></p>
<blockquote>
<p>这个句子在说什么</p>
</blockquote>
<ul>
<li>弄懂文字的含义</li>
<li>速读课程的层次</li>
</ul></li>
<li><p><strong>检视阅读 (Inspectional Reading)</strong></p>
<blockquote>
<p>这本书在谈什么、这本书的架构如何、这本书包含哪些部分</p>
</blockquote>
<ul>
<li>系统化略读</li>
<li>在规定时间内完成阅读任务</li>
<li>时间<strong>过短</strong>，难以掌握一本书所有重点</li>
<li><strong>有限时间内</strong>最好最完整的阅读</li>
</ul></li>
<li><p><strong>分析阅读 (Analytical Reading)</strong></p>
<ul>
<li><strong>无限时间内</strong>最好最完整的阅读</li>
<li><strong>追寻理解</strong></li>
</ul></li>
<li><p><strong>主题阅读 (Syntopical Reading or Comparative
Reading)</strong></p>
<ul>
<li>阅读多本书，列举相关处，提出共同主题</li>
<li>也许会架构一个从未提出的主题分析</li>
</ul></li>
</ul>
<h3 id="第三章-基础阅读">第三章 基础阅读</h3>
<p>无</p>
<h3 id="第四章-检视阅读">第四章 检视阅读</h3>
<h4 id="有系统的略读或粗读">有系统的略读或粗读</h4>
<blockquote>
<p>发现这本书值不值得多花时间仔细阅读，就算决定不再多花时间，略读也能告诉你许多与这本书有关的事</p>
</blockquote>
<ul>
<li>先看书名页，然后，有序先看序
<ul>
<li>特别注意副标题</li>
<li>注意相关说明、本书的特殊角度</li>
<li>与先前的书归类</li>
</ul></li>
<li>研究目录页</li>
<li>检阅索引
<ul>
<li>评估本书涵盖的议题范围</li>
<li>所提到的书籍种类与作者</li>
<li><strong>提取重要词汇</strong>并根据此翻阅内文</li>
</ul></li>
<li>出版者的介绍
<ul>
<li>一般是作者亲自写的</li>
</ul></li>
<li>挑几个和主题息息相关的篇章看看</li>
<li>随便翻翻看看
<ul>
<li>翻过全书，留意主要论点和主题脉动</li>
<li><strong>不要忽略最后的两三页</strong></li>
</ul></li>
</ul>
<h4 id="粗浅的阅读">粗浅的阅读</h4>
<p><strong>重要的阅读规则：头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不要停下来查询或思索</strong></p>
<p>即，只注意你能理解的部分，不要为一些没法立即了解的东西而停顿</p>
<p>就算不重读，对一本难度很高的书了解了一半，也比什么都不了解要好。如果一碰到困难就停住，最后可能就真的对这本书一无所知了</p>
<h4 id="阅读的速度">阅读的速度</h4>
<p>检视阅读的两个方式都需要快速的阅读</p>
<p>当然，理想的阅读速度应该是能够用<strong>恰当的速度读对应的书</strong></p>
<h4 id="逗留与倒退">逗留与倒退</h4>
<p>眼部的逗留和倒退是坏习惯，但是很容易矫正</p>
<h3 id="第五章-如何做一个自我要求的读者">第五章
如何做一个自我要求的读者</h3>
<h4
id="主动的阅读基础一个阅读者要提出的四个基本问题">主动的阅读基础：一个阅读者要提出的四个基本问题</h4>
<ul>
<li>这本书整体上在谈些什么</li>
<li>作者细处说了什么，怎么说的</li>
<li>这本书说的有道理吗？是全部有道理还是部分有道理</li>
<li>这本书跟你有什么关系
<ul>
<li>本书给你的资讯有什么意义</li>
<li>为什么作者认为这件事重要</li>
<li>你真的有必要了解这些资讯吗</li>
</ul></li>
</ul>
<h4 id="如何让一本书真正属于你自己">如何让一本书真正属于你自己</h4>
<p><strong>读出言外之意，写出言外之意</strong></p>
<p>做笔记的重要性</p>
<ul>
<li>保持清醒</li>
<li>用言语理顺自己的思考</li>
<li>帮你记住作者的思想</li>
</ul>
<p>做笔记的方法</p>
<ul>
<li>画底线</li>
<li>双下划线，或其他记号加重整个段落</li>
<li>慎用星号，仅用于本书最重要的十几个声明或段落</li>
<li>顺序编号</li>
<li>空白处记下其他的页码，集中全书的想法
<ul>
<li>Cf，表示比较或参照</li>
</ul></li>
<li>圈出关键字或句子</li>
<li>在书的空白处做笔记
<ul>
<li>记录问题或答案</li>
<li>简化复杂的论点</li>
<li>最后一页可以用于做索引页，标注重要观点</li>
<li>在书的前空白页写下书的大纲</li>
</ul></li>
</ul>
<h4 id="三种做笔记的方法">三种做笔记的方法</h4>
<ul>
<li>检视阅读——<strong>结构笔记 (structural note-making)</strong>
<ul>
<li>这是怎么样的一本书？</li>
<li>整本书在谈的是什么？</li>
<li>作者是借着怎样的整体架构，来发展他的观点或陈述他对这个主题的理解？</li>
<li>目录页或书名页</li>
<li>重点是全书的架构而非内容（至少不是细节）</li>
</ul></li>
<li>主题阅读——<strong>概念笔记 (conceptual note-making)</strong>
<ul>
<li>与作者的观点有关</li>
</ul></li>
<li>主题阅读——<strong>辩证笔记 (dialectical note-making)</strong></li>
</ul>
<h4 id="培养阅读的习惯">培养阅读的习惯</h4>
<blockquote>
<p>习惯是第二天性</p>
</blockquote>
<p><strong>艺术或技巧只属于养成习惯并且能按照规则运作的人</strong></p>
<h4 id="由许多规则中养成一个习惯">由许多规则中养成一个习惯</h4>
<p><strong>为了忘掉单一的动作，一开始必须学会每一个单一的动作</strong>，这是学习复杂技巧的基本知识</p>
<h2 id="第二篇-阅读的第三个层次分析阅读">第二篇
阅读的第三个层次：分析阅读</h2>
<p><strong>规则一</strong>：一定要知道自己在读的是哪一类书，越早越好，最好在开始阅读之前就知道</p>
<h3 id="第六章-一本书的分类">第六章 一本书的分类</h3>
<h4 id="从一本书的书名中你能学到什么">从一本书的书名中你能学到什么</h4>
<p>将书籍分到某一个种类，并且知道这个种类的书在谈什么</p>
<h4 id="实用性-vs.-理论性作品">实用性 vs. 理论性作品</h4>
<p>分别教授知与行</p>
<p>实用性的书常常出现“应该应当”“好坏”“结果意义”之类的字眼</p>
<p>理论性的书常常说“是”</p>
<h4 id="理论性作品的分类">理论性作品的分类</h4>
<p>历史：发生在过去的事</p>
<p>科学：在意定律或通则，<strong>会超越一般人的生活经验</strong></p>
<p>哲学：追求一般真理，但是提出的问题和解决问题的方法和科学不同，<strong>不会超过一般人的生活经验</strong></p>
<h3 id="第七章-透视一本书">第七章 透视一本书</h3>
<p><strong>规则二</strong>：使用一个单一的句子或最多几句话（一小段文字）来叙述整本书的内容</p>
<p>唯一的检验标准：用几句话告诉自己或者别人这本书的内容。不要满足于“感觉上的整体”而说不出口</p>
<p><strong>规则三</strong>：将书中重要篇章列举出来，说明它们如何按照顺序组成整体架构</p>
<h4 id="结构与规划叙述整本书的大意">结构与规划：叙述整本书的大意</h4>
<p>如果作者提供帮助，不要太骄傲而拒绝；但是也不要完全相信</p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>S5</category>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>时钟参与组合逻辑的心得</title>
    <url>/combinational-logic-concerning-clock/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="写在前面">写在前面</h2>
<blockquote>
<p>计组组合逻辑的一点小小的思考与整理</p>
</blockquote>
<span id="more"></span>
<p>关于clock参与逻辑运算的问题，黑书英文版第二版（《Degital design and
computer architecture》(2nd Edition) ）中 P116
已有对此问题的阐释，摘录如下：</p>
<blockquote>
<p>Generally, performing logic on the clock is a <strong>BAD
IDEA</strong>. Clock gating delays the clock and can cause timing
errors, as we will see in Section 3.5.3, so do it only if you are sure
you know what you are doing.</p>
</blockquote>
<p>这种时钟偏移 <code>timing error</code>
简言之是<strong>时钟不同时到达各个寄存器</strong>。时钟偏移也显著地增加了建立时间
<span class="math display">\[t_{setup}\]</span> 和保持时间 <span
class="math display">\[t_{hold}\]</span>
及时序总开销，减少了组合逻辑的有效工作时间，增加了通过组合逻辑所需要的最小延迟。（证明可参见黑书中文版
P87 或黑书英文版
P148）从而，部分器件在一定条件下会不满足时钟约束。太多的时钟偏移还会导致严重的保持时间错误，有时还需要将触发器设置为特别慢来防止相关问题。这会使得时序分析的最坏情况变糟，<strong>影响电路的适用性</strong>。</p>
<p>那么怎么叫<code>you are sure you know what you are doing?</code></p>
<p>我个人认为比如在普通的D触发器的实现中，需要用反相时钟组，<strong>确实没有其他好的办法时</strong>才会使时钟参与逻辑运算。实现带使能的D触发器时确实有两种方法，但是<strong>有时钟不参与逻辑运算的方法，就没必要采用另一种</strong>。甚至高老板的PPT里没有提到这一种内部电路。</p>
<figure>
<img src="C:\Users\Lee\Desktop\internal-copy.png" alt="internal" />
<figcaption aria-hidden="true">internal</figcaption>
</figure>
<p><del>更优质的解答：我也没法保证</del></p>
<p>所以能有严谨的方法，就不必冒险而产生可能的冒险（）</p>
<hr />
<p><strong>省流</strong>：clock参与运算会使电路变差，<strong>尽量避免时钟参与逻辑运算</strong>。</p>
<hr />
<p>最后，希望大家能从讨论区中相互借鉴，相互帮助，共同学习~</p>
]]></content>
      <categories>
        <category>CO</category>
        <category>S3</category>
      </categories>
      <tags>
        <tag>CO</tag>
      </tags>
  </entry>
  <entry>
    <title>概率统计复习</title>
    <url>/Probability-and-Statistics-Review/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>缓考笨比的临时抱佛脚<del>，是时候开始预习了</del></p>
</blockquote>
<span id="more"></span>
<p>时间紧任务重，格式问题先摆烂了，各位看官对不住。毕竟考试要紧，考试要紧</p>
<p><strong>8.5、9.3、9.4、11.5、12.3不考</strong></p>
<h1 id="前言">前言</h1>
<p>笔记不重要，写不完鸽了就行，重要的是学会东西<del>（啊对对对，我也没见你学会啊）</del></p>
<p><strong>本书结构</strong>：1-6章概率论</p>
<p>7-9章数理统计</p>
<p>10-12章随机过程</p>
<h1 id="第一章-随机事件的概率">第一章 随机事件的概率</h1>
<h2 id="随机事件与样本空间">1.1 随机事件与样本空间</h2>
<h3 id="试验和事件">1.试验和事件</h3>
<p>随机：其结果事先不可预言</p>
<p><strong>不特殊说明，本书中试验都指随机试验</strong></p>
<p>随机试验特征：</p>
<ul>
<li>相同条件下可以重复进行</li>
<li>能够事先明确所有可能的实验结果范围</li>
<li>实验前不能准确预言试验结果</li>
</ul>
<p>事件：试验的结果</p>
<p>随机事件：试验中可能发生，也可能不发生，用大写字母 <span
class="math inline">\(A, B\dots\)</span> 表示</p>
<p>基本事件：随机试验的每一个可能结果，也是最简单的随机事件，用小写字母
<span class="math inline">\(e, w\)</span> 表示</p>
<p>必然事件、不可能事件：</p>
<p>必然事件用 <span class="math inline">\(S\)</span> 或 <span
class="math inline">\(Ω\)</span> 表示，不可能事件用 <span
class="math inline">\(\empty\)</span> 表示</p>
<p>不是随机事件，讨论时为方便当作随机事件</p>
<h3 id="样本空间">2.样本空间</h3>
<p>试验 <span class="math inline">\(E\)</span>
的<strong>全部基本事件</strong>组成的集合</p>
<p><strong>随机事件是样本空间的子集</strong></p>
<p>不可能事件 <span class="math inline">\(\empty\)</span>
表示空集，必然事件 <span class="math inline">\(S\)</span>
表示样本空间</p>
<p>==为后文用集合论讨论事件间关系和运算做准备==</p>
<h3 id="随机事件的关系和运算">3.随机事件的关系和运算</h3>
<p>包含、和、积、互不相容（互斥）、互逆（对立）、差</p>
<p>推广到有限多个、用图形表示、运算律</p>
<p><img src="Examples\Chapter1\1.1.3-1.png" /></p>
<p>第一章比较简单，先鸽了，后面有空再补，因为🐓组、大⑤、离散赶得有点紧了（手动百丽破防哥）</p>
<h1 id="第二章-随机变量及其分布">第二章 随机变量及其分布</h1>
<h2 id="随机变量">2.1 随机变量</h2>
<p><img src="Notes\Chapter2\2.1.1-1.png" /></p>
<p>数学本质是一个可测函数</p>
<p>==将随机事件的概率问题转化为随机变量取值的概率问题==</p>
<p>==因此，随机变量及其取值范围的概率问题是我们今后学习和研究的主要问题==</p>
<h2 id="随机变量的分布函数">2.2 随机变量的分布函数</h2>
<p>==分布函数非常重要==</p>
<p><strong>定义</strong>：设 <span class="math inline">\(X\)</span>
为随机变量，则 <span class="math inline">\(\{X \ge x\} = \{e \in
S|-\infty &lt; X(e) \le x\}\)</span> 为随机事件，令</p>
<p><span class="math inline">\(F(x) = P\{X \le x\},-\infty &lt; x &lt;
+\infty\)</span></p>
<p>为随机变量 <span class="math inline">\(X\)</span> 的<strong><span
class="math inline">\(\textcolor{red}{概率分布函数}\)</span></strong>，简称<strong><span
class="math inline">\(\textcolor{red}{分布函数}\)</span></strong>，记作
<span class="math inline">\(X \sim F(x)\)</span></p>
<p><span class="math inline">\(F(x)\)</span> 等于 <span
class="math inline">\(X\)</span> 在区间 <span class="math inline">\((-
\infty ,x]\)</span> 取值的概率</p>
<h2 id="离散型随机变量及其概率分布">2.3 离散型随机变量及其概率分布</h2>
<p><span class="math inline">\(X\)</span> 取各个可能值的概率</p>
<p><span class="math inline">\(p_k = P\{X = x_k\}, k =
1,2,\dots\)</span></p>
<p>称为概率分布（分布律、分布列）</p>
<h2 id="常用离散型随机变量的分布律">2.4 常用离散型随机变量的分布律</h2>
<h3 id="两点分布0-1分布">1.两点分布（（0-1）分布）</h3>
<p>服从（0-1）分布的试验叫做<strong>伯努利试验</strong></p>
<h3 id="泊松分布">2.泊松分布</h3>
<p><span class="math inline">\(P\{X = k\}=e^{-\lambda} \frac{\lambda ^
k}{k!},k=0,1,2,\dots\)</span></p>
<p>其中 <span class="math inline">\(\lambda &gt; 0\)</span>，称 <span
class="math inline">\(X\)</span> 服从参数为 <span
class="math inline">\(\lambda\)</span> 的泊松分布，记作 <span
class="math inline">\(X \sim \Pi(\lambda)\)</span>，这里用到幂级数展开式
<span class="math inline">\(e^x =
\sum_{k=0}^{+\infty}{\frac{x^k}{k!}}\)</span></p>
<blockquote>
<p>我头一次明白这个式子，这是前面乘一个 <span
class="math inline">\(e^{-\lambda}\)</span>
系数，然后后面做幂级数求和，得到结果 <span
class="math inline">\(e^{\lambda}\)</span> ，乘积恰好为1</p>
</blockquote>
<h3 id="超几何分布">3.超几何分布</h3>
<p>高中学的，多练例题即可</p>
<h3 id="二项分布">4.二项分布</h3>
<p><span class="math inline">\(P\{X=k\}=\sum_{k=0}^{n}
C_{n}^{k}p^kq^{n-k},k=0,1,2,\dots\)</span></p>
<blockquote>
<p>这公式真难敲啊，顺带提一嘴，我感觉这些没啥特别的，就是一个上标一个下标，把这个写好了就行。以及MarkDown没有自己的组合数</p>
</blockquote>
<p><span
class="math inline">\(\bcancel{你没有自己的组合数吗}\)</span></p>
<p>是 <span class="math inline">\((p+q)^n\)</span>
展开式中的一般项，记作 <span class="math inline">\(X \sim
B(n,p)\)</span></p>
<p>每次概率不改变的就是二项分布，<strong>常用的：放回式取用</strong></p>
<h3
id="二项分布的近似计算和查泊松分布表">5.二项分布的近似计算和查泊松分布表</h3>
<p>n很大，p很小的时候，二项分布接近泊松分布（一般 <span
class="math inline">\(n \ge 10, p_n \le 0.1\)</span> 时)</p>
<p>转换公式：<span class="math inline">\(\lambda = np\)</span></p>
<h2 id="连续型随机变量及其概率密度函数">2.5
连续型随机变量及其概率密度函数</h2>
<p><span class="math inline">\(f(x)\)</span> 为<strong><span
class="math inline">\(\textcolor{red}{概率密度函数}\)</span></strong>（分布密度函数），简称<strong><span
class="math inline">\(\textcolor{red}{概率密度}\)</span></strong></p>
<p>==概率密度和分布函数都很重要，同时也要区分清楚==</p>
<h2 id="常用的连续型随机变量分布">2.6 常用的连续型随机变量分布</h2>
<h3 id="均匀分布">1.均匀分布</h3>
<p><span class="math inline">\(\zeta \sim U[a,b]\)</span></p>
<h3 id="指数分布">2.指数分布</h3>
<p><span class="math display">\[
f(x)=
\begin{cases}
\lambda e^{- \lambda x},x \ge 0,\\
0,x &lt; 0
\end{cases}
\]</span></p>
<p>分布函数 <span class="math display">\[
F(x)=
\begin{cases}
0,x&lt;0,\\
\int_{-\infty}^x f(t)dt = 1-e^{-\lambda x},x \ge 0
\end{cases}
\]</span></p>
<h3 id="welbull-分布">3.Welbull 分布</h3>
<p>指数分布的一般情况，没怎么考过</p>
<h3 id="gamma-函数">4.<span class="math inline">\(\Gamma\)</span>
函数</h3>
<p>类似于辅助的作用，单独考有点逆天，算了不写了</p>
<h2 id="正态分布">2.7 正态分布</h2>
<h3 id="欧拉-泊松积分">1.欧拉-泊松积分</h3>
<p>很巧妙的算法，用二重积分证明 <span class="math display">\[
\int _{-\infty} ^{+\infty} e^{-x^2} dx = \sqrt{\pi}
\]</span></p>
<h3 id="正态分布-1">2.正态分布</h3>
<p><span class="math inline">\(\Huge f(x)=\frac{1}{\sigma
\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2 \sigma^2}},-\infty &lt; x &lt;
+\infty\)</span></p>
<p>记作 <span class="math inline">\(\zeta \sim
N(\mu,\sigma^2)\)</span></p>
<p><span class="math inline">\(\Huge
\textcolor{red}{非常非常非常重要}\)</span></p>
<p>性质：</p>
<ul>
<li><span class="math inline">\(x = \mu\)</span> 时，取最大值 <span
class="math inline">\(f(\mu) = \Huge\frac{1}{\sigma
\sqrt{2\pi}}\)</span></li>
</ul>
<h3 id="标准正态分布">3.标准正态分布</h3>
<p><img src="Notes\Chapter2\2.7.3-1.png" /></p>
<p>鸽了，哥们真不想打公式了妈的</p>
<h3
id="正态分布与标准正态分布的关系">4.正态分布与标准正态分布的关系</h3>
<p><span class="math inline">\(\Huge F(x) =
\Phi(\frac{x-\mu}{\sigma}),-\infty &lt; x &lt; +\infty\)</span></p>
<blockquote>
<p>意义：将不好算的数据转化成可以查表的标准正态分布，相互转换得到结果</p>
</blockquote>
<h3 id="标准正态分布的-alpha-分位点">5.标准正态分布的 <span
class="math inline">\(\alpha\)</span> 分位点</h3>
<blockquote>
<p>重要理解：分位点是一个横坐标，这个图是偶函数，要注意其对称轴是 x = 0
而非 <span class="math inline">\(\frac{1}{2}\)</span></p>
</blockquote>
<p><img src="Notes\Chapter2\2.7.5-1.png" /></p>
<p><del>算了，和自己达成和解，公式太多了</del></p>
<p>考的不多但是要求一定的记忆量</p>
<h1 id="第三章-二维随机变量">第三章 二维随机变量</h1>
<h2 id="随机向量与联合分布">3.1 随机向量与联合分布</h2>
<h3
id="二维随机变量的定义和分布函数的基本性质">1.二维随机变量的定义和分布函数的基本性质</h3>
<p><span class="math display">\[
F(x,y) = P\{X \le x, Y \le y\} \}= P\{e \in S|X(e) \le x, Y(e) \le y\}
\]</span></p>
<p>称为二维随机变量 <span class="math inline">\((X,Y)\)</span>
的分布函数或随机变量 <span class="math inline">\(X\)</span> 和 <span
class="math inline">\(Y\)</span> 的联合分布函数</p>
<p><img src="Notes\Chapter3\3.1.1-1.png" /></p>
<p><img src="Notes\Chapter3\3.1.1-2.png" /></p>
<p><strong>千万注意这个交叉计算的方式</strong></p>
<h3 id="二维离散型随机变量">2.二维离散型随机变量</h3>
<p>没啥想写的，鸽了吧</p>
<p>记得有的题目要用条件概率（P73）</p>
<h3 id="二维连续型随机变量">3.二维连续型随机变量</h3>
<p><span class="math inline">\(\huge \frac{\partial^2 F}{\partial x
\partial y}(x_0,y_0) = f(x_0,y_0)\)</span></p>
<p><span class="math inline">\(\huge P\{(X,Y) \in D\} =
\iint_{D}f(x,y)dxdy\)</span></p>
<p>这里涉及到一些二重积分的内容，但是我全忘了</p>
<p>好消息，有淑芬书，坏消息，好像把淑芬书扔家里了</p>
<p>这两个🦁都极其重要，务必<del>基佬</del>记牢</p>
<h3 id="常用的二维连续型随机变量">4.常用的二维连续型随机变量</h3>
<figure>
<img src="image-20230201132709759.png" alt="image-20230201132709759" />
<figcaption aria-hidden="true">image-20230201132709759</figcaption>
</figure>
<p>这五个变量的意义请见第五章</p>
<h2 id="边缘分布函数">3.2 边缘分布函数</h2>
<blockquote>
<p>考虑两个变量分布函数之间的关系</p>
</blockquote>
<p>$$ F_X(x) = _{y+} F(x,y) = F(x, +)\</p>
<p>F_Y(y) = _{x+} F(x,y) = F(+, y) $$
由联合分布函数可计算边缘分布函数，但反之不可确定</p>
<h2 id="边缘分布律与条件分布律">3.3 边缘分布律与条件分布律</h2>
<p><span class="math inline">\((X, Y)\)</span> 关于 <span
class="math inline">\(X\)</span>
的变量分布律正好是联合分布律表中各行概率相加</p>
<p><span class="math inline">\((X, Y)\)</span> 关于 <span
class="math inline">\(Y\)</span>
的变量分布律正好是联合分布律表中各行概率相加</p>
<figure>
<img src="image-20230201132953614.png" alt="image-20230201132953614" />
<figcaption aria-hidden="true">image-20230201132953614</figcaption>
</figure>
<h2 id="边缘概率密度与条件概率密度">3.4 边缘概率密度与条件概率密度</h2>
<h3 id="边缘概率密度">1.边缘概率密度</h3>
<p><span class="math display">\[
f_X(x)=\int_{-\infty}^{+\infty} f(x,y)dy\\
f_Y(y)=\int_{-\infty}^{+\infty} f(x,y)dx
\]</span></p>
<h3 id="条件概率密度">2.条件概率密度</h3>
<p><img src="image-20230201133151631.png"
alt="image-20230201133151631" /> <span class="math display">\[
F_{X|Y}(x|y) = \frac{\frac{\partial}{\partial
x}F(x,y)}{\frac{d}{dx}F_Y(y)}\\
F_{Y|X}(y|x) = \frac{\frac{\partial}{\partial
y}F(x,y)}{\frac{d}{dy}F_X(x)}\\
F_{X|Y}(x|y) = \int_{-\infty}^x \frac{f(u,y)}{f_Y(y)} du\\
F_{Y|X}(y|x) = \int_{-\infty}^y \frac{f(x,v)}{f_X(x)} dv\\
f_{X|Y}(x|y) = \frac{f(x,y)}{f_Y(y)}\\
f_{Y|X}(y|x) = \frac{f(x,y)}{f_X(x)}
\]</span></p>
<h2 id="相互独立的随机变量">3.5 相互独立的随机变量</h2>
<h3 id="相互独立">1.相互独立</h3>
<p><span class="math display">\[
P\{X \le x, Y \le y\} = P\{X \le x\}·P\{Y \le y\} \\
F(x, y) = F_X(x)·F_Y(y), -\infty &lt; x, y &lt; \infty
\]</span></p>
<h3
id="离散型随机变量相互独立判别定理">2.离散型随机变量相互独立判别定理</h3>
<p><span class="math display">\[
P\{X \le x_i, Y \le y_j\} = P\{X \le x_i\}·P\{Y \le y_j\},i,j=1,2,\dots
\]</span></p>
<h3
id="连续型随机变量相互独立判别定理">3.连续型随机变量相互独立判别定理</h3>
<p><span class="math display">\[
f(x,y) = f_X(x)·f_Y(y)
\]</span></p>
<p>（几乎处处）</p>
<h3
id="有限多个或可列个变量相互独立">4.有限多个或可列个变量相互独立</h3>
<h1 id="第四章-随机变量的函数的分布">第四章 随机变量的函数的分布</h1>
<blockquote>
<p>用已有的概率分布求出函数式的概率分布</p>
</blockquote>
<h2 id="离散型随机变量的函数的分布">4.1 离散型随机变量的函数的分布</h2>
<h3
id="一维离散型随机变量的函数的分布律">1.一维离散型随机变量的函数的分布律</h3>
<p>y相同相加，不同分列</p>
<h3
id="二维离散型随机变量的函数的分布律">2.二维离散型随机变量的函数的分布律</h3>
<p>求出具体值</p>
<h2 id="一维连续型随机变量的函数的分布">4.2
一维连续型随机变量的函数的分布</h2>
<p>把y的范围转化成x的范围</p>
<p>一般方法：先求 <span class="math inline">\(Y = g(X)\)</span>
的分布函数 <span class="math inline">\(F_Y(y)\)</span>，求导得到 <span
class="math inline">\(f_Y(y)\)</span></p>
<p>也有公式，可以无脑套用<img src="image-20230201133941348.png"
alt="image-20230201133941348" /></p>
<h2 id="二维连续型随机变量的函数的分布">4.3
二维连续型随机变量的函数的分布</h2>
<p>转化成二重积分</p>
<p>几种特殊的方法：</p>
<h3 id="z-x-y-的分布">1.<span class="math inline">\(Z = X + Y\)</span>
的分布</h3>
<p><span class="math display">\[
f_Z(z)=\int_{-\infty}^{+\infty} f(x,z-x)dx = \int_{\over{AB}} f(x,y)dx
\]</span></p>
<p>第二型曲线积分</p>
<p>有点复杂啊，回头得好好看看</p>
<h3 id="z-maxx-y-的分布">2.<span class="math inline">\(Z = max\{X +
Y\}\)</span> 的分布</h3>
<p><span class="math display">\[
\{Z \le z\} = \{X \le z, Y \le z\}
\]</span></p>
<p><img src="Notes\Chapter4\4.3.2-1.png" /></p>
<h3 id="z-minx-y-的分布">3.<span class="math inline">\(Z = min\{X +
Y\}\)</span> 的分布</h3>
<p><img src="Notes\Chapter4\4.3.3-1.png" /></p>
<h1 id="第五章-随机变量的数字特征">第五章 随机变量的数字特征</h1>
<p>数字特征，指联系于分布函数的某些数：如平均值，方差等。反映了随机变量在某些方面的特征</p>
<p>确定分布函数需要一些参数，而参数又往往由某些数字特征或其他数值所决定，故找到这些特征便能确定分布函数。</p>
<p>实际中确定这些特征比较困难，而且没有必要，有时只需要知晓随机变量的某些特征即可。</p>
<h2 id="数学期望">5.1 数学期望</h2>
<p>P129，例4，收敛需要特殊记一下</p>
<p>相加相乘的性质</p>
<figure>
<img src="image-20230201135028202.png" alt="image-20230201135028202" />
<figcaption aria-hidden="true">image-20230201135028202</figcaption>
</figure>
<p><strong>几个定理</strong></p>
<figure>
<img src="image-20230201134714012.png" alt="image-20230201134714012" />
<figcaption aria-hidden="true">image-20230201134714012</figcaption>
</figure>
<figure>
<img src="image-20230201134726376.png" alt="image-20230201134726376" />
<figcaption aria-hidden="true">image-20230201134726376</figcaption>
</figure>
<h2 id="方差">5.2 方差</h2>
<h3 id="概念">1.概念</h3>
<p>几种符号</p>
<p>带括号不带括号，Var</p>
<p>标准差、均方差</p>
<p><strong>重要的计算公式 $ DX = EX^2 - (EX)^2 $</strong></p>
<h3 id="性质">2.性质</h3>
<figure>
<img src="image-20230201135954111.png" alt="image-20230201135954111" />
<figcaption aria-hidden="true">image-20230201135954111</figcaption>
</figure>
<figure>
<img src="image-20230201140009843.png" alt="image-20230201140009843" />
<figcaption aria-hidden="true">image-20230201140009843</figcaption>
</figure>
<h2 id="常用随机变量的数学期望和方差">5.3
常用随机变量的数学期望和方差</h2>
<h3 id="分布">0-1分布</h3>
<p><span class="math inline">\(EX = p, DX = p(1-p)\)</span></p>
<h3 id="二项分布-1">二项分布</h3>
<p><span class="math inline">\(EX = np, DX = npq\)</span></p>
<h3 id="泊松分布-1">泊松分布</h3>
<p><span class="math inline">\(EX = \lambda, DX = \lambda\)</span></p>
<h3 id="均匀分布-1">均匀分布</h3>
<p><span class="math inline">\(EX = \frac{a + b}{2}, DX =
\frac{(b-a)^2}{12}\)</span></p>
<h3 id="指数分布-1">指数分布</h3>
<p><span class="math inline">\(EX = \frac{1}{\lambda}, DX =
\frac{1}{\lambda^2}\)</span></p>
<h2 id="协方差和相关系数">5.4 协方差和相关系数</h2>
<p>表征二维向量 X 与 Y 之间的关系</p>
<h3 id="协方差">1.协方差</h3>
<p><span class="math display">\[ Cov(X,Y) = E[(X - EX) · (Y - EY)]
\]</span></p>
<p><span class="math display">\[ Cov(X,Y) = E(XY) - EX·EY \]</span></p>
<p>性质为：</p>
<h3 id="相关系数">2.相关系数</h3>
<p>也称标准协方差，记作 <span class="math inline">\(\rho\)</span></p>
<h3 id="计算举例">3.计算举例</h3>
<blockquote>
<p>时刻铭记：协方差本身就是一种方差，计算的时候不需要再乘上 <span
class="math inline">\(\sqrt{DX} \sqrt{DY}\)</span> 了</p>
</blockquote>
<h2 id="矩-协方差矩阵">5.5 矩 协方差矩阵</h2>
<p>记一下概念就行，式子比较麻烦后面补</p>
<p>以及这里应该不考，所以暂时先放了</p>
<h1 id="第六章-大数定律和中心极限定理">第六章
大数定律和中心极限定理</h1>
<p>极限可以刻画相同条件下大量重复的试验</p>
<p><strong>这章的思路：</strong></p>
<p><strong>大数定律：</strong></p>
<blockquote>
<p>随机事件的大量重复出现中，存在几乎必然的规律</p>
</blockquote>
<ul>
<li><strong>事件的频率作为事件的概率的估计</strong></li>
<li><strong>样本均值作为总体均值的估计</strong></li>
</ul>
<p><strong>中心极限定理：</strong></p>
<ul>
<li><strong>正态分布在概率论中占有极其重要的地位</strong></li>
</ul>
<h2 id="马尔可夫不等式和切比雪夫不等式">6.1
马尔可夫不等式和切比雪夫不等式</h2>
<p>两个重要的不等式，研究大数定律的基本工具</p>
<p><img src="Notes\Chapter6\6.1-1.png" /><img
src="Notes\Chapter6\6.1-2.png" /></p>
<p>马尔可夫不等式是前文提到的 k 阶绝对矩</p>
<p>切比雪夫不等式主要用于概率估计和理论推导</p>
<ul>
<li>理论上证实了 方差度量随机变量取值偏离均值的程度</li>
<li>引出了方差估计的“尾概率”</li>
</ul>
<p><img src="Notes\Chapter6\6.1-3.png" /></p>
<blockquote>
<p>没有偏离，则是所有变量相同取值，很好理解</p>
</blockquote>
<h2 id="大数定律">6.2 大数定律</h2>
<p>频率收敛到概率的理论根据</p>
<p>我们只介绍一些弱的情况</p>
<p><img src="Notes\Chapter6\6.2-1.png" /><img
src="Notes\Chapter6\6.2-2.png" /></p>
<p><img src="Notes\Chapter6\6.2-3.png" /></p>
<p><img src="Notes\Chapter6\6.2-4.png" /></p>
<p><img src="Notes\Chapter6\6.2-5.png" /></p>
<p><img src="Notes\Chapter6\6.2-6.png" /></p>
<p><img src="Notes\Chapter6\6.2-7.png" /></p>
<h2 id="中心极限定理">6.3 中心极限定理</h2>
<p>人们在对大量随机现象的研究中发现，如果一个量是由大量相互独立的随机因素所造成，而每一个因素在总量中所起的作用又较小，那么这种量通常服从或近似服从正态分布.
这种现象就是中心极限定理的客观背景.</p>
<p><img src="Notes\Chapter6\6.3-1.png" /></p>
<p><img src="Notes\Chapter6\6.3-2.png" /></p>
<p><img src="Notes\Chapter6\6.3-3.png" /></p>
<p><strong>独立同分布的随机变量序列，它们本身不服从正态分布，但是多个随机变量和的极限分布是正态分布，这就是量变引起质变的道理．</strong></p>
<p>设 <span class="math inline">\(X_1,X_2,\dots,X_n,\dots\)</span>
是相互独立的随机变量序列，且其服从参数为 <span
class="math inline">\(\lambda\)</span> 的指数分布，则</p>
<p><img src="C:/Users/Lee/AppData/Roaming/Typora/typora-user-images/image-20221120220346361.png" alt="image-20221120220341455" style="zoom:67%;" /><img src="C:/Users/Lee/AppData/Roaming/Typora/typora-user-images/image-20221120220355682.png" alt="image-20221120220355682" style="zoom:67%;" /><img src="C:/Users/Lee/AppData/Roaming/Typora/typora-user-images/image-20221120220400188.png" alt="image-20221120220400188" style="zoom:67%;" /></p>
<p>（公式太复杂，复制了个图片，摸了）</p>
<h1 id="第七章-统计总体与样本">第七章 统计总体与样本</h1>
<p><img src="Notes\Chapter7\7-1.png" /></p>
<p><strong>省流：只有参数估计和假设检验</strong></p>
<h2 id="总体与样本">7.1 总体与样本</h2>
<h3 id="总体与个体">1.总体与个体</h3>
<p>总体：具有一定共同属性的研究对象的全体</p>
<p>个体：组成总体的每一个元素</p>
<p>总体通常用 <span class="math inline">\(\Omega = \{ \omega \}\)</span>
或 <span class="math inline">\(S = \{e\}\)</span> 表示</p>
<p>在实际中，我们主要关心的是研究对象的某一（或某几项）<strong>数量指标
<span class="math inline">\(X=X(\omega)\)</span></strong>
，它是一个随机变量</p>
<blockquote>
<p>将总体的分布用随机变量刻画</p>
</blockquote>
<p>随机变量 <span class="math inline">\(X\)</span>
的分布就是总体的分布</p>
<p>总体就是指随机变量 <span class="math inline">\(X\)</span> 或 <span
class="math inline">\(X\)</span> 的取值集合</p>
<h3 id="样本与样本值">2.样本与样本值</h3>
<p>用部分统计的方法</p>
<p>从总体 <span class="math inline">\(X\)</span> 中有放回地随机抽取
<span class="math inline">\(n\)</span> 个数值，<span
class="math inline">\(x_i\)</span> 是一次抽样观察（记录）的结果，<span
class="math inline">\(x_1,x_2,\dots,x_n\)</span> 为总体 <span
class="math inline">\(X\)</span>
的一组样本观察值，简称<strong>样本值</strong></p>
<p><img src="Notes\Chapter7\7.1-1.png" /></p>
<p>这一段的一个重要的概念：<strong>观察值（样本值）独立与总体同分布</strong></p>
<p>简单随机样本、简单随机抽样（不再赘述）</p>
<p><strong>默认所提到的样本都是简单随机样本</strong></p>
<p><img src="Notes\Chapter7\7.1-2.png" /></p>
<h2 id="样本矩和统计量">7.2 样本矩和统计量</h2>
<blockquote>
<p>一些加工样本的方法</p>
</blockquote>
<h3 id="样本矩">1.样本矩</h3>
<p>样本 <span class="math inline">\(k\)</span> 阶矩（<span
class="math inline">\(k\)</span> 阶原点矩）： <span
class="math display">\[
A_k = \frac{1}{n}\sum_{i = 1}^n X_i ^ k
\]</span></p>
<p>样本 <span class="math inline">\(k\)</span> 阶中心矩： <span
class="math display">\[
B_k = \frac{1}{n} \sum_{i = 1} ^n (X_i - \overline{X}) ^ k
\]</span></p>
<p>样本均值、样本方差、样本 <span class="math inline">\(k\)</span>
阶矩和样本 <span class="math inline">\(k\)</span>
阶中心矩都是<strong>随机变量</strong></p>
<p><img src="Notes\Chapter7\7.2-1.png" /></p>
<p><img src="Notes\Chapter7\7.2-2.png" /></p>
<blockquote>
<p>样本 <span class="math inline">\(k\)</span> 阶矩收敛于总体 <span
class="math inline">\(k\)</span> 阶矩</p>
</blockquote>
<h3 id="统计量">2.统计量</h3>
<blockquote>
<p>对样本进行加工，需要针对不同的统计问题构造一个<strong>不含未知参数</strong>的样本的连续函数，称为统计量</p>
</blockquote>
<blockquote>
<p>若含有总体的未知参数，即使得到了样本的观测数据，仍然不能由这些样本数据通过统计量计算出要估计的量的值</p>
</blockquote>
<h3 id="顺序统计量与经验分布函数">3.顺序统计量与经验分布函数</h3>
<h2 id="常用统计量的分布">7.3 常用统计量的分布</h2>
<blockquote>
<p>统计量是对总体的分布或数字特征进行推断的基础。因此求统计量的分布是数理统计的基本问题之一</p>
</blockquote>
<blockquote>
<p>只研究正态总体的统计量分布</p>
</blockquote>
<p><strong>见另一个手写文件</strong></p>
<h1 id="第八章-参数估计">第八章 参数估计</h1>
<h2 id="参数的点估计">8.1 参数的点估计</h2>
<p><img src="Notes\Chapter8\8.1-1.png" /></p>
<p>用样本值估计总体的参数叫做参数估计</p>
<p>参数估计分为点估计和区间估计</p>
<p><strong>参数点估计的两种方法：矩估计法和极大似然估计法</strong></p>
<p>对于同一个参数，得出的估计量也是有时相同有时不同</p>
<h3 id="矩估计法">1.矩估计法</h3>
<p>令样本矩 = 总体矩解出矩估计量，矩估计量的观察值称为矩估计值</p>
<p>当样本一阶原点矩的式子中不含 <span
class="math inline">\(\theta\)</span>
时，需要求出二阶原点矩或者一阶绝对矩</p>
<h3 id="极大似然估计法">2.极大似然估计法</h3>
<p><strong>分连续型总体和离散型总体两种情况</strong></p>
<p>连续型总体：<span class="math inline">\(L(\theta) = \Pi_{i = 1} ^{n}
f(x_i;\theta)\)</span>，求导求最大值对应的 <span
class="math inline">\(\theta\)</span> 即为所求</p>
<p>离散型总体：<span class="math inline">\(L(\theta) = \Pi_{i = 1} ^{n}
p(x_i;\theta)\)</span>，求导求最大值对应的 <span
class="math inline">\(\theta\)</span> 即为所求</p>
<p>喜欢考的题：P203，指数的取最小值，倒数的取最大值</p>
<h2 id="点估计量的优良性">8.2 点估计量的优良性</h2>
<blockquote>
<p>评价估计量好坏的标准</p>
</blockquote>
<h3 id="无偏估计">1.无偏估计</h3>
<p><span class="math inline">\(E(\hat{\theta}) = \theta\)</span></p>
<p>对于几个无偏估计量应该也有区分他们好坏的标准</p>
<h3 id="最小方差无偏估计">2.最小方差无偏估计</h3>
<p>对任一无偏估计 <span class="math inline">\(\hat{\theta_2}\)</span>
，均有 <span class="math inline">\(D(\hat{\theta_1}) \leq
D(\hat{\theta_2})\)</span></p>
<p>对于正态总体找起来较为简单</p>
<h3 id="一致估计">3.一致估计</h3>
<h2 id="区间估计与置信区间">8.3 区间估计与置信区间</h2>
<blockquote>
<p><span class="math inline">\(\theta\)</span> 所在区间和区间包含 <span
class="math inline">\(\theta\)</span> 的可靠程度</p>
</blockquote>
<h3 id="置信区间">1.置信区间</h3>
<h3 id="单侧置信限">2.单侧置信限</h3>
<p>只关心置信区间的上限或下限</p>
<p>目前仅能实现对正态总体的参数 <span class="math inline">\(\mu\)</span>
和 <span class="math inline">\(\sigma\)</span> 的区间估计</p>
<h2 id="正态总体均值和方差的区间估计">8.4
正态总体均值和方差的区间估计</h2>
<h3 id="均值-ex-的区间估计">1.均值 EX 的区间估计</h3>
<h4
id="方差dx已知对ex进行区间估计">（1）方差DX已知，对EX进行区间估计</h4>
<p>用统计量 <span class="math inline">\(U\)</span> 估计</p>
<p>查这个比较多，因为算数简单</p>
<h4
id="方差dx未知对ex进行区间估计">（2）方差DX未知，对EX进行区间估计</h4>
<p>用统计量 <span class="math inline">\(T\)</span> 估计</p>
<h3 id="方差-dx-的区间估计">2.方差 DX 的区间估计</h3>
<h2 id="不考略过">8.5 不考，略过</h2>
<h1 id="第九章-假设检验">第九章 假设检验</h1>
<p>先对<strong>总体</strong>做出某种假设，然后通过样本数据对假设做出接受或者拒绝</p>
<h2 id="假设检验的提出及其基本思想">9.1 假设检验的提出及其基本思想</h2>
<h2 id="正态总体均值和方差的假设检验">9.2
正态总体均值和方差的假设检验</h2>
<h3 id="方差-sigma2-已知检验假设-h_0mu-mu_0h_1-任意">1.方差 <span
class="math inline">\(\sigma^2\)</span> 已知，检验假设 <span
class="math inline">\(H_0:\mu = \mu_0\)</span>，<span
class="math inline">\(H_1\)</span> 任意</h3>
<p>采用统计量 <span class="math inline">\(U_0 = \frac{\overline{x} -
\mu_0}{\sigma/\sqrt{n}}\)</span> 作为检验函数，<span
class="math inline">\(U_0 = \frac{\overline{x} - \mu_0}{\sigma/\sqrt{n}}
\sim N(0,1)\)</span></p>
<h3 id="方差-sigma2-未知检验假设-h_0mu-mu_0h_1-任意">2.方差 <span
class="math inline">\(\sigma^2\)</span> 未知，检验假设 <span
class="math inline">\(H_0:\mu = \mu_0\)</span>，<span
class="math inline">\(H_1\)</span> 任意</h3>
<p>采用统计量 <span class="math inline">\(T = \frac{\overline{x} -
\mu_0}{s/\sqrt{n}}\)</span> 作为检验函数，<span class="math inline">\(T
= \frac{\overline{x} - \mu_0}{s/\sqrt{n}} \sim t(n-1)\)</span></p>
<h3
id="单个正态总体方差的假设检验">3.（单个）正态总体方差的假设检验</h3>
<p>采用统计量 <span class="math inline">\(W =
\frac{(n-1)s^{2}}{\sigma_0^2}\)</span>，<span class="math inline">\(W =
\frac{(n-1)s^{2}}{\sigma_0^2} \sim \chi^2(n-1)\)</span></p>
<h2 id="不考略过-1">9.3、9.4 不考，略过</h2>
<h1 id="第十章-随机过程的基本概念">第十章 随机过程的基本概念</h1>
<h2 id="随机过程的定义及分类">10.1 随机过程的定义及分类</h2>
<h3 id="随机过程的概念">1.随机过程的概念</h3>
<h3 id="随机过程的分类">2.随机过程的分类</h3>
<p>二阶矩过程，包括正态过程和平稳过程等</p>
<p>马尔可夫过程...</p>
<h2 id="随机过程的概率分布">10.2 随机过程的概率分布</h2>
<h3 id="随机过程的-n-维分布函数">1.随机过程的 <span
class="math inline">\(n\)</span> 维分布函数</h3>
<h3 id="独立过程">2.独立过程</h3>
<p>任意 <span class="math inline">\(n\)</span>
个过程都是独立的，由过程的一维分布函数就能确定该过程的统计特征</p>
<figure>
<img src="image-20230211095739087.png" alt="image-20230211095739087" />
<figcaption aria-hidden="true">image-20230211095739087</figcaption>
</figure>
<h3
id="两个随机过程的有限维联合分布及独立性">3.两个随机过程的有限维联合分布及独立性</h3>
<h2 id="随机过程的数字特征比前面更易考">10.3
随机过程的数字特征（比前面更易考）</h2>
<blockquote>
<p>随机过程是随机变量构成的集合，所以可以通过考察随机变量的数字特征来研究</p>
</blockquote>
<figure>
<img src="image-20230211100031053.png" alt="image-20230211100031053" />
<figcaption aria-hidden="true">image-20230211100031053</figcaption>
</figure>
<h1 id="第十一章-平稳过程">第十一章 平稳过程</h1>
<h2 id="考试题型">考试题型</h2>
<p>先写 <span class="math inline">\(\Theta\)</span> 和 <span
class="math inline">\(X\)</span>
基础的分布、再求数字特征，最后判断是不是平稳过程</p>
<h2 id="严平稳过程">11.1 严平稳过程</h2>
<h2 id="广义平稳过程平稳过程">11.2 广义平稳过程（平稳过程）</h2>
<h3 id="定义">1.定义</h3>
<figure>
<img src="1.png" alt="1" />
<figcaption aria-hidden="true">1</figcaption>
</figure>
<h3 id="数字特征的性质">2.数字特征的性质</h3>
<h1 id="第十二章-马尔可夫链引论">第十二章 马尔可夫链引论</h1>
<h2 id="考试题型-1">考试题型</h2>
<p>判断、状态空间、一步转移矩阵、平稳分布、两步的总条件概率</p>
<p>判断：<img src="image-20230211091530921.png"
alt="image-20230211091530921" /></p>
<p>用上面的判据好像稍微多一些</p>
<figure>
<img src="image-20230211091800582.png" alt="image-20230211091800582" />
<figcaption aria-hidden="true">image-20230211091800582</figcaption>
</figure>
<figure>
<img src="image-20230211093731986.png" alt="image-20230211093731986" />
<figcaption aria-hidden="true">image-20230211093731986</figcaption>
</figure>
<p>两步的条件概率要注意马尔可夫的独立性，或者说是标明了一种确定的状态转移过程</p>
<p>平稳过程和马尔可夫一般都作为最后一道题出现，但是他们的难度并不大，基本都是套路题，能拿的分要稳稳握住</p>
<p>祝诸君考试都有好运气</p>
]]></content>
      <categories>
        <category>S3</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>概率统计</tag>
      </tags>
  </entry>
  <entry>
    <title>浙大翁恺OO</title>
    <url>/WK-OO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言">前言</h2>
<blockquote>
<p><em>Not finished</em></p>
<p>浙大翁恺老师的 OO 入门课</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p><em>Refs</em>：翁恺 &amp; 黑马程序员</p>
</blockquote>
<h2 id="第一周-类与对象">第一周 类与对象</h2>
<h3 id="用类制造对象">用类制造对象</h3>
<p>前置知识：对象变量是对象的管理者而非所有者，所以涉及到赋值、函数参数传递和比较（如果两个对象变量相等说明管理的是同一内容，判断管理内容是否相同应用<code>equal</code>判断）都与普通变量有所不同。</p>
<p>现在，我们要来尝试自己定义类，然后用自己定义的类来创建对象</p>
<h3 id="定义类">定义类</h3>
<p>观察这类事物的特点，用一些成员和函数表示这个类</p>
<ul>
<li>private是对类而非对象，所以同一类的不同对象之间可以访问彼此的成员</li>
<li>如果不声明默认friendly，可以在同一个包的文件下共用</li>
<li>protected见继承中的project</li>
</ul>
<h3 id="成员变量和成员函数">成员变量和成员函数</h3>
<p><code>this</code> 这个特殊的本地变量起着至关重要的作用</p>
<ul>
<li>注意：如果成员函数的参数与成员变量同名，那么会取作用域更小的，也即取参数作为这个变量名对应的变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">New</span> &#123;</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">int</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员函数内部调用其他成员函数也可不加<code>this.</code></p>
<p>区别于定义在函数内部的本地变量，成员变量的生存期是对象的生存期，作用域是类内部的成员函数（也即类内的成员函数可以使用成员变量，成员变量初始化...）</p>
<h3 id="对象初始化">对象初始化</h3>
<p>成员变量在对象初始化时，如果未赋值，会安排一个初始值，当然也可以手动初始化（手动直接赋值、调用函数赋值）</p>
<table>
<thead>
<tr class="header">
<th>变量类型</th>
<th>初始值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>boolean</td>
<td>false</td>
</tr>
<tr class="even">
<td>int</td>
<td>0</td>
</tr>
<tr class="odd">
<td>object（某个对象）</td>
<td>null</td>
</tr>
</tbody>
</table>
<p>构造函数（课上讲过不少了，我摸了（bushi））</p>
<h2 id="第二周-对象交互">第二周 对象交互</h2>
<h3 id="对象的识别">对象的识别</h3>
<p>感觉和定义类是一回事，两件事情可以在定义类的时候同时完成。</p>
<h3 id="对象的交互">对象的交互</h3>
<p>课上讲过一嘴，说到可以用static修饰的“类全局变量”</p>
<p>也可以通过将一个类的成员变量设置为其他类的对象来达到目的</p>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220913223756886.png"
alt="image-20220913223756886" />
<figcaption aria-hidden="true">image-20220913223756886</figcaption>
</figure>
<p><strong>图1 以钟表为例来看对象的交互</strong></p>
<h3 id="访问属性">访问属性</h3>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220913223824851.png" alt="image-20220913223824851" style="zoom: 33%;" /></p>
<p>图2 用鸡蛋图表示封装思想</p>
<p><strong>封装思想</strong>：把数据和对数据的操作放在一起</p>
<p>public：同一个编译单元（一个java文件）里只能有一个class为public，且public
class的名字必须与编译单元同名</p>
<p>如果不加public，则不能在这个package外面访问</p>
<p>一个编译单元最多有一个public class，但也可以一个都没有</p>
<p>文件结构：clock(project)-&gt;src-&gt;clock(package)-&gt;clock.java</p>
<p><strong>import</strong>：用到的类不在同一个package里，就需要import</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> display.Display</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure>
<p>包的名字.包的类</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20220911164023484.png"
alt="image-20220911164023484" />
<figcaption aria-hidden="true">image-20220911164023484</figcaption>
</figure>
<p>如果不用import，也可以像这样给出全名</p>
<p>也可以万能import（引用display所有内容，但是可能冲突，推荐import具体的类）</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20220911164335992.png"
alt="image-20220911164335992" />
<figcaption aria-hidden="true">image-20220911164335992</figcaption>
</figure>
<p>包的名字里面的点实际上表达文件夹层次</p>
<p>Java通过这样的手段管理文件系统（</p>
<p><strong>static：类变量</strong>，不属于任何一个对象，属于这个类，任何一个对象都拥有这个变量，但是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrong usage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        value++; <span class="comment">// cannot compile</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static函数只能调用static函数，只能访问static成员变量（这回理解了）</p>
<p>static函数和变量可以通过类访问，也可以通过对象访问，只是不能获得对象的具体信息</p>
<p>static变量的初始化只执行一次，和对象的创建过程无关</p>
<p>这就不得不提static的四种用法了（课上讲过，我摸了，略记一下）</p>
<h2 id="第三周-对象容器">第三周 对象容器</h2>
<h3 id="记事本的例子">记事本的例子</h3>
<ul>
<li>确定功能</li>
<li>接口设计</li>
</ul>
<p>每一个类都写main，方便做调试</p>
<h3 id="泛型容器">泛型容器</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; notes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">// ArrayList of String，用来存放String的ArrayList</span></span><br></pre></td></tr></table></figure>
<p>ArrayList是一个类，notes本身是对象管理者</p>
<p>容器类型、元素类型</p>
<ul>
<li>对象数组中的每个元素都是对象的管理者而非对象本身</li>
</ul>
<p>set：set相当于数学中的集合，元素不重复，且没有排序的概念</p>
<p>toString函数直接输出这个对象，会输出toString()函数返回的字符串结果</p>
<p>可以先写一个“空”的返回值，比如返回int类型的，先写个return
0，后面再改；</p>
<p>返回String的先写个return "";</p>
<p>HashMap：想写出“聪明”的代码，和具体数据无关</p>
<p>容器里的类型必须是对象，不能是基本元素，所以需要Integer这样的包裹类型</p>
<p>包裹类型的变量可以直接接受所对应的基础类型变量</p>
<p>所以HashMap的返回值也是对象，就是一个管理者</p>
<p>如果存在会返回有效值，不存在返回null</p>
<p>key唯一，后面的会覆盖前面的</p>
<p>遍历没有特别简单的方法，<strong>可以考虑采取for-each遍历entrySet或者valueSet的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integet k : name.keySet()) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> name.get(k);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要写构造器constructor</p>
<h2 id="第四周-继承与多态">第四周 继承与多态</h2>
<blockquote>
<p>一周后看：当时看觉得难是正常的，因为现在也觉得难（）</p>
</blockquote>
<p><strong>继承得到了父类的所有东西</strong>，item里面的所有都得到了，都是<strong>可能</strong>可以用的（至于为什么是可能，会涉及<strong>访问权限</strong>的问题，我们后面说）</p>
<p>如果不在子类里定义title，那么就会报“The field Item.title is not
visible”（此时没有super()）</p>
<p><strong>父类的private成员真的只有父类自己才能用</strong></p>
<p>虽然继承给了子类，但是子类不能直接用</p>
<p>本来我们应该做的事情是让Item给Item的title赋值，所以应该由Item来做初始化</p>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220914222324033.png"
alt="image-20220914222324033" />
<figcaption aria-hidden="true">image-20220914222324033</figcaption>
</figure>
<p>可以看到，虽然CD没有private的title，但是确实产生了title</p>
<ul>
<li>第一个解决方案：把标识符改成protected（自己可以访问，同一个包内的其他类可以访问，子类可以访问）<strong>这是一种没办法的办法</strong></li>
</ul>
<p>对item做一个constructor</p>
<ul>
<li>cd的构造器得拿到title，用<code>super(title);</code>把参数传给父类，父类构造器通过参数构造；</li>
<li>如果用<code>super()</code>，找不到这个没有参数的构造器</li>
<li>如果不通过<code>super()</code>传递参数，父类会用不带参数的构造器进行构造</li>
</ul>
<blockquote>
<p>因为</p>
</blockquote>
<ul>
<li>先做了父类的初始化（定义初始化和构造器），然后才来做子类自己定义的初始化（我理解这样方便覆盖），再进构造函数做其他事情</li>
<li>需要保证父类的成员变量得到恰当的初始化——定义初始化、构造器（原来在二者兼备时优先定义初始化，然后构造器），总体的顺序是父类-&gt;子类，也即父类定义初始化、构造器-&gt;子类初始化、构造器，与是否采用super()传递参数无关</li>
<li>同时存在两个成员，也是可以的，父类的被隐藏
<ul>
<li>计算机的基本原则：优先选择范围小的，也即title应该是DVD自己的title</li>
<li>回到父类对父类成员变量操作时，操作的是父类自己的成员变量</li>
</ul></li>
<li>总结一下
<ul>
<li>父类的所有内容都继承给子类
<ul>
<li>但是如果是private的，子类不能访问</li>
<li>在谁的函数里面，所指的成员变量就是谁的
<ul>
<li>子类父类出现同名成员变量，在子类里面的就是子类自己的，在父类里面的就是父类自己的，之间没有任何联系</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><strong>要用父类的print()，需要加一个super</strong>，比如下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;DVD:&quot;</span>);</span><br><span class="line">    <span class="built_in">super</span>.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类定义了类型</p>
<p>子类定义了子类型</p>
<p>子类的对象可以被当作父类的对象来使用</p>
<ul>
<li>赋值给父类的对象</li>
<li>传递给需要父类对象的函数</li>
<li>放进存放父类对象的容器里</li>
</ul>
<p>成员函数的绑定都是动态绑定</p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912171422963.png" alt="image-20220912171422963" style="zoom:50%;" /></p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912172044907.png" alt="image-20220912172044907" style="zoom:50%;" /></p>
<p>记得这里有一个强制类型转换</p>
<p>以及函数声明必须完全相同（函数名、参数表）</p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912173013633.png" alt="image-20220912173013633" style="zoom:50%;" /></p>
<p>可扩展性：不需要修改就能添加新的内容</p>
<p>可维护性：需要修改才能添加新的内容</p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912173133898.png" alt="image-20220912173133898" style="zoom:50%;" /></p>
<h2 id="第五周-设计原则">第五周 设计原则</h2>
<p>城堡游戏</p>
<p>open declaration：进入对应的声明</p>
<p>String类的操作系统开销大，可以用StringBuffer类</p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912174838925.png" alt="image-20220912174838925" style="zoom:50%;" /></p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912175117169.png" alt="image-20220912175117169" style="zoom:33%;" /></p>
<p>可扩展性：用HashMap避免“硬编码”（即不需要写出每一对对应的具体键值和值，只需要每次扩展时添加新的即可）</p>
<h2 id="第六周-抽象与接口">第六周 抽象与接口</h2>
<h3 id="抽象">6.1 抽象</h3>
<p><strong>抽象就是为了防止被制造实体</strong></p>
<p>抽象类的作用仅仅是表达接口，而不是具体的实现细节。抽象类中可以存在抽象方法。抽象方法也是使用abstract关键字来修饰。抽象的方法是不完全的，它只是一个<strong>方法签名</strong>而完全没有方法体</p>
<p>但是为了表达类之间的关系，还需要这样一个类来表达。如第一章的例子，如果去掉
<code>Shape</code> 类，那么 <code>Circle</code> 和
<code>Rectangle</code> 类就没有关系了</p>
<p>抽象函数<strong>（不能有括号）</strong>：表达概念而无法实现具体代码的函数，目的是为了告诉子类需要写
<code>draw()</code> 方法</p>
<p>只要有一个函数是抽象的，类就是抽象的。（这很容易理解，否则便无法调用这个抽象方法）</p>
<ul>
<li>有抽象类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Graphics g)</span>;</span><br><span class="line"><span class="comment">// 注意不能有大括号，即不能定义函数体</span></span><br></pre></td></tr></table></figure>
<p>抽象类<strong>（不能产生对象，但是可以定义变量）</strong>：表达概念而无法构造出实体的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Shape</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(a, b);</span><br></pre></td></tr></table></figure>
<ul>
<li>任何继承了抽象类的非抽象子类的对象可以赋值给这个变量（也即任何Shape类子类的对象都可以由s来管理）</li>
</ul>
<p>实现抽象函数</p>
<ul>
<li>继承自抽象类的子类必须覆盖父类中的抽象函数，这种覆盖叫做<strong>实现</strong></li>
<li>否则这个类自己就会成为抽象类</li>
</ul>
<p>计算机中的两种抽象</p>
<ul>
<li>与具体相对
<ul>
<li>表达一种概念而非实体</li>
</ul></li>
<li>与细节相对
<ul>
<li>表示在一定程度上忽略细节而着眼大局</li>
</ul></li>
</ul>
<h3 id="数据与表现分离">6.2 数据与表现分离</h3>
<p>两种看程序的方法：</p>
<ul>
<li>看main函数，挨个展开需要看的子类代码（”自顶向下“方法）</li>
<li>看最小的类，追到父类，从看懂小部件开始看懂整个代码（”自底向上“方法，联想HuffmanCode）</li>
</ul>
<p>JFrame、View（窗口）</p>
<p><del>重绘这个图工作量太大了，先摸为敬</del></p>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220912194352676.png"
alt="image-20220912194352676" />
<figcaption aria-hidden="true">image-20220912194352676</figcaption>
</figure>
<p>数据与表现分离</p>
<ul>
<li>程序的业务逻辑与表现无关
<ul>
<li>表现可以是图形的也可以是文本的</li>
<li>表现可以是当地的也可以是远程的</li>
</ul></li>
</ul>
<p>（强调了一种“各司其职”的思想，写业务逻辑的程序员不需要关心表现是怎样的，不需要关心是通过网页输入字符串还是控制台输入还是blabla）</p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912194831143.png" alt="image-20220912194831143" style="zoom:33%;" /></p>
<p>责任驱动设计</p>
<ul>
<li>将程序要实现的功能分配到合适的类/对象中去</li>
</ul>
<p>网格化</p>
<ul>
<li>图形界面本身有更高的清晰度</li>
<li>但是将画面网格化后数据更易处理</li>
</ul>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912195010980.png" alt="image-20220912195010980" style="zoom: 25%;" /></p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20220912195043598.png" alt="image-20220912195043598" style="zoom:25%;" /></p>
<p>除了C++都不支持多继承<del>（那为啥不用C++）</del></p>
<blockquote>
<p>9.20更新：Java可以通过接口实现多继承</p>
</blockquote>
<p><strong>接口</strong></p>
<ul>
<li><strong>接口是纯抽象类</strong>
<ul>
<li><strong>所有的成员函数都是抽象函数</strong></li>
<li><strong>所有的成员变量都是public static
final（常量）</strong>，static方便调用，接口名.函数名即可调用</li>
<li>无构造方法</li>
<li>成员变量：
<ul>
<li>JDK7：接口中只能有抽象方法</li>
<li>JDK8：接口中可以定义有方法体的方法</li>
<li>JDK9：接口中可以定义私有方法</li>
</ul></li>
</ul></li>
<li>接口规定了长什么样，但是不管里面有什么</li>
</ul>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220912220141030.png"
alt="image-20220912220141030" />
<figcaption aria-hidden="true">image-20220912220141030</figcaption>
</figure>
<p><code>cell o</code>的意思是任何实现了cell接口的都可以交给这个变量</p>
<p>interface是一种特殊的class，<strong>和class的地位是一样的</strong>，原来用class的地方都可以用interface</p>
<p>实现接口</p>
<ul>
<li>类用<code>extends</code>，接口用<code>complements</code></li>
<li>类可以实现很多接口</li>
<li>接口可以继承接口，但不能继承类</li>
<li>接口不能实现接口</li>
</ul>
<p>讲的就是两个东西之间的链接</p>
<p>需要其他服务的时候，不是定义一个类，而是定义一个接口</p>
<p>cell是view和field定义的</p>
<p><strong>面向接口的编程方式</strong></p>
<ul>
<li>设计程序时先定义接口，再实现类</li>
<li>任何需要在函数间传入传出的一定是接口而不是具体的类</li>
<li>是Java成功的关键之一，因为极适合多人同时写一个大程序</li>
<li>也是Java被批评的要点之一，因为代码量膨胀起来很快</li>
</ul>
<blockquote>
<p><em>补充自黑马程序员</em></p>
</blockquote>
<p>抽象类：更多地用作父类，是对事物的抽象</p>
<p>抽取共性方法作为抽象方法，抽象方法所在的类便成为抽象类</p>
<p>接口：更多地侧重于规则，是对行为的抽象（如游泳接口，可由动物和人实现）</p>
<p>接口的子类也称作实现类</p>
<ul>
<li>要么重写接口中所有的抽象方法</li>
<li>要么也是抽象类</li>
</ul>
<p>可以多实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subclass</span> <span class="keyword">implements</span> <span class="title class_">Class1</span>, Class2 &#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以我感觉多接口继承也是用接口的重要原因之一</p>
</blockquote>
<p>接口和类之间的关系</p>
<ul>
<li>类和类的关系
<ul>
<li>继承关系，只能单继承，不能多继承，但是可以多重继承</li>
</ul></li>
<li>类和接口的关系
<ul>
<li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口
<ul>
<li>实现多个接口需要重写<strong>全部的</strong>抽象方法</li>
<li>同名的话就是实现了不同接口的同名函数</li>
</ul></li>
</ul></li>
<li>接口和接口的关系
<ul>
<li>继承关系，可以单继承，也可以多继承
<ul>
<li>实现最下面的子接口的话，需要重写所有的抽象方法</li>
</ul></li>
</ul></li>
</ul>
<h2 id="第七周-控制反转与mvc模式">第七周 控制反转与MVC模式</h2>
<h3 id="布局管理器">7.1 布局管理器</h3>
<p>Swing：所有的东西都叫做部件、另外一种东西叫做容器</p>
<p>容器可以加到容器里，部件也需要加到容器里</p>
<p>容器管部件在哪里，显示多大</p>
<p>布局管理器</p>
<p>layout manager</p>
<p>frame默认的layout manager是border</p>
<p>这章似乎和图形可视化等等关系比较大，所以我摸了（）</p>
<h2 id="第八周-异常处理与输入输出">第八周 异常处理与输入输出</h2>
<h3 id="捕捉异常">8.1.1 捕捉异常</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    idx = in.nextInt();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        a[idx] = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Caught&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入5，输出Hello</span></span><br><span class="line"><span class="comment">// 输入10，输出Caught</span></span><br><span class="line"><span class="comment">// 说明第6行没做，从第6行跳到了第9行</span></span><br></pre></td></tr></table></figure>
<h3 id="异常处理机制">8.1.2 异常处理机制</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIndex</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        a[<span class="number">10</span>] = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            k();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;caught&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>a[10] = 10</code>
出了异常，之后的hello不会执行，离开f回到调用的地方<img
src="D:\Working\MarkDownFiles\exception-execution.png" /></p>
<h3 id="捕捉到的异常">8.1.3 捕捉到的异常</h3>
<p>捉到了做什么</p>
<p><code>String getMessage()</code></p>
<p><code>String toString()</code></p>
<p><code>void printStackTrace</code></p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">caught</span><br><span class="line">10</span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: 10</span><br></pre></td></tr></table></figure>
<p>再度抛出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">catch (Exception e) &#123;</span><br><span class="line">     System.err.println(&quot;An exception with thrown&quot;);</span><br><span class="line">     throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在这个层面上需要处理，但是不能做最终的决定</p>
<h3 id="异常">8.2.1 异常</h3>
<p>读文件的例子</p>
<p>bussiness logic业务逻辑</p>
<figure>
<img
src="../../AppData/Roaming/Typora/typora-user-images/image-20220913194007073.png"
alt="image-20220913194007073" />
<figcaption aria-hidden="true">image-20220913194007073</figcaption>
</figure>
<p>如果某一步出了问题，就用catch解决问题</p>
<p>异常：不寻常的事情发生之时，需要终止预期的任务，让另一段代码处理</p>
<p>异常机制最大的好处就是清晰地分开了业务逻辑代码和遇到情况时的处理代码</p>
<p>异常声明</p>
<ul>
<li>如果你的函数可能抛出异常，就必须在函数头部加以声明<code>void f() throws TooBig, TooSmall, DivZero &#123; //... &#125;</code></li>
<li>可以声明并不会真正抛出的异常</li>
</ul>
<p>什么能扔？</p>
<ul>
<li>任何继承了Throwable类的对象</li>
<li>Exception类继承了Throwable</li>
<li>throw new Exception;</li>
<li>throw new Exception("Help");</li>
</ul>
<p>catch怎么匹配的异常</p>
<h3 id="流">8.3.1 流</h3>
<p>流是输入输出的方式</p>
<ul>
<li>流是一维单向的
<ul>
<li>一维：用一个数字就可以表达位置</li>
<li>单向：读 or 写</li>
</ul></li>
</ul>
<p>所有的IO操作都是有风险的</p>
<h2 id="tips">Tips</h2>
<h3 id="printf格式化输出">printf()格式化输出</h3>
<p>Java也支持<code>printf</code>格式化输出，格式与C语言相同</p>
<p>两个类里的<code>main函数</code>可以同时运行，当然还要看评测要求</p>
]]></content>
      <categories>
        <category>OO</category>
        <category>Notes</category>
        <category>S3</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>科目三实战技巧</title>
    <url>/subject3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言">前言</h2>
<blockquote>
<p>笔者与科三的爱恨情仇</p>
</blockquote>
<span id="more"></span>
<p>笔者去年没有练完的科三拖到了今年来练...在模拟了两次破费一百大洋后终于掌握要诀，肉疼的笔者心里那个不服，用键盘<del>讨伐</del>记录如下</p>
<h3 id="上车准备">上车准备</h3>
<blockquote>
<p>先上车进行身份验证，直到听到“请进行下车准备”时，观察左后视镜，扭头观察左后方无车后打开车门下车。逆时针绕车，在距离每个感应点20-30cm处交叉手臂几次，隐约听到车内“正在经过车尾”。绕车结束后上车，检查远光灯复位，挡位处在空挡，手刹拉起。调整座椅，系好安全带。</p>
</blockquote>
<h3 id="灯光">灯光</h3>
<blockquote>
<p>听到“请启动发动机”口令后，踩住离合器一次性把火打着，（随机考五个灯光）</p>
</blockquote>
<h3 id="起步">起步</h3>
<blockquote>
<p>听到“关闭灯光请起步”语音，打左转向灯，按喇叭两次，挂一档松手刹，左右观察驶入第二车道。加油门挂二档</p>
</blockquote>
<h3 id="行驶中">行驶中</h3>
<blockquote>
<p>行驶中第一个项目<strong>通过学校</strong>，无语音播报。观察左内右后视镜轻点刹车，需要注意，轻点刹车要使车有<strong>顿挫感</strong>。</p>
<p>第二个项目<strong>通过公交车站</strong>，无语音播报。观察左内右后视镜轻点刹车。</p>
<p>第三个项目<strong>直线行驶</strong>，听到“直线行驶”语音后，车在车道中间正负15cm，方向盘角度不超过15度，行驶一百米。</p>
<p>第四个项目<strong>前方路口左转</strong>，听到“前方路口左转”语音后，踩一次<strong>刹车</strong>，打<strong>左转向灯</strong>，观察左内右后视镜<strong>轻点刹车</strong>，注意观察路口情况，注意避让对侧直行社会车辆，<strong>避免斑马线停车</strong>。保险起见在路口斑马线前再踩一次<strong>刹车</strong>。</p>
<p>第五个项目<strong>加减挡</strong>，无语音播报。车速15迈左右挂二挡，25迈左右挂三挡，35迈左右挂四挡，踩油门保持车速35迈，默念6-7个数（5s）。松开油门回三挡，轻踩刹车，25迈以下回二挡。注意<strong>不要越级挂挡</strong>。</p>
<p>第六个项目<strong>前方路口直行</strong>，听到“前方路口直行”语音后，观察左内右后视镜<strong>轻点刹车</strong>。</p>
<p>第七个项目<strong>会车</strong>，听到前方会车语音以后，观察左内右后视镜<strong>轻点刹车。</strong></p>
<p>第八个项目<strong>掉头</strong>，听到“前方请找合适地点掉头”语音后，变更至最左侧车道，<strong>打左转向灯</strong>，快掉头时换一挡，在掉头前刹车一次，刷新一挡行驶距离（一挡连续行驶不能超过50m）。左打死观察左右情况掉头。</p>
<p>第九个项目<strong>变更车道</strong>，听到“变更车道”语音后，打右转向灯，看右后视镜并扭头观察右后方，往右打方向盘变道。</p>
<p>第十个项目<strong>前方路口右转</strong>，听到“前方路口右转”语音后，踩一次<strong>刹车</strong>，打<strong>右转向灯</strong>，观察左内右后视镜<strong>轻点刹车</strong>，注意观察路口情况，<strong>避免斑马线停车</strong>。保险起见在路口斑马线前再踩一次<strong>刹车</strong>。</p>
<p>第十一个项目<strong>超越前方车辆</strong>，听到“超越前方车辆语音”后，<strong>打左转向灯</strong>，看左后视镜并扭头观察左后方，往左变道，行驶四十米（约7-8条白线），看右后视镜并扭头观察右后方，变道驶回原车道。</p>
<p>第十二个项目<strong>通过人行横道</strong>，观察左内右观察后视镜<strong>轻点刹车</strong>。</p>
<p>第十三个项目<strong>靠边停车</strong>，听到“前方请找合适路段靠边停车”语音后，<strong>打右转向灯</strong>，看右后视镜并扭头观察右后方变道。挂一档靠边慢溜，车身与边线不能超过30cm（约一条半白线宽）。注意看前方将车顺正再看后视镜确认距离。如需调整应先顺正再微调。即使已发出“操作完毕请下车”语音仍可继续微调。确认可以以后，拉起手刹，摘空挡，熄火。踩住离合和刹车，确认上述三项复位。松安全带，松离合，松脚刹，观察左内右后视镜和左扭头观察左后方，确认安全后开关车门但不下车，开关车门的时间不能超过15秒。听到语音播报成绩，考试结束。</p>
</blockquote>
]]></content>
      <categories>
        <category>生活记录</category>
        <category>S3 Winter</category>
      </categories>
      <tags>
        <tag>科目三</tag>
      </tags>
  </entry>
  <entry>
    <title>《编译技术》笔记</title>
    <url>/compiling-technique-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="总述">总述</h2>
<blockquote>
<p>北航张莉《编译技术》笔记，看着玩玩</p>
</blockquote>
<span id="more"></span>
<h1 id="第一章-编译概述">第一章 编译概述</h1>
<h2 id="什么是程序设计语言">1.1 什么是程序设计语言</h2>
<p>人与计算机之间的中介，充当通信工具</p>
<h3 id="程序设计语言的定义方法">1.1.1 程序设计语言的定义方法</h3>
<p>对语言结构形式的描述：文法(grammar)或语法(syntax)</p>
<p>语言所表达内容的含义：语义</p>
<p><strong>本书采用属性文法。</strong>属性文法是一种半形式化的语义描述方法</p>
<h3 id="程序设计语言的处理系统">1.1.2 程序设计语言的处理系统</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428170824268.png"
alt="image-20230428170824268" />
<figcaption aria-hidden="true">image-20230428170824268</figcaption>
</figure>
<p>源程序(source program)、源语言(source language)、目标程序(object
program)或目标代码(object code)、目标语言(object language)</p>
<h3 id="编译程序和解释程序">1.1.3 编译程序和解释程序</h3>
<p>编译程序也可以输出介于低级语言和高级语言之间的某种中间语言(intermediate)</p>
<blockquote>
<p>中间程序可以理解为某种虚拟计算机的机器语言</p>
</blockquote>
<p>解释程序(interpreter)：能对编译得到的中间语言（甚至是源语言）进行解释执行的程序</p>
<blockquote>
<p>解释程序可以理解为这种虚拟计算机的模拟软件</p>
</blockquote>
<p>编译型语言运行时不需要重新翻译，执行效率高；但是依赖编译器，跨平台性差</p>
<p>常常用于开发操作系统、大型应用程序、数据库系统等</p>
<p>常见的编译型语言有 C/C++、Pascal/Object Pascal(Delphi)等</p>
<p>解释执行程序：需要对中间代码甚至源代码逐行解释，速度较慢，优点为：</p>
<ol type="1">
<li>可以运行时动态确定数据</li>
<li>中间代码的信息可以辅助调试</li>
<li>可以边修改边解释执行，缩短再次编译运行的时间</li>
<li>处理系统易开发</li>
<li>中间代码占用内存少</li>
<li>易于移植（中间语言的机器无关性）</li>
</ol>
<p><strong>T型图</strong></p>
<h2 id="与编译程序相关的处理系统">1.2 与编译程序相关的处理系统</h2>
<p><strong>1.各种翻译程序</strong></p>
<blockquote>
<p>翻译是广义的翻译，开阔下思路</p>
</blockquote>
<p><strong>2.预处理器</strong></p>
<p>把源程序变换为<strong>其它语言程序</strong>再进行编译。当然，与源程序的不对应性会导致程序调试困难</p>
<p><strong>3.宏处理器</strong></p>
<h2 id="编译程序和程序设计环境">1.3 编译程序和程序设计环境</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428171210972.png"
alt="image-20230428171210972" />
<figcaption aria-hidden="true">image-20230428171210972</figcaption>
</figure>
<h2 id="编译程序的构造">1.4 编译程序的构造</h2>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428171300901.png"
alt="image-20230428171300901" />
<figcaption aria-hidden="true">image-20230428171300901</figcaption>
</figure>
<p><strong>1.词法分析</strong></p>
<p>是以识别单词为目标的简单的语法分析程序</p>
<p><code>token</code> 的种类：</p>
<ul>
<li>保留字或关键词，如
<code>begin</code>、<code>if</code>、<code>for</code></li>
<li>标识符</li>
<li>常量，包括浮点数、整数、各进制数、字符常量、字符串常量等</li>
<li>分界符和运算符</li>
</ul>
<p>空格和注释会被过滤</p>
<blockquote>
<p>可以用枚举类具体实现</p>
</blockquote>
<p><strong>2.语法分析</strong></p>
<p>根据语法规则将token组合成大的语法类或语法成分，如变量声明、表达式、语句、函数和过程等</p>
<p>输出：一棵语法分析树（简称语法树）</p>
<ul>
<li><p>叶结点：token</p></li>
<li><p>非叶结点：语法成分</p></li>
</ul>
<p><strong>3.语义分析</strong></p>
<p>确定源程序的意义</p>
<p>事实上还要同时进行语义检查，比如赋值类型不匹配等</p>
<p>语义动作还包括生成中间代码</p>
<p><strong>4.代码生成</strong></p>
<p>通常是将源程序的中间形式转换为汇编语言或者机器语言，可通过代码优化进一步优化</p>
<p><strong>5.代码优化</strong></p>
<p>机器无关的优化</p>
<ul>
<li><p>常数表达式的计算、应用操作符的性质（结合性、可交换性、分配性等）</p></li>
<li><p>多次出现的相同子表达式一次性计算、将循环内不变的语句移到循环外等</p></li>
</ul>
<p>机器有关的优化</p>
<ul>
<li>寄存器分配等</li>
</ul>
<p><strong>6.符号表管理</strong></p>
<p><strong>7.错误检测与处理</strong></p>
<p>以上是逻辑结构，实现时常常结合实现</p>
<p><strong>8.前端和后端(front end and back end)</strong></p>
<p>前端：与源语言有关而与目标机无关的部分（即分析部分）</p>
<ul>
<li>词法分析、语法分析</li>
<li>符号表建立</li>
<li>语义分析、中间代码生成</li>
<li>相应部分的错误处理和符号表操作</li>
<li>与机器无关的代码优化</li>
</ul>
<p>后端：与目标机有关的部分（即综合部分），与源语言无关而仅仅依赖于中间语言</p>
<ul>
<li>目标代码生成</li>
<li>相应部分的错误处理和符号表操作</li>
<li>与机器有关的代码优化</li>
</ul>
<p><strong>9.遍(pass)</strong></p>
<h2 id="编译技术在软件工程中的应用">1.5 编译技术在软件工程中的应用</h2>
<p>略，用处不大</p>
<h2 id="练习-1">练习 1</h2>
<p>基本是概念复述</p>
<h1 id="第二章-文法和语言的概念和表示">第二章
文法和语言的概念和表示</h1>
<h2 id="文法的非形式讨论">2.1 文法的非形式讨论</h2>
<p><strong>文法</strong>：形式上描述和规定语言结构的规则，也称语法</p>
<h3 id="语法树">2.1.1 语法树</h3>
<table>
<thead>
<tr class="header">
<th>语法树结点</th>
<th>语法</th>
<th>形式语言</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>带尖括号的结点</td>
<td>语法成分</td>
<td>非终结符号</td>
</tr>
<tr class="even">
<td>不带尖括号的结点</td>
<td>单词符号</td>
<td>终结符号</td>
</tr>
</tbody>
</table>
<h3 id="规则">2.1.2 规则</h3>
<h3 id="推导">2.1.3 推导</h3>
<p>通常把规则称为<strong>产生式</strong>，用符号 <code>:==</code> 或
<span class="math inline">\(\rightarrow\)</span> 表示</p>
<p>用符号 <span class="math inline">\(\Rightarrow\)</span> 表示推导</p>
<p>两个以上的语法成分同时存在时可任选其中之一并根据规则重复上述推导，直到推出句子</p>
<h3 id="练习-2-1">练习 2-1</h3>
<h2 id="符号符号串及其集合的运算">2.2 符号、符号串及其集合的运算</h2>
<p>任何一种语言都是由该语言的<strong>基本符号</strong>所组成的<strong>符号串集合</strong></p>
<h3 id="字母表和符号串">2.2.1 字母表和符号串</h3>
<p><strong>字母表</strong>：元素的<strong>非空有穷</strong>集合</p>
<p><strong>符号</strong>：字母表中的元素</p>
<p><strong>符号串</strong>：由字母表中的符号所组成的任何<strong>有穷</strong>序列</p>
<p><strong>空符号串 <span
class="math inline">\(\varepsilon\)</span></strong>
：不包含任何符号的符号串</p>
<p><strong>符号串的递归定义</strong>：</p>
<ul>
<li>$ $ 是 <span class="math inline">\(\Sigma\)</span> 上的符号串</li>
<li>若 $ x$ 是 <span class="math inline">\(\Sigma\)</span>
上的符号串，且 <span class="math inline">\(a \in \Sigma\)</span> ，则 $
xa $ 或 $ ax $ 是 <span class="math inline">\(\Sigma\)</span>
上的符号串</li>
<li>$ y $ 是 <span class="math inline">\(\Sigma\)</span>
上的符号串，当且仅当 <span class="math inline">\(y\)</span> 可由 ① 和 ②
产生</li>
</ul>
<blockquote>
<p>前后拼接</p>
</blockquote>
<p>通常用 <span class="math inline">\(a、b \dots\)</span> 和 <span
class="math inline">\(S、T、U \dots\)</span> 表示符号，用 <span
class="math inline">\(s、t、u\)</span> 表示符号串，用 <span
class="math inline">\(A、B、C、 \dots 、 R\)</span> 表示符号串集合</p>
<h3 id="符号串及其集合的运算">2.2.2 符号串及其集合的运算</h3>
<p><strong>符号串相等</strong>：各个符号依次相等</p>
<blockquote>
<p>符号串中符号的顺序很重要</p>
</blockquote>
<p><strong>符号串的运算</strong>：</p>
<ul>
<li><p>符号串长度：$ |x| $，数值上等于组成该符号串的符号个数</p></li>
<li><p>符号串连接：若 <span class="math inline">\(x\)</span> 和 $ y $
是两个符号串，其连接为 $ xy $ ，特殊地，有 $ x = x = x $</p></li>
<li><p>集合的乘积运算：符号串集合 $ A $ 和 $ B $ 的乘积 <span
class="math inline">\(AB = \{xy | x \in A, y \in B\}\)</span>
，特殊地，有 $ {} A = A {} = A $</p></li>
<li><p>符号串的幂运算：<img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428181309643.png" alt="image-20230428181309643" style="zoom:50%;" /></p></li>
<li><p>集合的幂运算：</p>
<p><img src="D:\Programing\Compilers\Notes\WolfBook\Images\集合幂运算.png" alt="集合幂运算" style="zoom:50%;" /></p></li>
<li><p>集合 <span class="math inline">\(A\)</span> 的闭包 <span
class="math inline">\(A^*\)</span> 和 集合 $ A $ 的正闭包 <span
class="math inline">\(A^+\)</span> ：$ A^+ = A^1 A^2  A^n \ A ^* = A^0
A^*$，有 <span class="math inline">\(A^+ = AA^* = A^*A\)</span></p></li>
</ul>
<h2 id="文法和语言的形式定义">2.3 文法和语言的形式定义</h2>
<h3 id="文法的形式定义">2.3.1 文法的形式定义</h3>
<p><strong>产生式或规则</strong>：有序对 $(U, x) $ ，通常写作 <span
class="math inline">\(U::=x\)</span> 或 <span class="math inline">\(U
\rightarrow x\)</span>，其中 <span class="math inline">\(U\)</span>
是符号，是产生式的左部，<span class="math inline">\(x\)</span>
是有穷符号串，是产生式的右部</p>
<p><strong>字汇表</strong>：所有的规则左部和右部中的所有符号组成的集合</p>
<p><strong>非终结符号</strong>：文法 <span
class="math inline">\(G\)</span>
中作为规则左部出现的符号，也称语法成分，形成了非终结符号集 <span
class="math inline">\(V_n\)</span></p>
<p><strong>终结符号</strong>：规则中不属于 <span
class="math inline">\(V_n\)</span> 的符号，形成了终结符号集合 <span
class="math inline">\(V_t\)</span></p>
<p><strong>识别符号或开始符号</strong>：符号 <span
class="math inline">\(Z\)</span> 至少是一条规则的左部</p>
<p><strong>BNF 表示法</strong>：</p>
<blockquote>
<p>合并具有相同左部的规则</p>
</blockquote>
<p><strong>文法</strong>：一个四元组 <span class="math inline">\(G =
&lt;V_n, V_i, P, Z&gt;\)</span></p>
<p><span class="math inline">\(P\)</span>：产生式或规则的集合，<span
class="math inline">\(Z\)</span>：文法的识别符号</p>
<h3 id="推导的形式定义">2.3.2 推导的形式定义</h3>
<p><strong>直接推导</strong>：<img
src="D:\Programing\Compilers\Notes\WolfBook\Images\直接推导.png"
alt="直接推导" /></p>
<p>间接推导：</p>
<figure>
<img src="D:\Programing\Compilers\Notes\WolfBook\Images\间接推导.png"
alt="简介推导" />
<figcaption aria-hidden="true">简介推导</figcaption>
</figure>
<h3 id="语言的形式定义">2.3.3 语言的形式定义</h3>
<p>设 $G[Z] $ 是定义在字汇表 <span class="math inline">\(V\)</span>
上的一个文法，其中 <span class="math inline">\(Z\)</span>
是识别符号，在此省去了尖括号</p>
<p><strong>句型</strong>：如果 <span class="math inline">\(Z
\stackrel{*} \Rightarrow x\)</span>，且 <span class="math inline">\(x
\in V^*\)</span>，则称 $x $ 是文法 <span
class="math inline">\(G\)</span> 的一个句型</p>
<p><strong>句子</strong>：如果 <span class="math inline">\(Z
\stackrel{+} \Rightarrow x\)</span>，且 <span class="math inline">\(x
\in V^*_t\)</span>，则称 $x $ 是文法 <span
class="math inline">\(G\)</span> 的一个句子</p>
<ul>
<li>句子是语言的最小单位</li>
<li>句子是从文法的识别符号推导出来的由终结符号所组成的符号串</li>
<li>定义式是充要条件</li>
<li>若用 <span class="math inline">\(Z \stackrel{*} \Rightarrow
x\)</span>，有可能 <span class="math inline">\(Z = x\)</span>，与 <span
class="math inline">\(x \in V^*_t\)</span> 矛盾</li>
</ul>
<p><strong>语言</strong>：文法 <span class="math inline">\(G[Z]\)</span>
产生的所有句子的集合，记为 <span
class="math inline">\(L(G[Z])\)</span>，称为文法 <span
class="math inline">\(G[Z]\)</span> 所定义的语言，即 <span
class="math inline">\(L(G[Z]) = \{x | x \in V^*_t，且Z \stackrel{*}
\Rightarrow x \}\)</span></p>
<ul>
<li>语言是所有终结符号串所组成的集合的一个子集，即 <span
class="math inline">\(L(G[Z]) \subseteq V^*_t\)</span></li>
</ul>
<p><strong>规范推导</strong>：最右推导</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428232155349.png"
alt="image-20230428232155349" />
<figcaption aria-hidden="true">image-20230428232155349</figcaption>
</figure>
<ul>
<li>每个句子都有一个规范推导，但并非每个句型都有规范推导</li>
<li>可规范推导出的句型称为“规范句型”</li>
</ul>
<p><strong>等价文法</strong>：<span class="math inline">\(G\)</span> 和
<span class="math inline">\(G \prime\)</span> 是两个不同的文法，如果
<span class="math inline">\(L(G) = L(G\prime)\)</span>
，称二者为等价文法。</p>
<ul>
<li>定义的语言相同即等价</li>
<li>为了某种目的改写文法</li>
</ul>
<h3 id="递归规则与递归文法">2.3.4 递归规则与递归文法</h3>
<p><strong>递归规则</strong>：<span
class="math inline">\(U::=xUy\)</span></p>
<ul>
<li>若 <span class="math inline">\(x = \varepsilon\)</span>，则 <span
class="math inline">\(U::=Uy\)</span> 称为左递归规则</li>
<li>若 <span class="math inline">\(y = \varepsilon\)</span>，则 <span
class="math inline">\(U::=xU\)</span> 称为右递归规则</li>
<li>若 <span class="math inline">\(x, y \neq \varepsilon\)</span>，则
<span class="math inline">\(U::=xUy\)</span> 称为自嵌入的规则</li>
</ul>
<p><strong>文法的递归性质</strong>：</p>
<ul>
<li>直接递归：文法中至少包含一条递归规则，则称文法是直接递归的</li>
<li>间接递归</li>
<li>对文法中任一非终结符号，若能建立一个推导过程，在推导所得的符号串中又出现了该终结符本身，则文法是递归性的；反之是非递归性的</li>
</ul>
<blockquote>
<p>含义很容易理解，只是用形式语言描述似乎看起来啰嗦些</p>
</blockquote>
<ul>
<li>可以由有穷的规则刻画无穷的语言</li>
<li>左递归文法无法采用自顶向下的分析算法</li>
</ul>
<h3 id="短语简单短语和句柄">2.3.5 短语、简单短语和句柄</h3>
<p><strong>短语</strong>：设 <span class="math inline">\(G[Z]\)</span>
是一文法，<span class="math inline">\(w = uxy\)</span> 是一句型，如果有
<span class="math inline">\(Z \stackrel{*} \Rightarrow xUy\)</span> 且
<span class="math inline">\(U \stackrel{+} \Rightarrow u\)</span> ，称
<span class="math inline">\(u\)</span> 是一个相对于非终结符号 <span
class="math inline">\(U\)</span> 的句型 <span
class="math inline">\(w\)</span> 的短语</p>
<ul>
<li>若有 <span class="math inline">\(Z \stackrel{*} \Rightarrow
xUy\)</span> 且 <span class="math inline">\(U \Rightarrow u\)</span>
，称 <span class="math inline">\(u\)</span> 是一个相对于非终结符号 <span
class="math inline">\(U\)</span> 的句型 <span
class="math inline">\(w\)</span> 的简单短语</li>
<li>$ U V_n, u V^+, x, y V$</li>
<li>短语是针对句型和非终结符号的</li>
</ul>
<p><strong>句柄</strong>：任一句型的最左简单短语称为句型的句柄</p>
<blockquote>
<p>通过画出句型的语法树可以直观方便地找到句型的短语、简单短语和句柄</p>
</blockquote>
<h3 id="练习-2-3">练习 2-3</h3>
<h2 id="语法树和二义性">2.4 语法树和二义性</h2>
<h3 id="推导与语法树">2.4.1 推导与语法树</h3>
<ol type="1">
<li>推导过程与语法树的生成
<ul>
<li>推导过程不同，但是最终生成的语法树是完全相同的</li>
<li>推导过程仅反应推导顺序</li>
<li>当然，并非所有文法都具有语法树唯一性</li>
</ul></li>
<li>子树与短语
<ul>
<li>摆了</li>
</ul></li>
<li>由树构造推导
<ul>
<li>摆了</li>
</ul></li>
</ol>
<h3 id="文法与二义性">2.4.2 文法与二义性</h3>
<p><strong>文法的二义性</strong>：</p>
<ul>
<li>文法中的某个句子存在不同的语法树</li>
<li>有两个不同的最右（最左）推导</li>
<li>有两个不同的最左归约（规范归约），即归约中某些规范句型的句柄不唯一</li>
</ul>
<p><strong>消除二义性</strong>：</p>
<ul>
<li>根据条件修改编译算法，如定义优先级</li>
<li>根据条件直接修改文法</li>
</ul>
<h3 id="练习-2-4">练习 2-4</h3>
<h2 id="符号串的分析">2.5 符号串的分析</h2>
<blockquote>
<p>前面讨论了用已知文法推导和产生句子，下面讨论确定给定符号串是否是文法的句子</p>
<p>即已知文法 <span class="math inline">\(G[Z], s \in V^*_t\)</span>
，判定 <span class="math inline">\(s \in L(G[Z])\)</span>？</p>
<p>主要分为自顶向下和自底向上分析</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th></th>
<th>自顶向下分析</th>
<th>自底向上分析</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="有关文法的实用限制">2.6 有关文法的实用限制</h2>
<p>不能有有害规则、多余规则</p>
<p><strong>压缩文法</strong>：每一个终结符都满足条件一和条件二</p>
<h2 id="扩充的-bnf-表示和语法图">2.7 扩充的 BNF 表示和语法图</h2>
<ol type="1">
<li>扩充的 BNF 表示</li>
</ol>
<p>优点：</p>
<ul>
<li>表示方便</li>
<li>消除左递归，便于自顶向下分析</li>
</ul>
<p>具体规则：</p>
<ul>
<li>花括号 <code>&#123;&#125;</code>：<span class="math inline">\(\{t\} ^m
_n\)</span>，表示符号串 <span class="math inline">\(t\)</span>
可以重复连接 <span class="math inline">\(n\)</span> 到 $ m$ 次，若省略
<span class="math inline">\(n、m\)</span> 表示可连接 <span
class="math inline">\(0\)</span> 次到任意多次</li>
<li>方括号 <code>[]</code>：<span
class="math inline">\(\[t\]\)</span>，表示符号串 <span
class="math inline">\(t\)</span> 可有可无，<span
class="math inline">\([t] = \{t\} ^1 _0\)</span></li>
<li>圆括号 <code>()</code>：在规则中提取因子</li>
</ul>
<ol start="2" type="1">
<li>语法图</li>
</ol>
<h2 id="文法和语言分类">2.8 文法和语言分类</h2>
<ol type="1">
<li><p>乔姆斯基对文法的定义</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230429143851835.png"
alt="image-20230429143851835" />
<figcaption aria-hidden="true">image-20230429143851835</figcaption>
</figure>
<ol start="2" type="1">
<li><p>文法和语言分类</p>
<ol type="1">
<li><span class="math inline">\(0\)</span> 型文法（短语结构文法）</li>
<li><span class="math inline">\(1\)</span>
型文法（上下文敏感文法、上下文有关文法）</li>
<li><span class="math inline">\(2\)</span> 型文法（上下文无关文法）</li>
<li><span class="math inline">\(3\)</span> 型文法（正则文法）
<ul>
<li>与能为有穷状态自动机接受等价</li>
</ul></li>
</ol>
<p>文法的限制性依次增强</p></li>
</ol></li>
</ol>
<h1 id="第三章-词法分析程序的设计">第三章 词法分析程序的设计</h1>
<p>词法分析程序又称词法分析器或扫描器</p>
<p>大多数程序语言的词法规则属于乔姆斯基 <span
class="math inline">\(3\)</span> 型文法</p>
<p>通过状态图方便地设计词法分析程序</p>
<h2 id="词法分析器的功能及实现方案">3.1 词法分析器的功能及实现方案</h2>
<ol type="1">
<li>识别输出单词，并检查错误</li>
<li>转换数字</li>
<li>删去空格、换行、制表、注释等空白符</li>
</ol>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230429144433494.png"
alt="image-20230429144433494" />
<figcaption aria-hidden="true">image-20230429144433494</figcaption>
</figure>
<blockquote>
<p>将字符串表示的源程序转化为以单词表示的源程序</p>
</blockquote>
<h2 id="单词的种类及词法分析程序的输出形式">3.2
单词的种类及词法分析程序的输出形式</h2>
<ol type="1">
<li><p>单词的种类：见前</p></li>
<li><p>词法分析程序的输出形式 一般采用二元式，如</p>
<table>
<thead>
<tr class="header">
<th>单词类别</th>
<th>单词值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>整型</td>
<td>58</td>
</tr>
<tr class="even">
<td>保留字</td>
<td>for</td>
</tr>
</tbody>
</table></li>
<li><p>按单词种类分类或一符一类</p></li>
</ol>
<h2 id="正则文法及其状态图">3.3 正则文法及其状态图</h2>
<blockquote>
<p>画状态图并以之构造词法分析器</p>
</blockquote>
<h3 id="状态图">3.3.1 状态图</h3>
<p><strong>一个有向图</strong>，其中</p>
<ul>
<li><p>圆圈标识的结点表示状态，状态之间用有向弧连接，弧上的标记（字符）代表有向弧的射出结点状态下可能出现的输入字符。</p></li>
<li><p>包含有限个结点，包含初态和终态，终态用双圈表示</p></li>
</ul>
<h3 id="使用状态图分析字符串x">3.3.2 使用状态图分析字符串x</h3>
<blockquote>
<p>自底向上</p>
</blockquote>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428155920181.png"
alt="image-20230428155920181" />
<figcaption aria-hidden="true">image-20230428155920181</figcaption>
</figure>
<h2 id="词法分析程序的设计与实现">3.4 词法分析程序的设计与实现</h2>
<h3 id="文法及其状态图">3.4.1 文法及其状态图</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428160047564.png"
alt="image-20230428160047564" />
<figcaption aria-hidden="true">image-20230428160047564</figcaption>
</figure>
<h3 id="词法分析程序的构造">3.4.2 词法分析程序的构造</h3>
<p>将语义动作添加到状态图中，并使每一个状态都对应一小段程序</p>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428161120196.png"
alt="image-20230428161120196" />
<figcaption aria-hidden="true">image-20230428161120196</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230428161251494.png"
alt="image-20230428161251494" />
<figcaption aria-hidden="true">image-20230428161251494</figcaption>
</figure>
<h3 id="词法分析程序的实现">3.4.3 词法分析程序的实现</h3>
<p>先确定具体输出形式</p>
<ol type="1">
<li><p>输出形式</p>
<p>采用二元式</p></li>
</ol>
<figure>
<img src="D:\Programing\Compilers\Notes\WolfBook\Images\3.4.png"
alt="3.4" />
<figcaption aria-hidden="true">3.4</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsym</span><span class="params">()</span> &#123; <span class="comment">// 返回类别码</span></span><br><span class="line">    clearToken();</span><br><span class="line">    <span class="keyword">while</span> (isSpace() || isNewline() || isTab()) &#123;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isLetter()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isLetter() || isDigit()) &#123;</span><br><span class="line">            catToken();</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        retract();</span><br><span class="line">        <span class="type">int</span> result = reserver();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) </span><br><span class="line">            symbol = IDSY;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            symbol = result;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDigit()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isDigit()) &#123;</span><br><span class="line">            catToken();</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        retract();</span><br><span class="line">        num = transNum(token);</span><br><span class="line">        symbol = INTSY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isColon()) &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span> (isEqu()) </span><br><span class="line">            symbol = ASSIGNSY;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            retract();</span><br><span class="line">            symbol = COLONSY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlus()) &#123;</span><br><span class="line">            symbol = PLUSSY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isMinus()) &#123;</span><br><span class="line">            symbol = MINUSSY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isStar()) &#123;</span><br><span class="line">            symbol = STARSY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLpar()) &#123;</span><br><span class="line">            symbol = LPARSY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRpar()) &#123;</span><br><span class="line">            symbol = RPARSY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSemi()) &#123;</span><br><span class="line">            symbol = SEMISY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDivi()) &#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">if</span> (isStar()) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        getchar();</span><br><span class="line">                    &#125; <span class="keyword">while</span> (!isStar());</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        getchar();</span><br><span class="line">                        <span class="keyword">if</span> (isDivi())</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (isStar());</span><br><span class="line">                &#125; <span class="keyword">while</span> (!isStar());</span><br><span class="line">            &#125;</span><br><span class="line">            retract();</span><br><span class="line">            symbol = DIVISY;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            erro();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第4章-语法分析">第4章 语法分析</h1>
<blockquote>
<p>主要介绍自顶向下手工实现递归下降</p>
</blockquote>
<h2 id="自顶向下分析方法">4.1 自顶向下分析方法</h2>
<p>一般方法：带回溯的自顶向下分析方法</p>
<blockquote>
<p>本质上是一种试探方法，反复使用不同规则匹配输入串</p>
</blockquote>
<p>存在的问题：</p>
<ul>
<li><p>左递归问题——用扩充 BNF 文法改写</p>
<ul>
<li><p>提因子规则：消除左递归，压缩文法长度</p></li>
<li><p>替换规则：<span class="math inline">\(U::=x|y|\dots|z|Uv
\rightarrow U::=(x|y|\dots|z)\{v\}\)</span></p></li>
<li><p>改写为右递归：<span class="math inline">\(P::=Pa|b \rightarrow
P::=bP ^{\prime}\)</span> 和 <span class="math inline">\(P \prime
::=aP^{\prime} | \varepsilon\)</span></p></li>
<li><p>一般的改写算法：<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230429151541958.png"
alt="image-20230429151541958" /></p>
<blockquote>
<p>事实上就是先递归代入，再消除左递归，最后化简</p>
</blockquote></li>
</ul></li>
<li><p>回溯问题</p>
<ul>
<li><figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230429152458251.png"
alt="image-20230429152458251" />
<figcaption aria-hidden="true">image-20230429152458251</figcaption>
</figure></li>
</ul></li>
</ul>
<h2 id="递归下降分析法">4.2 递归下降分析法</h2>
<p><strong>主要做法</strong>：对文法中每一个非终结符号 <span
class="math inline">\(U\)</span>
都编写一个子程序完成其所对应的语法成分的分析和识别任务。子程序用该非终结符号的规则的右部符号串去匹配输入串</p>
<h2 id="基于递归下降分析法的语法分析程序构造">4.3
基于递归下降分析法的语法分析程序构造</h2>
<p><code>nextsym</code> ：扫描下一个符号并将类别码储存在
<code>sym</code> 中</p>
<p><code>error</code>
：调用出错处理程序打印错误信息，跳过分析过程中有错误的一段源程序</p>
<h1 id="第五章-符号表管理技术">第五章 符号表管理技术</h1>
<p>分析阶段：维护符号表</p>
<p>综合阶段：利用符号表生成目标代码</p>
<h2 id="概述">5.1 概述</h2>
<p><strong>符号表</strong>：记录<strong>源程序</strong>中各种标识符的特性信息的表格</p>
<p><strong>与遍数的关系</strong>：</p>
<ul>
<li>多遍扫描中在词法分析阶段填写，其他属性在语义分析和代码生成阶段填入</li>
<li>一遍：语义分析和代码生成</li>
</ul>
<p>标识符在源程序中的每一次出现都要与符号表打一次交道</p>
<p>若允许隐式声明，必须按首次引用处理</p>
<h2 id="符号表的组织和内容">5.2 符号表的组织和内容</h2>
<h3 id="符号表的结构和内容">5.2.1 符号表的结构和内容</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230429160114282.png"
alt="image-20230429160114282" />
<figcaption aria-hidden="true">image-20230429160114282</figcaption>
</figure>
<ul>
<li><p>标识符的种类：如简单变量、函数、过程、数组、标号、参数等。</p></li>
<li><p>类型：如整型、实型、字符型、指针等（一般用编码表示）</p></li>
<li><p>性质：变量形参、值形参等</p></li>
<li><p>值：标识符所代表的数值。</p></li>
<li><p>地址：标识符所分配单元的首地址或地址位移。</p></li>
<li><p>大小：所占的字节数。</p></li>
<li><p>作用域的嵌套层次：分程序结构语言中，标识符声明所在的分程序的层次。</p></li>
<li><p>标识符声明的源程序行号</p></li>
<li><p>标识符引用的源程序行号</p></li>
<li><p>以字母顺序排列的链域</p>
<blockquote>
<p>链域指向按字母排序的下一个标识符在符号表中的位置，便于产生按字母顺序排列的标识符交叉引用表</p>
<p>故如果不产生交叉引用表可以删去</p>
</blockquote></li>
</ul>
<p>对于一些特殊的名字，还要考虑较多的信息，如:</p>
<ul>
<li>对于数组，要考虑维数、上下界值、计算下标变量地址所用的信息以及数组元素类型等</li>
<li>对于记录（结构、联合），要考虑域的个数,每个域名、地址位移类型等</li>
<li>对于过程或函数，要考虑形参个数、所在层次、函数返回值类型、局部变量所占空间大小等</li>
<li>对于指针，要考虑所指对象类型等</li>
</ul>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230429160551515.png"
alt="image-20230429160551515" />
<figcaption aria-hidden="true">image-20230429160551515</figcaption>
</figure>
<h3 id="符号表的组织方式">5.2.2 符号表的组织方式</h3>
<ul>
<li><strong>统一符号表</strong>：按各种信息的并集设计表项
<ul>
<li>方便插入、查找</li>
<li>浪费空间</li>
</ul></li>
<li><strong>按标识符建立符号表</strong>：分别设计表项
<ul>
<li>节约空间</li>
<li>插入、查找开销大</li>
</ul></li>
<li><strong>折中</strong>：存储大部分共同信息，特殊信息另附表，二者用指针连接
<ul>
<li><figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230429160924281.png"
alt="image-20230429160924281" />
<figcaption aria-hidden="true">image-20230429160924281</figcaption>
</figure></li>
</ul></li>
</ul>
<blockquote>
<p>经典的时间和空间的 tradeoff</p>
</blockquote>
<p><strong>符号名的存储方法</strong>：</p>
<ul>
<li>预设长度
<ul>
<li>速度快，空间利用率低</li>
</ul></li>
<li>放置描述符
<ul>
<li>速度慢，节约空间</li>
</ul></li>
</ul>
<blockquote>
<p>就是数组实现方式和链表实现方式的区别</p>
</blockquote>
<h2 id="非分程序结构语言的符号表组织">5.3
非分程序结构语言的符号表组织</h2>
<p>主要介绍了散列技术，摆了</p>
<h2 id="分程序结构语言的符号表组织">5.4 分程序结构语言的符号表组织</h2>
<h3 id="标识符的作用域及基本处理方法">5.4.1
标识符的作用域及基本处理方法</h3>
<p>作用域局限在所定义的<strong>最小模块</strong>中</p>
<p>建表和查表的基本处理方法：</p>
<ul>
<li>在声明部分读到标识符时
<ul>
<li>查询所在程序单元符号表
<ul>
<li>已存在同名标识符——报错</li>
<li>不存在同名标识符——插入</li>
</ul></li>
</ul></li>
<li>在可执行部分读到标识符时
<ul>
<li>查询所在程序单元符号表
<ul>
<li>已存在同名标识符——已声明</li>
<li>不存在同名标识符
<ul>
<li>逐层查找外层符号表
<ul>
<li>已存在同名标识符——已声明，读取信息供使用</li>
<li>未存在同名标识符——使用了未声明的标识符</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li>语言预定义的标识符
<ul>
<li>放在最外层符号表</li>
</ul></li>
<li>分程序开始
<ul>
<li>定位</li>
</ul></li>
<li>分程序结束
<ul>
<li>重定位</li>
</ul></li>
</ul>
<h3 id="定位和重定位">5.4.2 定位和重定位</h3>
<blockquote>
<p>其嵌套方式显然对应着栈结构</p>
</blockquote>
<h3 id="符号表的组织方式-1">5.4.3 符号表的组织方式</h3>
<ol type="1">
<li>栈式符号表
<ul>
<li>遇到标识符声明——压栈</li>
<li>分程序结尾——仅弹栈而不彻底删除</li>
<li>性能较差，仅用于符号表较小时</li>
</ul></li>
<li>散列符号表的栈式实现</li>
</ol>
<h1 id="第六章-运行时的存储组织及管理">第六章
运行时的存储组织及管理</h1>
<h2 id="静态存储分配">6.1 静态存储分配</h2>
<p>对于编译时可以确定其存储空间大小的数据，可以在编译时就给它们分配固定的存储空间</p>
<p>其余数据则将分配存储过程留待目标程序运行时动态地进行</p>
<h2 id="动态内存分配">6.2 动态内存分配</h2>
<h3 id="活动记录">6.2.1 活动记录</h3>
<p>运行栈上的动作和普通栈上的动作相同。当进入一个模块时，就在运行栈的栈顶创建一个专用数据区，通常称为活动记录(Activation
Record)。活动记录的开始位置称为基</p>
<p><strong>注意栈的增长方向</strong></p>
<h3 id="参数区">6.2.2 参数区</h3>
<h3 id="display-区">6.2.3 display 区</h3>
<h3 id="运行时的地址计算">6.2.4 运行时的地址计算</h3>
<h3 id="递归过程的处理">6.2.5 递归过程的处理</h3>
<h2 id="内存垃圾回收器">6.3 内存垃圾回收器</h2>
<p>需要从编译器、操作系统甚至处理器芯片中获得信息</p>
<p>分析当前程序运行时产生的变量根集（root set）进行可达性分析</p>
<p>变量根集指在程序运行的某一时刻运行栈上所有变量或对象的集合，再加上当前程序的全局变量、静态变量等变量或对象</p>
<h3 id="引用计数">6.3.1 引用计数</h3>
<p>reference counting</p>
<p>指向该对象的引用被创建——count+1</p>
<p>已经存在的指向某对象的引用被删除或重写——count-1</p>
<p>e.g. <span class="math inline">\(P = Q\)</span> ，Q
指向对象的计数值-1，P 指向对象的计数值+1</p>
<p>回收一个对象可能会传递性地对其他对象的计数器进行-1操作，最后回收那些计数器变成0的对象</p>
<p>对于大部分高性能系统，引用计数已经被跟踪型垃圾回收器替代</p>
<h3 id="标记和清除垃圾回收器">6.3.2 标记和清除垃圾回收器</h3>
<p>两阶段回收垃圾：</p>
<ul>
<li>从对象根集开始遍历整个指针关系图，通过标识位区分死对象和活对象</li>
<li>垃圾回收，不移动内存堆中的对象。故主要弊端是<strong>内存碎片</strong></li>
</ul>
<h3 id="标记紧缩算法">6.3.3 标记紧缩算法</h3>
<p>在标记清除回收器的基础上引入紧缩技术</p>
<h3 id="拷贝回收算法">6.3.4 拷贝回收算法</h3>
<ul>
<li>空间利用率低</li>
</ul>
<h3 id="分代垃圾回收器">6.3.5 分代垃圾回收器</h3>
<h1 id="第七章-源程序的中间形式">第七章 源程序的中间形式</h1>
<blockquote>
<p>也即中间代码</p>
</blockquote>
<h2 id="波兰表示">7.1 波兰表示</h2>
<p>中缀转后缀算法：</p>
<ul>
<li>扫描到操作数，直接输出</li>
<li>遇到操作符，与栈顶元素比较优先级
<ul>
<li>栈顶 &gt; 栈外，输出栈顶</li>
<li>反之，操作符入栈</li>
</ul></li>
</ul>
<p>波兰表示<strong>不便优化</strong></p>
<h2 id="n-元表示">7.2 N-元表示</h2>
<p>三元式：<操作符1>,<操作数1>,<操作数2></p>
<p>一组三元式，前面三元式的计算结果可用该三元式的编号表示</p>
<p>四元式：<操作符1>,<操作数1>,<操作数2>,<结果></p>
<h2 id="抽象语法树">7.3 抽象语法树</h2>
<p>非叶结点：操作符</p>
<p>叶结点：操作数</p>
<p><strong>与前两种表示的联系</strong>：后续遍历可以得到后缀表达式，</p>
<h2 id="抽象机代码">7.4 抽象机代码</h2>
<p>摆了</p>
<h1 id="第八章-错误处理">第八章 错误处理</h1>
<h2 id="概述-1">8.1 概述</h2>
<p>编译程序的错误处理能力包括：</p>
<ul>
<li>检查出各类错误的能力</li>
<li>准确地指出出错位置及错误性质的能力</li>
<li>通过一次编译能将源程序中的错误尽可能都找出来的能力</li>
<li>具有一定的错误改正的能力</li>
<li>遏止重复错误信息的能力</li>
</ul>
<h2 id="错误的分类">8.2 错误的分类</h2>
<ul>
<li>语法错误：不符合语法（词法）规则
<ul>
<li>如漏掉一半括号等</li>
</ul></li>
<li>语义错误：不符合语义或超越具体计算机的限制
<ul>
<li>如标识符先声明才能引用，形参实参个数匹配</li>
<li>溢出错误，如计算结果太大；符号表、数据存储区等溢出</li>
</ul></li>
</ul>
<h2 id="错误的检查与报告">8.3 错误的检查与报告</h2>
<p>一些语义错误要由目标程序检查出来</p>
<ul>
<li>如下标越界</li>
<li>处理方法一般是编译时生成有关检验指令</li>
</ul>
<p>报告错误的两种方式</p>
<ul>
<li>分析完再打印，需要单独开辟空间</li>
<li>边分析边打印，有可能检测不出来</li>
</ul>
<h2 id="错误处理技术">8.4 错误处理技术</h2>
<p>两种错误处理办法</p>
<ul>
<li>错误改正
<ul>
<li>太难了没有编译器做到</li>
</ul></li>
<li>错误局部化处理
<ul>
<li>暂停并跳过对出错部分的分析</li>
<li>实现：在编译程序中设置专用变量存放指定的右界符</li>
</ul></li>
</ul>
<p>遏制重复的错误信息</p>
<ul>
<li><p>建立出错名字表，类似如下代码段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.java</span></span><br><span class="line"><span class="keyword">if</span> (errorMap.containsKey(unDefinedModifier)) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    put(unDefinedModifier, errorMessage);</span><br><span class="line">    <span class="comment">// print something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设置标志位，类似 <code>isVisited</code></p></li>
</ul>
<h1 id="第九章-语法制导翻译技术">第九章 语法制导翻译技术</h1>
<blockquote>
<p>翻译文法、属性文法、自顶向下语法制导翻译技术</p>
</blockquote>
<h2 id="翻译文法">9.1 翻译文法</h2>
<figure>
<img
src="D:\Programing\Compilers\Notes\WolfBook\Images\活动序列动作符号.png"
alt="活动序列动作符号" />
<figcaption aria-hidden="true">活动序列动作符号</figcaption>
</figure>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230430222848882.png"
alt="image-20230430222848882" />
<figcaption aria-hidden="true">image-20230430222848882</figcaption>
</figure>
<p><strong>翻译文法</strong>：终结符号集由输入符号和动作符号组成的上下文无关文法。</p>
<p><strong>活动序列</strong>：翻译文法确定的语言中的符号串</p>
<h2 id="语法制导翻译">9.2 语法制导翻译</h2>
<blockquote>
<p>形式上，将翻译看成偶对的集合，第一个元素是输入语言中的符号串，第二个元素是翻译该符号串时的动作序列或执行动作序列所规定的操作后生成的新符号串</p>
<p>即 符号串 <span class="math inline">\(\rightarrow\)</span>
动作序列</p>
<p>或 符号串 <span class="math inline">\(\rightarrow\)</span>
动作序列生成的新符号串</p>
<p>在翻译文法是符号串翻译文法的时候可以认为二者同义</p>
</blockquote>
<p><strong>语法制导翻译</strong>：给定一输入符号串，根据输入文法获得翻译该符号串的动作序列，并执行该动作序列所规定的动作的过程</p>
<blockquote>
<p>翻译文法定义的翻译</p>
</blockquote>
<p><strong>输入序列</strong>：表示从活动序列中删掉所有<strong>动作符号</strong>而得到的符号序列
<strong>动作序列</strong>：表示从活动序列中删掉所有<strong>输入符号</strong>而得到的符号序列</p>
<blockquote>
<p>你俩在这玩相爱相杀是吧</p>
</blockquote>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230430224236885.png"
alt="image-20230430224236885" />
<figcaption aria-hidden="true">image-20230430224236885</figcaption>
</figure>
<h2 id="属性翻译文法">9.3 属性翻译文法</h2>
<h3 id="综合属性">9.3.1 综合属性</h3>
<p>将翻译文法中无值的符号扩充为有值的，值部分称为符号的属性</p>
<blockquote>
<p>产生式中左部符号的属性值是通过计算右部符号的属性值得来的</p>
</blockquote>
<h3 id="继承属性">9.3.2 继承属性</h3>
<figure>
<img
src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230501102809077.png"
alt="image-20230501102809077" />
<figcaption aria-hidden="true">image-20230501102809077</figcaption>
</figure>
<h2 id="自顶向下语法制导翻译">9.4 自顶向下语法制导翻译</h2>
<p>// to be continued</p>
<blockquote>
<p>这章好抽象啊，不知道对于实验需要的内容有多大帮助，反正连滚带爬读完了，理论内容先放一放</p>
</blockquote>
<h1 id="第十章-语义分析和代码生成">第十章 语义分析和代码生成</h1>
<h2 id="语义分析的概念">10.1 语义分析的概念</h2>
<p>处理上下文有关文法的方式：用专门的语义动作来补充上下文无关分析器的动作，即<strong>借助语义分析</strong></p>
<p>语义分析要处理的问题</p>
<ul>
<li>我没读出来作者的意思，所以这条鸽了</li>
<li>表达式和赋值语句操作数的类型一致性检查</li>
<li>分析语义并做相应的语义处理</li>
</ul>
<h2 id="栈式抽象机及其汇编指令">10.2 栈式抽象机及其汇编指令</h2>
<p>table</p>
<h2 id="声明语句的处理">10.3 声明语句的处理</h2>
<p>编译器分离出每个实体，并填符号表</p>
<p>声明后，可以使用符号表中信息</p>
<ul>
<li>检查对所声明的实体引用是否正确</li>
<li>利用已声明实体的特性信息，为给定源程序生成特定的目标代码</li>
</ul>
<h3 id="常量类型">10.3.1 常量类型</h3>
<h3 id="简单变量">10.3.2 简单变量</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">staticvardef</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> i, <span class="type">char</span> *n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = tableinsert(n, t, i);</span><br><span class="line">    <span class="comment">/*给定一简单变量n的类型,所需的数据空间大小i。tableinsert将n和属性i及t一起填入符号表。</span></span><br><span class="line"><span class="comment">    i用作临时变量,记录函数返回值。*/</span></span><br><span class="line">    <span class="keyword">if</span> (j == DUPLICATION) &#123;</span><br><span class="line">        errmsg(duplident, statmtno);<span class="comment">/*输出相关的错误信息*/</span> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == OVERFLOW) &#123;</span><br><span class="line">        errmsg(tableoverflow, staticnumber);</span><br><span class="line">        <span class="built_in">abort</span>();        <span class="comment">/*符号表溢出,编译失败,终止编译程序*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">allocsv</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">/*存储分配*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*设简单变量所要求的数据空间大小为i,由此可更新指针 codeptr 的内容*/</span></span><br><span class="line">    codeptr = codeptr + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组变量">10.3.3 数组变量</h3>
<p>编译程序在处理数组声明时将建立一个模板，以便在执行期间能够间接引用该数组的元素。</p>
<ul>
<li>静态数组——在编译期间建立</li>
<li>动态数组——在编译时仅为模板的建立分配一个空间，而模板本身将在运行时建立</li>
</ul>
<p><strong>数组绝对地址的计算</strong></p>
<h3 id="记录变量">10.3.4 记录变量</h3>
<p>用来引用几个不同名字所组成的实体</p>
<h3 id="过程声明">10.3.5 过程声明</h3>
<h2 id="表达式语句">10.4 表达式语句</h2>
<p>将表达式的操作数装载到操作数栈栈顶或寄存器，执行操作后将结果保留在操作数栈栈顶或寄存器</p>
<h2 id="赋值语句">10.5 赋值语句</h2>
<p>如果支持对数组的赋值，需要先找到数组的地址，继而使用内部计数器增值的方法产生对所有数组元素的引用</p>
<h2 id="控制语句">10.6 控制语句</h2>
<h3 id="if-语句">10.6.1 <code>if</code> 语句</h3>
<h3 id="case-语句">10.6.2 <code>case</code> 语句</h3>
<h3 id="while-语句">10.6.3 <code>while</code> 语句</h3>
<h3 id="for-语句">10.6.4 <code>for</code> 语句</h3>
<h2 id="过程调用和返回语句">10.7 过程调用和返回语句</h2>
<p>// to be continued</p>
<h2 id="输入输出语句">10.8 输入/输出语句</h2>
<p>// to be continued</p>
<h2 id="编译程序的辅助功能">10.9 编译程序的辅助功能</h2>
]]></content>
      <categories>
        <category>Notes</category>
        <category>S5</category>
        <category>编译</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学笔记</title>
    <url>/combinatorics-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>2023 春组合数学笔记，全部资料参见我的 Github <a
href="%5BStrivingLee/Introductory-Combinatorics:%20Course%20resources%20of%20BUAA%20introductory%20combinatorics%20(github.com)%5D(https://github.com/StrivingLee/Introductory-Combinatorics)">Click
here to see the remote repository</a></p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>总思路：存在 <span class="math inline">\(\rightarrow\)</span> 计数
<span class="math inline">\(\rightarrow\)</span> 算法 <span
class="math inline">\(\rightarrow\)</span> 优化</p>
</blockquote>
<h3 id="timeline">TimeLine</h3>
<p>Created: 2023.05.09</p>
<p>Maximum change: 2023.06.09</p>
<p>Finish: 2023.06.13</p>
<h3 id="第1章-引论">第1章 引论</h3>
<h4 id="例1幻方">例1：幻方</h4>
<p><span class="math inline">\(2\)</span> 阶幻方不存在，对于任意 $n &gt;
3 $ 的整数 <span class="math inline">\(n\)</span>，都存在一个 <span
class="math inline">\(n\)</span> 阶幻方</p>
<h4 id="例236-军官问题">例2：<span class="math inline">\(36\)</span>
军官问题</h4>
<h4 id="例3完美覆盖问题">例3：完美覆盖问题</h4>
<h4 id="一般化">一般化：</h4>
<p>$ m n $ 棋盘被 <span class="math inline">\(b\)</span> -
牌完美覆盖，当且仅当 <span class="math inline">\(b\)</span> 是 <span
class="math inline">\(m\)</span> 或 <span
class="math inline">\(n\)</span> 的一个因子</p>
<h4 id="延伸问题断层线-fault-line">延伸问题：断层线 (Fault Line)</h4>
<p><span class="math inline">\(4 \times 4\)</span> 棋盘用 <span
class="math inline">\(8\)</span>
张多米诺牌完美覆盖，证明：总可以将这个棋盘横向或纵向分成非空两个部分，且没有牌被切断</p>
<p><img src="Images\FaultLine.jpg" alt="FaultLine" style="zoom: 33%;" /></p>
<h4 id="例4相互重叠的圆递推公式">例4：相互重叠的圆（递推公式）</h4>
<p>设这 <span class="math inline">\(h_n\)</span> 个圆将平面分为 <span
class="math inline">\(m\)</span> 个区域，当加入第 <span
class="math inline">\(n\)</span> 个圆时，这个圆与前面 <span
class="math inline">\(n-1\)</span> 个圆交于 <span
class="math inline">\(2(n-1)\)</span> 个点，这 <span
class="math inline">\(2(n-1)\)</span> 个点把第 <span
class="math inline">\(n\)</span> 个圆分成 <span
class="math inline">\(2(n-1)\)</span> 条弧，每条弧将其经过的区域分成
<span class="math inline">\(2\)</span> 个区域（在前面的 <span
class="math inline">\(n-1\)</span> 个圆分成的区域中），故新加入的第
<span class="math inline">\(n\)</span> 个圆使区域数增加了 <span
class="math inline">\(2(n-1)\)</span></p>
<p>建立递推关系如下： <span class="math display">\[
h_n = h_{n-1} + 2(n-1) (n \geq 2) \\ h_1 = 2
\]</span></p>
<blockquote>
<p>解决问题的一般顺序：求通项 <span
class="math inline">\(\rightarrow\)</span> 求递推公式 <span
class="math inline">\(\rightarrow\)</span> 诉诸生成函数</p>
</blockquote>
<h4 id="例5nim-取子游戏">例5：<span class="math inline">\(Nim\)</span>
取子游戏</h4>
<p>有 <span class="math inline">\(k(\geq 1)\)</span> 堆石子，分别含有
<span class="math inline">\(n_1,n_2,\dots, n_k\)</span> 个子</p>
<p>游戏规则:</p>
<ul>
<li>游戏人 <span class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 交替从这些堆里取一定数量石子</li>
<li>取子时，只能选择其中一堆，并且取至少一个石子</li>
<li>最后取完子的人为胜者</li>
</ul>
<p>定义：<span class="math inline">\(n_1, n_2, \dots, n_k\)</span>
是正整数，若它们的二进制数码的<strong>异或值</strong>为 <span
class="math inline">\(0\)</span>，则称它们处于<strong>平衡状态</strong>，否则处于<strong>非平衡状态</strong></p>
<p>结论：<span class="math inline">\(A\)</span> 能在非平衡的 <span
class="math inline">\(Nim\)</span> 取子中获胜，而 <span
class="math inline">\(B\)</span> 能在平衡的 <span
class="math inline">\(Nim\)</span> 取子中获胜</p>
<h3 id="第2章-排列与组合"><strong>第2章 排列与组合</strong></h3>
<h4 id="个基本的计数原理">2.1：4个基本的计数原理</h4>
<ul>
<li>加法原理、乘法原理、减法原理、除法原理
<ul>
<li>例：确定数 <span class="math inline">\(3^4 \times 5^2 \times 11^7
\times 13^8\)</span> 的正整数因子的个数（<strong>注意每个因子取 <span
class="math inline">\(0\)</span> 次！！！</strong>因为 <span
class="math inline">\(1\)</span> 也是因子）</li>
<li>解：由乘法原理，<span class="math inline">\(5 \times 3 \times 8
\times 9\)</span></li>
</ul></li>
</ul>
<h4 id="集合的排列">2.2：集合的排列</h4>
<ul>
<li><p>从 <span class="math inline">\(n\)</span> 个不同元素取出 <span
class="math inline">\(r\)</span> 个元素有序摆放，称 <span
class="math inline">\(n\)</span> 元素集合的 <span
class="math inline">\(r\)</span> - 排列。 用 <span
class="math inline">\(P(n, r)\)</span> 表示 <span
class="math inline">\(n\)</span> 元素集合的全部 <span
class="math inline">\(r\)</span> - 排列数。</p></li>
<li><p>全排列：列出全部元素的排列</p></li>
<li><p><span class="math inline">\(P(n, r) =
\dfrac{n!}{(n-r)!}\)</span></p></li>
<li><p>分步递推：<span class="math inline">\(P(n, r)=n \times
P(n-1,r-1)\)</span></p>
<ul>
<li><p>选择 <span class="math inline">\(1\)</span> 号盒子，放入 <span
class="math inline">\(1\)</span> 个乒乓球</p></li>
<li><p>从 <span class="math inline">\(n-1\)</span> 个球中选出 <span
class="math inline">\(r-1\)</span> 个放入 <span
class="math inline">\(r-1\)</span> 个盒子排列</p></li>
</ul></li>
<li><p>分类递推：<span class="math inline">\(P(n,
r)=P(n-1,r)+rP(n-1,r-1)\)</span></p>
<ul>
<li><p>不选第 <span class="math inline">\(1\)</span> 个球</p></li>
<li><p>选择第 <span class="math inline">\(1\)</span> 个球</p></li>
</ul></li>
<li><p>循环排列：只考虑元素间的相对顺序</p></li>
<li><p><strong>定理2.2.2：</strong> <span
class="math inline">\(n\)</span> 个元素集合的循环 <span
class="math inline">\(r\)</span> 排列个数为： <span
class="math display">\[
\dfrac{P(n, r)}{r}
\]</span></p>
<ul>
<li><p>例：<span class="math inline">\(10\)</span> 个人围坐圆桌，<span
class="math inline">\(2\)</span> 人不彼此相邻，求总排列方法数</p></li>
<li><p><span class="math inline">\((10 - 1)! - 2 \times (9 -
1)!\)</span></p></li>
<li><p>先固定一个人 <span class="math inline">\(P_1\)</span>，然后 <span
class="math inline">\(P_2\)</span> 可选位置为 <span
class="math inline">\(7\)</span>，余下 <span
class="math inline">\(8\)</span> 人任意坐，共 <span
class="math inline">\(7 \times 8!\)</span></p></li>
</ul></li>
<li><p>若是项链排列，为上式除以 <span
class="math inline">\(2\)</span>，考虑正反翻转 <span
class="math inline">\(2\)</span> 种情况</p></li>
</ul>
<h4 id="集合的组合">2.3：集合的组合</h4>
<ul>
<li><p>从 <span class="math inline">\(n\)</span> 个元素中无序地取出
<span class="math inline">\(r\)</span> 个元素，称 <span
class="math inline">\(n\)</span> 元素集合的 <span
class="math inline">\(r\)</span> - 组合。用 <span
class="math inline">\(\left( \begin{matrix} n \\ r
\end{matrix}\right)\)</span> 表示 <span class="math inline">\(n\)</span>
元素集合的全部 <span class="math inline">\(r\)</span> -
组合数。</p></li>
<li><p>约定：</p>
<ul>
<li><p><span class="math inline">\(\left(
\begin{matrix}0\\0\end{matrix}\right)=1\)</span></p></li>
<li><p>当 <span class="math inline">\(r &gt; n\)</span> 时，<span
class="math inline">\(\left(
\begin{matrix}n\\r\end{matrix}\right)=1\)</span></p>
<blockquote>
<p>选择的个数多于总个数时计数为 <span
class="math inline">\(0\)</span></p>
</blockquote></li>
</ul></li>
<li><p>选班委公式：<span class="math inline">\(C(n,r)C(r,k)=C(n,k)C(n-k,
r-k)\)</span>。</p>
<ul>
<li><p>选出 <span class="math inline">\(r\)</span> 个班委、<span
class="math inline">\(k\)</span> 个常委</p></li>
<li><p>先选出 <span class="math inline">\(k\)</span> 个常委，再选出
<span class="math inline">\(r-k\)</span> 个其他班委</p></li>
</ul></li>
<li><p><strong>定理2.3.3（Pascal公式）：</strong>对于满足 <span
class="math inline">\(1 \le k \le n - 1\)</span> 的整数 <span
class="math inline">\(k\)</span> 和 <span
class="math inline">\(n\)</span>，有</p>
<ul>
<li><p><span class="math display">\[
\left( \begin{matrix}n\\k\end{matrix}\right) = \left( \begin{matrix}n -
1\\k\end{matrix}\right) + \left( \begin{matrix}n - 1\\k -
1\end{matrix}\right)
\]</span></p></li>
<li><p>组合证明：</p></li>
<li><p>不包含某个元素 <span class="math inline">\(x\)</span> 的 <span
class="math inline">\(k\)</span> 子集 <span class="math inline">\(\left(
\begin{matrix}n-1\\k\end{matrix}\right)\)</span> 个</p></li>
<li><p>包含这个元素 <span class="math inline">\(x\)</span> 的 <span
class="math inline">\(k\)</span> 子集 <span class="math inline">\(\left(
\begin{matrix}n-1\\k-1\end{matrix}\right)\)</span>​ 个</p></li>
</ul></li>
<li><p>公式：<span class="math inline">\(\left(
\begin{matrix}n\\0\end{matrix}\right)+\left(
\begin{matrix}n\\1\end{matrix}\right)+\left(
\begin{matrix}n\\2\end{matrix}\right)+...+\left(
\begin{matrix}n\\n\end{matrix}\right)=2^n\)</span>
（用子集数量组合计数证明）</p></li>
</ul>
<h4 id="多重集的排列">2.4：多重集的排列</h4>
<blockquote>
<p>主要分无限重复和有限重复</p>
</blockquote>
<ul>
<li><p><strong>定义：</strong><span class="math inline">\(M =
\{a,a,b,c,c,c\} = \{2 \cdot a, 1 \cdot b, 3 \cdot c\}\)</span>，称 <span
class="math inline">\(2, 1, 3\)</span> 是重复集的重数</p>
<ul>
<li>允许元素重复</li>
<li>允许无限重数</li>
</ul></li>
<li><p><strong>定理2.4.2：</strong>令 <span
class="math inline">\(S\)</span> 是多重集，它有 <span
class="math inline">\(k\)</span> 种不同的元素，每种元素的重复数分别为
<span class="math inline">\(n_1，n_2，…，n_k\)</span>，那么，<span
class="math inline">\(S\)</span> 的排列数等于 <span
class="math display">\[
\dfrac{n!}{n_1!n_2!...n_k!}
\]</span></p>
<ul>
<li>证明：依次摆放，约去多余项</li>
<li>例如：数字 <span class="math inline">\(1,1,1, 3, 8\)</span>
可以构造出多少个不同的 <span class="math inline">\(5\)</span>
位数？即</li>
</ul>
<p><span class="math display">\[
\dfrac{5!}{3!1!1!}=20
\]</span></p></li>
<li><p><strong>定理2.4.3：</strong>设 <span class="math inline">\(n =
n_1 + n_2 + \dots + n_k\)</span>，将 <span
class="math inline">\(n\)</span> 个元素集合划分为做了标签的 <span
class="math inline">\(k\)</span> 个盒子 <span class="math inline">\(B_1,
B_2, \dots ,B_k\)</span>，其中 <span class="math inline">\(B_i\)</span>
盒子含有 <span class="math inline">\(n_i\)</span> 个元素，方法数为 <span
class="math display">\[
\dfrac{n!}{n_1!n_2! \dots n_k!}
\]</span> 若盒子无标号且 <span class="math inline">\(n_1 = n_2 = \dots =
n_k\)</span>，则划分数为 <span class="math display">\[
\dfrac{n!}{k!n_1!n_2! \dots n_k!}
\]</span></p>
<blockquote>
<p>多重集的另一种解释：集合划分</p>
<p>如果不是所有的划分数都相等，就需要相同个数的划分去重</p>
</blockquote>
<ul>
<li><p>例：将 <span class="math inline">\(7\)</span> 个不同颜色的球放入
<span class="math inline">\(3\)</span>
个无区别的盒子中，要求每盒球数目不少于 <span
class="math inline">\(2\)</span>，求解放置方案数。</p></li>
<li><p>解：放置方法必为 <span
class="math inline">\(223\)</span>，故方案数为（第一个 <span
class="math inline">\(2!\)</span> 为划分去重） <span
class="math display">\[
\dfrac{7!}{2!2!2!3!} = 105
\]</span></p></li>
</ul></li>
<li><p><strong>定理2.4.4（非攻击性车摆放）：</strong>有 <span
class="math inline">\(n\)</span> 个车共 <span
class="math inline">\(k\)</span> 种颜色，其中第一种颜色的车有 <span
class="math inline">\(n_1\)</span> 个，第二种颜色的车有 <span
class="math inline">\(n_2\)</span> 个，<span
class="math inline">\(\dots\)</span>，第 <span
class="math inline">\(k\)</span> 种颜色的车有 <span
class="math inline">\(n_k\)</span> 个，那么，把这些车放到 <span
class="math inline">\(n \times n\)</span>
的棋盘上，使得没有车能相互攻击的摆放方法数为： <span
class="math display">\[
\dfrac{n!}{n_1!n_2!...n_k!}\cdot n! = \dfrac{(n!)^2}{n_1!n_2!...n_k!}
\]</span></p>
<ul>
<li>例如：当 <span class="math inline">\(8\)</span> 个车，<span
class="math inline">\(1\)</span> 个红车，<span
class="math inline">\(3\)</span> 个蓝车和 <span
class="math inline">\(4\)</span> 个黄车。非攻击车摆放的方法数：</li>
</ul>
<p><span class="math display">\[
8! \times \dfrac{8!}{1!3!4!} = \dfrac{(8!)^2}{3!4!}
\]</span></p>
<blockquote>
<p>先排车，再给车排颜色</p>
</blockquote></li>
</ul>
<h4 id="多重集的组合">2.5：多重集的组合</h4>
<blockquote>
<p>相当于将 <span class="math inline">\(r\)</span> 个相同元素分成 <span
class="math inline">\(k\)</span>
个不同区域，每个区域对应一种元素——隔板法</p>
<p>多重集组合 <span class="math inline">\(\Leftrightarrow\)</span>
不定方程解集 <span class="math inline">\(\Leftrightarrow\)</span>
多重集排列</p>
<p>多重集 <span class="math inline">\(S\)</span> 的 <span
class="math inline">\(r\)</span> - 组合数等于多重集 <span
class="math inline">\(T\)</span> 的排列数</p>
</blockquote>
<ul>
<li><p><strong>定理2.5.1：</strong>令 <span
class="math inline">\(S\)</span> 是多重集，它有 <span
class="math inline">\(k\)</span>
个不同的元素，每个元素都有无限重复次数，那么，<span
class="math inline">\(S\)</span> 的 <span
class="math inline">\(r\)</span> - 组合个数为： <span
class="math display">\[
\left(
\begin{matrix}
r+k-1 \\
r
\end{matrix}
\right)
=
\left(
\begin{matrix}
r+k-1 \\
k-1
\end{matrix}
\right)
\]</span></p>
<ul>
<li><p>例：令 <span class="math inline">\(S＝\{12 \cdot a, 12\cdot b,
12\cdot c\}\)</span>，求 <span class="math inline">\(S\)</span> 的 <span
class="math inline">\(12\)</span> - 组合个数： <span
class="math display">\[
\left(
\begin{matrix}
12+3-1 \\
12
\end{matrix}
\right)=\dfrac{14!}{12!2!}
\]</span></p></li>
<li><p>例：方程 <span class="math inline">\(x_1+x_2+x_3+x_4=20\)</span>
的整数解的个数是多少？其中 <span class="math inline">\(x_1\geq 3,
x_2\geq 1, x_3\geq 0, x_4\geq 5\)</span></p>
<p>作变量代换：<span class="math inline">\(y_1=x_1-3， y_2=x_2-1，
y_3=x_3，y_4=x_4-5\)</span>，那么，得到方程：$ y_1+y_2+y_3+y_4=11$ <span
class="math display">\[
\left(
\begin{matrix}
11+4-1 \\
11
\end{matrix}
\right)=
\left(
\begin{matrix}
14 \\
11
\end{matrix}
\right)
\]</span></p></li>
<li><p>例（出现次数下界约束）：令 <span class="math inline">\(S＝{12
\cdot a, 12 \cdot b, 12 \cdot c }\)</span>。求 <span
class="math inline">\(S\)</span> 的使得 <span
class="math inline">\(3\)</span> 个元素都至少出现一次的 <span
class="math inline">\(12\)</span> - 组合个数。</p>
<ul>
<li>令 <span class="math inline">\(y_i = x_i -
1\)</span>，求非负整数解，套用公式</li>
</ul></li>
<li><p>上界约束：用其他方法做就行，不必拘泥这一章知识</p></li>
</ul></li>
</ul>
<h4 id="x其它一些题目">2.x：其它，一些题目</h4>
<ul>
<li><p>把 <span class="math inline">\(2n\)</span> 个人分成 <span
class="math inline">\(n\)</span> 组，每组 <span
class="math inline">\(2\)</span> 人，有多少分法？</p>
<p>等价为分组问题，相当于将 <span class="math inline">\(2n\)</span>
个不同球投入 $n $ 个相同的盒子中，每个盒子 <span
class="math inline">\(2\)</span> 个。【有点像定理2.4.2除以 <span
class="math inline">\(n!\)</span> 的变体】 <span class="math display">\[
\dfrac{2n!}{(2!)^n \cdot n!}=\dfrac{2n!}{2^n \cdot n!}
\]</span></p></li>
<li><p><strong>不相邻选取问题：</strong>从 <span
class="math inline">\(\{1, 2, \dots, n\}\)</span> 中取出 <span
class="math inline">\(r\)</span> 个不相邻的数，这样的组合有多少种？</p>
<p><span class="math inline">\(\left( \begin{matrix} n-r+1 \\ r
\end{matrix} \right)\)</span> 种，相当于往 $n-r $ 个数的 <span
class="math inline">\(n-r+1\)</span> 个间隔里插入 <span
class="math inline">\(r\)</span>
个<strong>被选取的数</strong>作为“隔板”</p></li>
</ul>
<h3 id="第3章-鸽巢原理"><strong>第3章 鸽巢原理</strong></h3>
<blockquote>
<p>证明存在性的一种主要手段</p>
</blockquote>
<h4 id="鸽巢原理的简单形式">3.1 鸽巢原理的简单形式</h4>
<ul>
<li><p>例：证明，如果从 <span class="math inline">\({1, 2, …,
2n}\)</span> 中任意选择 <span class="math inline">\(n+1\)</span>
个不同的整数，那么一定存在两个整数，它们之间差为 $ 1$。</p>
<p>将集合 <span class="math inline">\(\{1, 2, \dots ,2n\}\)</span>
划分成 <span class="math inline">\(n\)</span> 个子集 <span
class="math inline">\(S_1, S_2, \dots , S_n\)</span>，其中 <span
class="math inline">\(S_n = \{2i-1, 2i\}, i = 1, 2, \dots
,n\)</span></p>
<p>设选择的 <span class="math inline">\(n+1\)</span> 个整数为 $ a_1&lt;
a_2 &lt;…&lt;a_{n+1}$。令 <span class="math inline">\(b_1=a_1+1,
b_2=a_2+1, …, b_{n+1} = a_{n+1} +1\)</span>。此 $ 2n+2$
个数中至少有一对数相等，由于 <span class="math inline">\(a_1, \dots,
a_n\)</span> 互不相等，且 <span class="math inline">\(b_1, \dots
,b_n\)</span> 互不相等。因此存在一对 <span class="math inline">\(b_j =
a_j + 1\)</span> 与 <span class="math inline">\(a_k\)</span> 相等 <span
class="math inline">\((j \ne k)\)</span></p>
<ul>
<li>扩展：从 <span class="math inline">\(1,2, \dots, kn\)</span>
中任意选择 <span class="math inline">\(n+1\)</span> 个，则存在差为 <span
class="math inline">\(k-1\)</span></li>
</ul></li>
<li><p>例：证明，在 <span class="math inline">\(m\)</span> 个正整数
<span class="math inline">\(a_1, a_2, …, a_m\)</span> 中，存在 <span
class="math inline">\(0\leq k&lt; l \leq m\)</span>，使得 <span
class="math inline">\(a_{k+1}+ a_{k+2}+ …+a_l\)</span> 能够被 <span
class="math inline">\(m\)</span> 整除。</p>
<p>证：考虑 <span class="math inline">\(m\)</span> 个和（<span
class="math inline">\(s_m\)</span> 是正整数的前 <span
class="math inline">\(n\)</span> 项和）： <span class="math display">\[
s_1=a_1, s_2=a_1+a_2, s_3=a_1+a_2+a_3, …, s_m=a_1+a_2+…+a_m
\]</span></p>
<ul>
<li><p>若以上和中有一个能被 <span class="math inline">\(m\)</span>
整除，则结论成立；</p>
<blockquote>
<p>这是从头开始的部分和</p>
</blockquote></li>
<li><p>否则设 <span class="math inline">\(r_1, r_2, \dots ,r_n\)</span>
为 <span class="math inline">\(s_1, s_2, \dots ,s_n\)</span> 除以 <span
class="math inline">\(m\)</span> 的非零余数，则 <span
class="math inline">\(1 \leq r_i \leq m-1, i = 1, \dots
,m\)</span>。由鸽巢原理，存在 <span class="math inline">\(r_l = r_k, l
&gt; k\)</span>，则 <span class="math inline">\(a_{k+1} + a_{k+2} +
\dots + a_l\)</span> 能被 <span class="math inline">\(m\)</span>
整除</p>
<blockquote>
<p>这是从中间开始的部分和</p>
</blockquote></li>
</ul></li>
<li><p>例：从整数 <span class="math inline">\(1, 2, …，200\)</span>
中选取 <span class="math inline">\(101\)</span>
个整数。证明所选的数中存在两个整数，使得其中一个是另一个的因子。</p>
<p>证：对于 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(200\)</span> 间的整数 <span
class="math inline">\(n\)</span>，<span class="math inline">\(n\)</span>
可写作以下形式：<span class="math inline">\(n=2^k \times
a\)</span>（其中 <span class="math inline">\(a\)</span> 是 <span
class="math inline">\(1, 2, …, 200\)</span> 内的奇数）</p>
<p>由于要选取 <span class="math inline">\(101\)</span> 个整数，而 <span
class="math inline">\(200\)</span> 内只有 <span
class="math inline">\(100\)</span> 个奇数，由鸽巢原理知必存在两个整数
<span class="math inline">\(n_1\)</span> 与 <span
class="math inline">\(n_2\)</span>
写作上式形式后，两数中的奇数因子相等，均为 <span
class="math inline">\(b\)</span>。 假设 <span
class="math inline">\(n_1=2^{k1} \times b, n_2=2^{k2} \times
b\)</span>，其中 <span class="math inline">\(b\)</span> 是 <span
class="math inline">\(1, 2, …, 200\)</span> 内的奇数。显然，当 <span
class="math inline">\(k_1 \geq k_2\)</span> 时，<span
class="math inline">\(n_2\)</span> 整除 <span
class="math inline">\(n_1\)</span>；否则 <span
class="math inline">\(n_1\)</span> 整除 <span
class="math inline">\(n_2\)</span>。</p></li>
<li><p>例：某厂在五年期间的每一个月里至少试制一种新产品，每年最多试制
<span class="math inline">\(19\)</span>
种新产品。试证明：一定存在连续几个月，恰好试制 <span
class="math inline">\(24\)</span> 种新产品。</p>
<p>证：设五年间每个月新产品数分别为 <span class="math inline">\(a_1,
a_2, \dots , a_{59}, a_{60}\)</span>。构造出数列 <span
class="math inline">\(a_n\)</span> 的前 <span
class="math inline">\(n\)</span> 项和的数列 <span
class="math inline">\(s_1, s_2, \dots , s_{59}, s_{60}\)</span>，则有：
<span class="math display">\[
1≤a_1=s_1&lt;s_2&lt;…&lt;s_{59}&lt;s_{60} \leq 19 \times 5=95
\]</span> 而序列 <span class="math inline">\(s_1+24, s_2+24, \dots ,
s\_{59}+24, s_{60}+24\)</span> 也是一个严格递增序列： <span
class="math display">\[
25≤s_1+24&lt;s_2+24&lt; \dots &lt;s_{59}+24&lt;s-{60}+24 ≤95+24=119
\]</span> 这 <span class="math inline">\(120\)</span> 个数都在区间 <span
class="math inline">\([1,119]\)</span>
内，根据鸽巢原理，必定存在两个数相等</p>
<p>由于 <span class="math inline">\(s_1, s_2, \dots, s_{60}\)</span> 与
<span class="math inline">\(s_1 + 24, s_2 + 24, \dots, s_{60} +
24\)</span> 均为严格单调的，因此必然存在一个 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span>，使得 <span class="math inline">\(s_i =
s_j + 24\)</span> ，因此在第 <span class="math inline">\(j+1\)</span>
个月到第 <span class="math inline">\(i\)</span>
个月的几个月时间里恰好试制了 <span class="math inline">\(24\)</span>
种新产品<strong>（解释含义）</strong></p></li>
</ul>
<p><strong>几何问题：</strong></p>
<ul>
<li><p>例：确定一个整数 <span
class="math inline">\(n_k\)</span>，使得如果在边长为 <span
class="math inline">\(1\)</span> 的等边三角形中任意选择 <span
class="math inline">\(n_k\)</span> 个点，一定存在 <span
class="math inline">\(2\)</span> 个点，其距离至多为 <span
class="math inline">\(\dfrac{1}{k}\)</span></p>
<ul>
<li>解：<span class="math inline">\(n_k = k^2 + 1\)</span></li>
<li>证：将每边均分为 <span class="math inline">\(k\)</span> 份，共有
<span class="math inline">\(k^2\)</span>
个区域，落在任意一个部分中的两点之间的距离至多为 <span
class="math inline">\(\dfrac{1}{k}\)</span>，由鸽巢原理知 <span
class="math inline">\(n_k = k^2 + 1\)</span></li>
</ul></li>
<li><p>例（一道数值计算题，比较暴力，估计不会考）：在直径为 <span
class="math inline">\(5\)</span> 的圆内任意给定 <span
class="math inline">\(10\)</span> 个点，证明存在两点距离小于 <span
class="math inline">\(2\)</span></p>
<ul>
<li>证：<img src="Images\Circle.png" alt="Circle" style="zoom:33%;" /></li>
</ul></li>
<li><p>例：将一个矩形分成 <span class="math inline">\(4\)</span> 行
<span class="math inline">\(19\)</span> 列的网格，每个单元格涂 <span
class="math inline">\(3\)</span> 种颜色当中的 <span
class="math inline">\(1\)</span>
种颜色，证明：无论怎样涂色，必有一个由单元格构成的矩形的 <span
class="math inline">\(4\)</span> 个角上的格子颜色相同</p>
<ul>
<li>思路：两次鸽巢原理</li>
<li>每一列 <span class="math inline">\(4\)</span> 行但只有 <span
class="math inline">\(3\)</span>
个颜色，由鸽巢原理，必有两个单元格颜色相同，其位置组合共 <span
class="math inline">\(\left( \begin{matrix} 4 \\ 2 \end{matrix} \right)
= 6\)</span> 种，<span class="math inline">\(3\)</span> 种颜色下共 <span
class="math inline">\(18\)</span> 种，由鸽巢原理，得证</li>
</ul></li>
<li><p>例：证明在 <span class="math inline">\(n+2\)</span>
个任选的正整数中，存在两个数，或者其差能被 <span
class="math inline">\(2n\)</span> 整除，或者其和能被 <span
class="math inline">\(2n\)</span> 整除。</p>
<p>证明：已知所有正整数除以 <span class="math inline">\(2n\)</span>
的余数只能取值 <span class="math inline">\(0, 1, 2, …,
2n-1\)</span>。</p>
<p>把以上余数构造以下 <span class="math inline">\(n+1\)</span>
个子集：<span class="math inline">\(\{1, 2n-1\}, \{2, 2n-2\}, …, \{n-1,
n+1\}, \{n, n\}, \{0, 0\}\)</span>。</p>
<p>任选 <span class="math inline">\(n+2\)</span>
个正整数，由鸽巢原理知，一定存在两个数，其除以 <span
class="math inline">\(2n\)</span> 的余数来自同一个子集 <span
class="math inline">\(A\)</span>。</p>
<ul>
<li><p>若 <span class="math inline">\(A\)</span> 是前 <span
class="math inline">\(n-2\)</span> 个子集中一个，则这两个数的和能被
<span class="math inline">\(2n\)</span> 整除；</p></li>
<li><p>若 <span class="math inline">\(A\)</span> 是最后 <span
class="math inline">\(2\)</span> 个子集中一个，则这两个数的差能被 <span
class="math inline">\(2n\)</span> 整除。</p></li>
</ul></li>
<li><p>例：一间房屋内有 <span class="math inline">\(10\)</span>
个人，他们当中没有人超过 <span class="math inline">\(60\)</span>
岁（年龄只能以整数给出)，但又至少不低于 <span
class="math inline">\(1\)</span>
岁。证明：总能找出两组人（两组人中不含相同的人 ），使得年龄和相同。</p>
<p>证：<span class="math inline">\(10\)</span> 个人构成的子集一共是
<span class="math inline">\(2^{10}=1024\)</span>
个，去除掉空集与全集，一共 <span class="math inline">\(1022\)</span>
个子集可以是找出的两组人中的一组。由于这些子集的年龄和最小为 <span
class="math inline">\(1\)</span> 岁，且不超过 <span
class="math inline">\(60 \times 9= 540\)</span>
岁。因此，由鸽巢原理知，至少有两组人的年龄和相同，<strong>去除这两组人的相同人后</strong>，所得的两组人满足题目要求</p>
<ul>
<li>如果改成 <span class="math inline">\(9\)</span> 个人，则下面记得改成
<span class="math inline">\(480\)</span></li>
</ul></li>
<li><p>其他问题和作业题整理——todo</p></li>
</ul>
<h4 id="鸽巢原理的加强形式">3.2 鸽巢原理的加强形式</h4>
<ul>
<li><p><strong>定理3.2.1 ：</strong>令 <span class="math inline">\(q_1,
q_2 , \dots, q_n\)</span> 为正整数。若将 <span
class="math inline">\(q_1+q_2+ \dots +q_n - n+1\)</span> 个物体放进
<span class="math inline">\(n\)</span> 个盒子内，那么，</p>
<p>或者第 <span class="math inline">\(1\)</span> 个盒子至少含有 <span
class="math inline">\(q_1\)</span> 个物体，</p>
<p>或者第 <span class="math inline">\(2\)</span> 个盒子至少含有 <span
class="math inline">\(q_2\)</span> 个物体，</p>
<p>…，</p>
<p>或者第 <span class="math inline">\(n\)</span> 个盒子至少含有 <span
class="math inline">\(q_n\)</span> 个物体</p>
<blockquote>
<p>当然，也就是说不会出现每个盒子的物体数少于上述数字的情况</p>
</blockquote>
<blockquote>
<p>令 <span class="math inline">\(q_1 = q_2 = \dots = q_n =
2\)</span>，即为鸽巢原理的简单形式</p>
</blockquote></li>
<li><p><strong>平均原理：</strong>如果 <span
class="math inline">\(m\)</span> 个物体放入 <span
class="math inline">\(n\)</span> 个盒子，则至少有一个盒子含有 <span
class="math inline">\(\lceil m/n\rceil\)</span> 个或更多的物体</p></li>
<li><p>例（判断满足条件的最小物品总数）：一篮水果装有苹果、梨和桔子。为了保证或者至少
<span class="math inline">\(8\)</span> 个苹果，或者至少 <span
class="math inline">\(6\)</span> 个梨或者至少 <span
class="math inline">\(9\)</span>
个桔子，则放入篮子中的水果的最少件数是多少？</p>
<p><span class="math inline">\(8+6+9-3+1=21\)</span> 件</p>
<p><strong>（尽量说明下反面）</strong>：当放入篮子的水果数为 <span
class="math inline">\(20\)</span> 时，可能出现 <span
class="math inline">\(7\)</span> 个苹果，<span
class="math inline">\(5\)</span> 个香蕉和 <span
class="math inline">\(8\)</span> 个桔子的情形，不满足题目要求</p></li>
<li><p>例：证明从任意给出的 <span class="math inline">\(5\)</span>
个正整数中必能选出 <span class="math inline">\(3\)</span>
个数，它们的和能被 <span class="math inline">\(3\)</span> 整除。</p>
<p>任意正整数除以 <span class="math inline">\(3\)</span> 的余数只能为
<span class="math inline">\(0,1,2\)</span>。</p>
<p>设 <span class="math inline">\(A\)</span> 为任意给出的 <span
class="math inline">\(5\)</span> 个正整数的集合。设 <span
class="math inline">\(t_0, t_1, t_2\)</span> 为 <span
class="math inline">\(A\)</span> 中除以 <span
class="math inline">\(3\)</span> 余数分别为 <span
class="math inline">\(0, 1, 2\)</span> 的数的个数。</p>
<ul>
<li><p>若 <span class="math inline">\(t_0, t_1, t_2\)</span> 均不为
<span class="math inline">\(0\)</span>， 则一定有三个数除以 <span
class="math inline">\(3\)</span> 的余数分别为 <span
class="math inline">\(0, 1, 2\)</span>，则这三个数的和能被 <span
class="math inline">\(3\)</span> 整除。</p></li>
<li><p>若 <span class="math inline">\(t_0, t_1, t_2\)</span>
中至少有一个为 <span class="math inline">\(0\)</span>，不妨设 <span
class="math inline">\(t_0=0\)</span>，则 <span
class="math inline">\(t_1+t_2=5\)</span>。由平均原理知，至少有 <span
class="math inline">\(\lceil 5/2\rceil = 3\)</span> 个数除以 <span
class="math inline">\(3\)</span> 的余数相同（全为 <span
class="math inline">\(1\)</span> 或全为 <span
class="math inline">\(2\)</span>），则这三个数的和能被 <span
class="math inline">\(3\)</span> 整除。</p></li>
</ul></li>
<li><p>例：证明每个由<span
class="math inline">\(n^2+1\)</span>个实数构成的序列：<span
class="math inline">\(a_1, a_2, \dots a_{n^2 +
1}\)</span>，或者含有长度为 <span class="math inline">\(n+1\)</span>
的递增子序列，或者含有长度为 <span class="math inline">\(n+1\)</span>
的递减子序列。</p>
<p>证：假设不存在长度为 <span class="math inline">\(n+1\)</span>
的递增子序列，只需构造一个长度为 <span
class="math inline">\(n+1\)</span> 的递减子序列。 设 <span
class="math inline">\(l_k\)</span> 是以 <span
class="math inline">\(a_k\)</span> 为起始的最长递增子序列长度，<span
class="math inline">\(k =1, 2, …，n^2+1\)</span>，则对 <span
class="math inline">\(\forall k\)</span> 有 <span
class="math inline">\(1 \leq l_k \leq n\)</span>。对序列 <span
class="math inline">\(l_1, l_2, …,l_{n^2 + 1}\)</span>
运用鸽巢原理加强形式，一定存在 <span class="math inline">\(\lceil
(n^2+1)/n \rceil =n+1\)</span> 个 <span
class="math inline">\(l_i\)</span> 相等。 设 <span
class="math display">\[
l_{k_1}=l_{k_2}= \dots =l_{k_{n+1}}
\]</span> 其中 <span class="math inline">\(1 \leq k_1&lt; k_2&lt;…&lt;
k_{n+1} \leq n^2+1\)</span></p>
<p>(下面证明 <span class="math inline">\(a_{k_1},a_{k_2}, \dots
,a_{k_{n+1}}\)</span> 是长度为 <span class="math inline">\(n+1\)</span>
的递减序列) 反证：假设存在 <span class="math inline">\(k_i,
k_{i+1}\)</span>，使得 <span
class="math inline">\(a_{k_i}&lt;a_{k_{i+1}}\)</span>，把 <span
class="math inline">\(a_{k_i}\)</span> 加到以 <span
class="math inline">\(a_{k_{i+1}}\)</span>
开始的最长递增子序列，则构成了以 <span
class="math inline">\(a_{k_i}\)</span> 开始的递增子序 列，得 <span
class="math inline">\(l_{k_i}&gt;l_{k_{i+1}}\)</span>，与 <span
class="math inline">\(l_{k_i} = l_{k_{i+1}}\)</span> 矛盾！</p>
<blockquote>
<p>证明不是递增就是递减</p>
</blockquote>
<p>todo 方阵排队问题</p></li>
</ul>
<h4 id="ramsey-定理">3.3 <span class="math inline">\(Ramsey\)</span>
定理</h4>
<ul>
<li><p><strong><span class="math inline">\(Ramsey\)</span>
定理：</strong></p>
<ul>
<li>通俗实例： 在 <span class="math inline">\(6\)</span> 个人中，或者有
$ 3$ 个人，他们中每两个人都互相认识；或者有 <span
class="math inline">\(3\)</span>
个人，他们中的每两个人都彼此不认识。</li>
<li>给图 <span class="math inline">\(K_6\)</span>
的边任意着红色、蓝色后，一定存在一个红色 <span
class="math inline">\(K_3\)</span> 或 蓝色<span
class="math inline">\(K_3\)</span>，记为<span class="math inline">\(K_6
\rightarrow K_3,K_3\)</span></li>
<li><span class="math inline">\(n\)</span> 阶完全图：用 <span
class="math inline">\(K_n\)</span> 表示平面上没有 <span
class="math inline">\(3\)</span> 点共线的 <span
class="math inline">\(n\)</span> 个顶点构成的一个完全图。</li>
</ul></li>
<li><p>证明：给图 <span class="math inline">\(K_6\)</span>
的边任意着红色、蓝色，一定存在一个红色 <span
class="math inline">\(K_3\)</span> 或蓝色 <span
class="math inline">\(K_3\)</span>，记为 <span class="math inline">\(K_6
\rightarrow K_3, K_3\)</span></p>
<p><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611105033290.png" alt="image-20230611105033290" style="zoom:33%;" /></p></li>
<li><p><strong>定理 3.3.1 (<span class="math inline">\(Ramsey\)</span>
定理) ：</strong>如果两个整数 <span class="math inline">\(m ≥ 2, n ≥
2\)</span>，则存在正整数 <span class="math inline">\(p\)</span>，使得
<span class="math inline">\(K_p \rightarrow K_m,K_n\)</span></p></li>
<li><p><strong><span class="math inline">\(Ramsey\)</span>
数：</strong><span class="math inline">\(Ramsey\)</span> 数 <span
class="math inline">\(r(m, n)\)</span> 是使 <span
class="math inline">\(K_p \rightarrow K_m,K_n\)</span> 成立的最小整数
<span class="math inline">\(p\)</span></p>
<ul>
<li><p>一定存在</p></li>
<li><p>对称性：<span class="math inline">\(r(m,n) =
r(n,m)\)</span></p></li>
<li><p>平凡的 <span class="math inline">\(Ramsey\)</span> 数：<span
class="math inline">\(r(2, n)=n, r(m,2)=m\)</span></p>
<blockquote>
<p>或者存在一条边是红色，或者所有边是蓝色</p>
</blockquote></li>
<li><p>推论：<span class="math inline">\(r(m, n) ≤ r(m-1, n) + r(m,
n-1)\)</span>。</p></li>
</ul></li>
<li><p><strong><span class="math inline">\(Ramsey\)</span>
定理推广：</strong>如果<span class="math inline">\(n_1, n_2,\dots,
n_l\)</span> 都是大于或等于 <span class="math inline">\(2\)</span>
的整数，则一定存在正整数 <span class="math inline">\(p\)</span>，使得
<span class="math display">\[
K_p \rightarrow K_{n_1},K_{n_2},\dots,K_{n_l}
\]</span> 满足以上条件的最小整数 <span class="math inline">\(p\)</span>
称为 <span class="math inline">\(Ramsey\)</span> 数。例如：<span
class="math inline">\(K_{17} \rightarrow
K_3,K_3,\dots,K_3\)</span></p></li>
<li><p>例：证明 <span class="math inline">\(r(3, 3, 3) \le 17\)</span>
todo</p></li>
</ul>
<h3 id="第4章-生成排列和组合"><strong>第4章 生成排列和组合</strong></h3>
<blockquote>
<p>排列生成算法：</p>
<ul>
<li>递归生成算法</li>
<li>邻位对换算法</li>
<li>从逆序生成排列算法
<ul>
<li>逆序相关知识</li>
<li>从最大数或最小数</li>
</ul></li>
</ul>
<p>组合生成算法：</p>
<ul>
<li>字典序</li>
<li>反射 <span class="math inline">\(Gray\)</span> 码
<ul>
<li>递归法</li>
<li>逐次法</li>
</ul></li>
<li>基于字典序的 <span class="math inline">\(r\)</span> -
组合生成算法</li>
</ul>
</blockquote>
<h4 id="生成排列">4.1 生成排列</h4>
<ul>
<li>递归生成算法</li>
<li>邻位对换算法：
<ul>
<li>可活动：箭头指向与其相邻但比它小的整数</li>
</ul></li>
<li>两种算法生成的排列顺序一致</li>
</ul>
<h4 id="排序中的逆序">4.2 排序中的逆序</h4>
<ul>
<li><p><strong>逆序：</strong>令 <span
class="math inline">\(i_1,i_2,\dots,i_n\)</span> 是集合 <span
class="math inline">\(\{1, 2,\dots, n\}\)</span> 的一个排列， 如果 <span
class="math inline">\(0\leq k &lt; l \leq n\)</span>， 且 <span
class="math inline">\(i_k &gt; i_l\)</span> , 称数对 <span
class="math inline">\((i_k, i_l)\)</span> 是排列的一个逆序。</p>
<ul>
<li><p>如，排列 <span class="math inline">\(31524\)</span> 的逆序为
<span class="math inline">\((3,1), (3,2), (5,2), (5,4)\)</span></p></li>
<li><p>唯一没有逆序的排列为 <span class="math inline">\(1 2 3 \dots
n\)</span></p></li>
</ul></li>
<li><p><strong>逆序数：</strong>对于 <span class="math inline">\(\{1,
2,\dots, n\}\)</span> 上的一个排列，逆序数 <span
class="math inline">\(a_j\)</span> 是<strong>第二元</strong>是 <span
class="math inline">\(j\)</span> 的逆序的数量，也即排列中先于整数 <span
class="math inline">\(j\)</span> 并大于 <span
class="math inline">\(j\)</span> 的整数的个数，度量 <span
class="math inline">\(j\)</span> 的反序程度。</p></li>
<li><p><strong>逆序列：</strong>令 <span
class="math inline">\(a_j\)</span> 表示排列 <span
class="math inline">\(i_1i_2,\dots,i_n\)</span> 中数 <span
class="math inline">\(j\)</span> 的逆序数， 称<span
class="math inline">\(a_1,a_2,\dots,a_n\)</span>为排列 <span
class="math inline">\(i_1i_2,\dots,i_n\)</span> 的逆序列</p>
<p>例如，排列 <span class="math inline">\(361245\)</span>。</p>
<p>逆序：<span class="math inline">\((3, 1) ,(3, 2), (6, 1),(6, 2), (6,
4) ,(6, 5)\)</span>。</p>
<p>逆序数：<span class="math inline">\(a_1=2, a_2=2, a_3=0, a_4=1,
a_5=1, a_6=0\)</span></p>
<p>逆序列：<span class="math inline">\(2 2 0 1 1 0\)</span></p></li>
<li><p>从逆序生成排列算法：</p>
<ol type="1">
<li><p>从最大数开始。已知 <span class="math inline">\(\{1, 2, …,
8\}\)</span> 的一个排列的逆序列为 <span class="math inline">\(5 3 4 0 2
1 1 0\)</span>，确定此排列。【每个数放在第“逆序数”个位置上】</p>
<ul>
<li>特点：相对位置固定，但是每个整数的位置要到最后才能确定</li>
</ul>
<table>
<thead>
<tr class="header">
<th>当前放置数</th>
<th>当前排列</th>
<th>逆序数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>8：</td>
<td>8</td>
<td>0</td>
</tr>
<tr class="even">
<td>7：</td>
<td>8 7</td>
<td>1</td>
</tr>
<tr class="odd">
<td>6：</td>
<td>8 6 7</td>
<td>1</td>
</tr>
<tr class="even">
<td>5：</td>
<td>8 6 5 7</td>
<td>2</td>
</tr>
<tr class="odd">
<td>4：</td>
<td>4 8 6 5 7</td>
<td>0</td>
</tr>
<tr class="even">
<td>3：</td>
<td>4 8 6 5 3 7</td>
<td>4</td>
</tr>
<tr class="odd">
<td>2：</td>
<td>4 8 6 2 5 3 7</td>
<td>3</td>
</tr>
<tr class="even">
<td>1：</td>
<td>4 8 6 2 5 1 3 7</td>
<td>5</td>
</tr>
</tbody>
</table></li>
<li><p>从最小数开始。仍上例。【每个数放在第“逆序数+1”个<strong>空</strong>位置上】</p>
<table>
<thead>
<tr class="header">
<th>当前放置数</th>
<th>当前排列</th>
<th>逆序数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1：</td>
<td>X X X X X 1 X X</td>
<td>5</td>
</tr>
<tr class="even">
<td>2：</td>
<td>X X X 2 X 1 X X</td>
<td>3</td>
</tr>
<tr class="odd">
<td>3：</td>
<td>X X X 2 X 1 3 X</td>
<td>4</td>
</tr>
<tr class="even">
<td>4：</td>
<td>4 X X 2 X 1 3 X</td>
<td>0</td>
</tr>
<tr class="odd">
<td>5：</td>
<td>4 X X 2 5 1 3 X</td>
<td>2</td>
</tr>
<tr class="even">
<td>6：</td>
<td>4 X 6 2 5 1 3 X</td>
<td>1</td>
</tr>
<tr class="odd">
<td>7：</td>
<td>4 X 6 2 5 1 3 7</td>
<td>1</td>
</tr>
<tr class="even">
<td>8：</td>
<td>4 8 6 2 5 1 3 7</td>
<td>0</td>
</tr>
</tbody>
</table></li>
</ol></li>
<li><p>逆序个数为奇数的排列称为奇排列；
逆序个数为偶数的排列称为偶排列。</p></li>
<li><p><span class="math inline">\(15
Puzzles\)</span>：用逆序数证明无解：左右移动逆序数的和不变，上下移动逆序数的和
<span class="math inline">\(+3\)</span></p></li>
</ul>
<h4 id="生成组合">4.3 生成组合</h4>
<ul>
<li><p><span class="math inline">\(n\)</span> 元集合 <span
class="math inline">\(S=\{x_{n-1},x_{n-2}, \dots, x_0\}\)</span>
的组合与长度为 <span class="math inline">\(n\)</span>
的二进制数一一对应（注意到两者个数均为 <span
class="math inline">\(2^n\)</span>）</p>
<ul>
<li>对应方法：这个整数的二进制表示 <span
class="math inline">\(1\)</span> 所在的位置的元素包含在组合中</li>
<li>如：<span class="math inline">\(29 \in [1, 2^7]\)</span>
的二进制表示 <span class="math inline">\(0011101\)</span>，则 <span
class="math inline">\(29\)</span> 对应的组合为 <span
class="math inline">\(\{x_4, x_3, x_2, x_0\}\)</span></li>
</ul></li>
<li><p>字典序生成算法</p>
<ul>
<li><p>初始：<span class="math inline">\(a_{n-1} \dots a_1a_0 = 0 \dots
00\)</span></p></li>
<li><p>当 <span class="math inline">\(a_{n-1} \dots a_1a_0 \neq 1 \dots
11\)</span> 时，求出使得 <span class="math inline">\(a_j = 0\)</span>
的最小整数 <span class="math inline">\(j\)</span>，用 <span
class="math inline">\(1\)</span> 替换 <span
class="math inline">\(a_j\)</span> 并用 <span
class="math inline">\(0\)</span> 替换每个 <span
class="math inline">\(a_{j-1}, \dots a_1, a_0\)</span></p>
<blockquote>
<p>把最小的 <span class="math inline">\(1\)</span> 找出来，后面的全换成
<span class="math inline">\(0\)</span></p>
</blockquote></li>
<li><p>例1：求组合 <span class="math inline">\(\{x_6, x_4, x_2, x_1,
x_0\}\)</span> 的下一个组合</p>
<ul>
<li><span class="math inline">\(1010111 + 1 =
1011000\)</span>，对应组合为 <span class="math inline">\(\{x_6, x_4,
x_3\}\)</span></li>
</ul></li>
<li><p>例2：<span class="math inline">\(S = \{x_6, x_5, \dots, x_1,
x_0\}\)</span> 的哪个子集是子集列表中的第 <span
class="math inline">\(108\)</span> 个子集？</p>
<ul>
<li>注：位置从 <span class="math inline">\(0\)</span> 开始，第 <span
class="math inline">\(108\)</span> 个子集对应 <span
class="math inline">\(108\)</span>，<span
class="math inline">\(108\)</span> 二进制数为 <span
class="math inline">\(1101100\)</span>，则对应子集为 <span
class="math inline">\(\{x_6, x_5, x_3, x_2\}\)</span></li>
</ul></li>
</ul></li>
<li><p>反射 <span class="math inline">\(Gray\)</span>
码序生成算法：特点为相邻的组合间仅相差一个元素。生成方法：前面补0，1；之后折叠</p>
<blockquote>
<p>对应 <span class="math inline">\(n\)</span> 维空间点坐标</p>
</blockquote>
<ul>
<li>递归生成：见图
<ul>
<li><img src="Images\RecursiveGray.png" alt="RecursiveGray" style="zoom: 33%;" /></li>
</ul></li>
<li>逐次生成：整体思路——每次改变 <span
class="math inline">\(\sigma\)</span> 的奇偶性
<ul>
<li>初始：<span class="math inline">\(a_{n-1} \dots a_1a_0 = 0 \dots
00\)</span></li>
<li>当 <span class="math inline">\(a_{n-1} \dots a_1a_0 \neq 1 \dots
00\)</span> 时，计算 <span class="math inline">\(\sigma(a_{n-1} \dots
a_1 a_0) = a_{n-1} + \dots + a_1 + a_0\)</span>，如果结果为偶数，则改变
<span class="math inline">\(a_0\)</span>；否则确定使得 <span
class="math inline">\(a_j = 1\)</span> 且对于所有 <span
class="math inline">\(i &lt; j\)</span>$， $<span
class="math inline">\(a_i = 0\)</span> 的最小整数 <span
class="math inline">\(j\)</span>，改变 <span
class="math inline">\(a_{j+1}\)</span></li>
</ul></li>
</ul></li>
<li><p>可由归纳法证明二者生成相同顺序的 <span
class="math inline">\(n\)</span> 阶反射 <span
class="math inline">\(Gray\)</span> 码</p></li>
<li><p>确定 <span class="math inline">\(n\)</span> 元组在 <span
class="math inline">\(Gray\)</span>
码序表中的准确位置：<img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230608105305919.png" alt="image-20230608105305919" style="zoom: 33%;" /></p></li>
</ul>
<h4 id="生成-r---组合">4.4 生成 <span class="math inline">\(r\)</span> -
组合</h4>
<ul>
<li><p>先于：若 <span class="math inline">\(A \cup B \setminus A \cap
B\)</span> 中的最小整数属于 <span class="math inline">\(A\)</span>，则称
<span class="math inline">\(A\)</span> 先于 <span
class="math inline">\(B\)</span></p>
<blockquote>
<p>属于 <span class="math inline">\(A \cup B\)</span>， 但不同时属于
<span class="math inline">\(A \cap B\)</span></p>
</blockquote></li>
<li><p>直接后继求解算法：找出满足 <span
class="math inline">\(a_i&lt;n\)</span>，且 <span
class="math inline">\(a_i+1\)</span> 不在 <span
class="math inline">\(\{a_1,…, a_r\}\)</span> 中的最大的 <span
class="math inline">\(i\)</span>，记为 <span
class="math inline">\(k\)</span>，在字典序中 <span
class="math inline">\(a_1a_2…a_r\)</span> 的直接后继是<span
class="math inline">\(a_1a_2…a_{k-1} (a_k+1) (a_k+2)…(a_k+r – k
+1)\)</span></p></li>
<li><p><span class="math inline">\(r\)</span> 子集的生成算法：从 <span
class="math inline">\(12 \dots r\)</span>
开始，逐个列出直接后继，直到得到 <span
class="math inline">\((n-r+1)(n-r+2) \dots n\)</span></p></li>
</ul>
<h3 id="第5章-二项式系数"><strong>第5章 二项式系数</strong></h3>
<blockquote>
<p>讨论二项式系数相关等式和性质</p>
</blockquote>
<h4 id="pascal-三角形">5.1 <span class="math inline">\(Pascal\)</span>
三角形</h4>
<ul>
<li><p><strong>定理5.1.1(<span class="math inline">\(Pascal\)</span>
公式)：</strong>对于满足 <span class="math inline">\(1 \leq k \leq
n\)</span> 的所有整数 <span class="math inline">\(k\)</span> 和 <span
class="math inline">\(n\)</span>，有： <span class="math display">\[
\left(\begin{matrix}
n \\ k
\end{matrix}\right)=
\left(\begin{matrix}
n-1 \\ k
\end{matrix}\right)+
\left(\begin{matrix}
n-1 \\ k-1
\end{matrix}\right)
\]</span></p>
<ul>
<li>组合证明同前，此处从略</li>
<li><span class="math inline">\(Pascal\)</span>
三角形：<img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230608111421566.png" alt="image-20230608111421566" style="zoom:33%;" /></li>
<li>行列套用定义即可，没有很强的几何直观性</li>
<li>另一种解释：路径移动</li>
<li>可以证明若干项求和的等式</li>
</ul></li>
</ul>
<h4 id="二项式定理">5.2 二项式定理</h4>
<ul>
<li><p><strong>定理5.2.1：</strong>令 <span
class="math inline">\(n\)</span> 是一个正整数, 那么对于所有的 <span
class="math inline">\(x, y\)</span> 有： <span class="math display">\[
(x+y)^n=\sum_{k=0}^n \left( \begin{matrix} n \\ k \end{matrix} \right)
x^{n-k} y^k
\]</span></p>
<ul>
<li>可以对换 <span class="math inline">\(x, y\)</span>，对换 <span
class="math inline">\(n\)</span> 和 <span
class="math inline">\(n-k\)</span> 得到等价形式</li>
</ul></li>
<li><p><strong>二项式系数的其它等式：</strong> <span
class="math display">\[
k \left( \begin{matrix} n \\ k \end{matrix} \right) = n \left(
\begin{matrix} n-1 \\ k-1 \end{matrix} \right)
\]</span></p>
<ul>
<li><p><span class="math inline">\(n\)</span> 个人中选 <span
class="math inline">\(k\)</span> 人组成足球队，其中 <span
class="math inline">\(1\)</span> 人为队长，有多少种不同选法？</p>
<p>1、先选足球队，然后从足球队中选队长；</p>
<p>2、先选队长，再在剩下的 <span class="math inline">\(n-1\)</span>
人中选 <span class="math inline">\(k-1\)</span> 个足球队员。</p></li>
</ul>
<p><span class="math display">\[
\sum_{k=0}^n \left( \begin{matrix} n \\ k \end{matrix} \right)^2 =
\left( \begin{matrix} 2n \\ n \end{matrix} \right) (n \geq 0)
\]</span></p>
<ul>
<li><p>设 <span class="math inline">\(A={1, 2, …, n}, B={n+1, n+2, …,
2n}\)</span>，<span class="math inline">\(A \cup B={1, 2, …,
2n}\)</span>。令 <span class="math inline">\(S＝A\cup B\)</span>，<span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 是两个不相交的 <span
class="math inline">\(n\)</span> 个元素集合.</p>
<ul>
<li><p><span class="math inline">\(S\)</span> 的 <span
class="math inline">\(n\)</span> - 组合数是<span
class="math inline">\(\left(\begin{matrix} 2n \\ n
\end{matrix}\right)\)</span></p></li>
<li><p>设 <span class="math inline">\(S\)</span> 的一个 <span
class="math inline">\(n\)</span> - 组合含有 <span
class="math inline">\(A\)</span> 的元素为 <span
class="math inline">\(k\)</span> 个，含有 <span
class="math inline">\(B\)</span> 的元素为 <span
class="math inline">\(n-k\)</span> 个，<span
class="math inline">\(k=0,1,…, n\)</span>。令 <span
class="math inline">\(C_k\)</span> 是含有 <span
class="math inline">\(k\)</span> 个 <span
class="math inline">\(A\)</span> 的元素的 <span
class="math inline">\(n\)</span> - 组合，则 <span
class="math inline">\(S\)</span> 的所有 <span
class="math inline">\(n\)</span> - 组合可划分为：<span
class="math inline">\(C_0, C_1,…, C_n\)</span>。有：</p></li>
</ul>
<p><span class="math display">\[
\left(\begin{matrix} 2n \\ n \end{matrix}\right) =
\left| C_0 \right| + \left| C_1 \right| + \dots + \left| C_n \right|
\]</span></p>
<p><span class="math display">\[
\left| C_k \right| =
\left(\begin{matrix} n \\ k \end{matrix}\right)
\left(\begin{matrix} n \\ n-k \end{matrix}\right) =
\left(\begin{matrix} n \\ k \end{matrix}\right) ^2
\]</span></p>
<p>得证。 <span class="math display">\[
\left(\begin{matrix} n \\ 0 \end{matrix}\right)-
\left(\begin{matrix} n \\ 1 \end{matrix}\right)+
\left(\begin{matrix} n \\ 2 \end{matrix}\right)+ \dots +
(-1)^n\left(\begin{matrix} n \\ n \end{matrix}\right)+ \dots = 0
\]</span></p></li>
<li><p>证明：</p>
<ul>
<li>方法一：令二项式公式中 <span class="math inline">\(x = 1, y =
-1\)</span></li>
<li>方法二：奇偶子集之和之差</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[
\left(\begin{matrix} n \\ 0 \end{matrix}\right)+
\left(\begin{matrix} n \\ 2 \end{matrix}\right)+ \dots =
\left(\begin{matrix} n \\ 1 \end{matrix}\right)+
\left(\begin{matrix} n \\ 3 \end{matrix}\right)+ \dots = 2^{n-1}
\]</span></p>
<ul>
<li><p>证明</p>
<ul>
<li>方法一：偶数个元素的子集的个数 = 奇数个元素的子集的个数 = <span
class="math inline">\(\dfrac{1}{2}\)</span>总子集数。</li>
<li>方法二：<span class="math inline">\(x_1,…, x_{n-1}\)</span>
每个有两种选择，但前面的奇偶性决定了 <span
class="math inline">\(x_n\)</span> 只有一种选择（使得总元素个数为 奇数
或 偶数）</li>
</ul></li>
<li><p>例：证明以下等式： <span class="math display">\[
1 \left(\begin{matrix} n \\ 1 \end{matrix}\right)+
2 \left(\begin{matrix} n \\ 2 \end{matrix}\right)+ \dots +
n \left(\begin{matrix} n \\ n \end{matrix}\right) = n 2^{n-1}
\]</span></p>
<ul>
<li><p>利用选队长公式 <span class="math inline">\(k \left(
\begin{matrix} n \\ k \end{matrix} \right) = n \left( \begin{matrix} n-1
\\ k-1 \end{matrix} \right)\)</span> <span class="math display">\[
1 \left(\begin{matrix} n \\ 1 \end{matrix}\right) +
2 \left(\begin{matrix} n \\ 2 \end{matrix}\right) + \dots +
n \left(\begin{matrix} n \\ n \end{matrix}\right) =
n \left(\begin{matrix} n-1 \\ 0 \end{matrix}\right) +
n \left(\begin{matrix} n-1 \\ 1 \end{matrix}\right) + \dots +
n \left(\begin{matrix} n-1 \\ n-1 \end{matrix}\right) = n2^{n-1}
\]</span></p></li>
<li><p>求导法：对 <span class="math inline">\((1+x)^n = 1 +
\left(\begin{matrix} n \\ 1 \end{matrix}\right)x + \left(\begin{matrix}
n \\ 2 \end{matrix}\right)x^2 + \dots + \left(\begin{matrix} n \\ k
\end{matrix}\right)x^k + \dots + \left(\begin{matrix} n \\ n
\end{matrix}\right)x^n\)</span>，左右同求导数，取 <span
class="math inline">\(x = 1\)</span></p></li>
</ul></li>
<li><p>例：<img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611115437992.png" alt="image-20230611115437992" style="zoom:33%;" /></p></li>
<li><p>组合定义扩展</p>
<ul>
<li><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230608114453735.png" alt="image-20230608114453735" style="zoom:33%;" /></li>
</ul></li>
</ul>
<h4 id="二项式系数的单峰性">5.3 二项式系数的单峰性</h4>
<ul>
<li><p><strong>定理5.3.1：</strong>对 <span
class="math inline">\(n\)</span> 是奇数偶数的单峰性讨论</p>
<ul>
<li>证明：考虑相邻两项的商</li>
</ul></li>
<li><p><strong>链与反链：</strong>令 <span
class="math inline">\(S\)</span> 是 <span
class="math inline">\(n\)</span> 个元素的集合，<span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的<strong>子集</strong>的集合</p>
<ul>
<li><p><strong>链：</strong>若 <span class="math inline">\(C\)</span>
中任意两个不同的子集都存在包含关系，则称 <span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的一个链。</p>
<ul>
<li>对 <span class="math inline">\(\forall S_1, S_2 \in C\)</span>，且
<span class="math inline">\(S_1 \ne S_2\)</span>，则 <span
class="math inline">\(S_1 \subset S_2\)</span> 或 <span
class="math inline">\(S_2 \subset S_1\)</span></li>
</ul></li>
<li><p><strong>反链：</strong>若 <span class="math inline">\(C\)</span>
中任意一个子集都不包含在其他子集内，
即任意两个不同的子集都不存在包含关系，则称 <span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的一个反链。</p>
<ul>
<li>一个构造反链的方法：取 <span class="math inline">\(A_k\)</span> 为
<span class="math inline">\(S\)</span> 所有的 <span
class="math inline">\(k\)</span> 子集的集合</li>
</ul></li>
<li><p><strong>链与反链的关系：</strong></p>
<ul>
<li><p><span class="math inline">\(S\)</span> 上的一条链最多只能包含
<span class="math inline">\(S\)</span>
的任意一条反链中的一个子集</p></li>
<li><p><span class="math inline">\(S\)</span> 上的一条反链最多只能包含
<span class="math inline">\(S\)</span> 的任意一条链中的一个子集</p>
<blockquote>
<p>可以有 <span class="math inline">\(0\)</span> 或 <span
class="math inline">\(1\)</span> 个公共元素</p>
</blockquote></li>
<li><p>反证法：设 <span class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的一条链，<span
class="math inline">\(A\)</span> 是 <span
class="math inline">\(S\)</span> 的一条反链。若 <span
class="math inline">\(C\)</span> 包含 <span
class="math inline">\(A\)</span> 中两个子集 <span
class="math inline">\(S_1, S_2\)</span>，则 <span
class="math inline">\(S_1, S_2\)</span> 不存在包含关系，与 <span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(S\)</span> 的一条链矛盾</p></li>
</ul></li>
<li><p><strong>链与反链的推广：</strong></p>
<ul>
<li>极大元、极小元</li>
</ul></li>
<li><p>一些证明题：todo</p></li>
</ul></li>
<li><p><strong>定理 5.3.3：</strong>设 <span
class="math inline">\(S\)</span> 为 <span
class="math inline">\(n\)</span> 个元素的集合，则 <span
class="math inline">\(S\)</span> 的一个反链最多包含<span
class="math inline">\(\left(\begin{matrix} n \\ \lfloor n/2 \rfloor
\end{matrix}\right)\)</span>个集合。</p></li>
<li><p><strong>最大链：</strong></p>
<ul>
<li><span class="math inline">\(A_0 = \emptyset \subset A_1 \subset A_2
\dots \subset A_n\)</span></li>
<li><span class="math inline">\(|A_i| = i(i = 1, \dots ,
n)\)</span></li>
<li><span class="math inline">\(S\)</span> 的最大链与 <span
class="math inline">\(S\)</span> 的排列一一对应，相应地，最大链的数目为
<span class="math inline">\(n!\)</span></li>
<li>构造方法：
<ul>
<li><span class="math inline">\(A_0 = \empty\)</span></li>
<li>从 <span class="math inline">\(S\)</span> 中选择元素 <span
class="math inline">\(i_1\)</span>，<span class="math inline">\(A_1 =
\{i_1\}\)</span></li>
<li>从 <span class="math inline">\(S\)</span> 中选择元素 <span
class="math inline">\(i_2 \ne i_1\)</span>，<span
class="math inline">\(A_2 = \{i_1, i_2\}\)</span></li>
<li><span class="math inline">\(\dots\)</span></li>
<li>从 <span class="math inline">\(S\)</span> 中选择元素 <span
class="math inline">\(i_k \ne i_1, i_2, \dots, i_{k-1}\)</span>，<span
class="math inline">\(A_k = \{i_1, i_2 \dots, i_k\}\)</span></li>
<li><span class="math inline">\(\dots\)</span></li>
<li>从 <span class="math inline">\(S\)</span> 中选择元素 <span
class="math inline">\(i_n \ne i_1, i_2, \dots, i_{n-1}\)</span>，<span
class="math inline">\(A_n = \{i_1, i_2 \dots, i_n\}\)</span></li>
</ul></li>
</ul></li>
<li><p><strong>对称链划分：</strong></p>
<ul>
<li><span class="math inline">\(S\)</span> 的幂集 <span
class="math inline">\(\mathcal{P}(S)\)</span> 的一个链划分
<ul>
<li>链中每一个子集比它前面的子集的元素个数多 <span
class="math inline">\(1\)</span></li>
<li>链中第一个子集与最后一个子集的大小和等于 <span
class="math inline">\(n\)</span></li>
<li>如果只含一个子集，那么既是第一个又是最后一个，大小为 <span
class="math inline">\(\dfrac{n}{2}\)</span></li>
<li>每一个链中必须含有一个 <span class="math inline">\(\lfloor n/2
\rfloor\)</span> 的子集和一个 <span class="math inline">\(\lceil n/2
\rceil\)</span> 的子集</li>
<li>链的个数为 <span class="math inline">\(\left(\begin{matrix} n \\
\lfloor n/2 \rfloor \end{matrix}\right)\)</span></li>
</ul></li>
<li>构造方法：对于 <span class="math inline">\(n=k\)</span>
时的每一个含多个子集的链 <span class="math inline">\(E\)</span>，可构造
<span class="math inline">\(n=k+1\)</span> 时的两个链
<ul>
<li>在 <span class="math inline">\(E\)</span> 的最后一个子集中增加 <span
class="math inline">\(k+1\)</span>，并加入这个新子集</li>
<li>在 <span class="math inline">\(E\)</span>
的除最后一个子集外的所有子集中加入 <span
class="math inline">\(k+1\)</span>，并删除最后一个子集</li>
</ul></li>
</ul></li>
</ul>
<h4 id="多项式定理">5.4 多项式定理</h4>
<ul>
<li><p>把二项式定理 <span class="math inline">\((x+y)^n\)</span>
扩展到<span class="math inline">\((x_1+x_2+ \dots +
x_t)^n\)</span>。其中，多项式系数： <span class="math display">\[
\left(\begin{matrix} n \\ n_1 n_2 \dots n_t \end{matrix}\right) =
\dfrac{n!}{n_1! n_2! \dots n_t!}
\]</span></p></li>
<li><p><strong>定理5.4.1：</strong>设 <span
class="math inline">\(n\)</span> 是正整数，对于所有的 <span
class="math inline">\(x_1, x_2, \dots, x_t\)</span>，有 <span
class="math display">\[
(x_1+x_2+...+x_t)^n=\sum\binom{n}{n_1n_1...n_t}{x_1}^{n_1}{x_2}^{n_2}...{x_t}^{n_t}
\]</span></p></li>
</ul>
<h4 id="牛顿二项式定理">5.5 牛顿二项式定理</h4>
<blockquote>
<p>把二项式定理的指数扩展到实数</p>
</blockquote>
<h3 id="第6章-容斥原理及应用"><strong>第6章 容斥原理及应用</strong></h3>
<blockquote>
<p>解决具有重叠集合的并集的计数原理</p>
</blockquote>
<h4 id="容斥原理">6.1 容斥原理</h4>
<ul>
<li><p><strong>定理6.1.1（容斥原理计数）：</strong>集合 <span
class="math inline">\(S\)</span> 不具有性质 <span
class="math inline">\(P_1,P_2, \dots ,P_m\)</span> 的物体的个数： <span
class="math display">\[
| \overline{A_1} \cap  \overline{A_2} \cap \dots \cap  \overline{A_n}|=
|S| - \sum|A_i| + \sum|A_i \cap A_j| -
\sum |A_i \cap A_j \cap A_k| + \dots +
(-1)^m \sum |A_1 \cap A_2 \cap \dots \cap A_m|
\]</span></p>
<ul>
<li><p>例：求 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(1000\)</span> 不能被 <span
class="math inline">\(5, 6, 8\)</span> 整除的数的个数。</p>
<p>设 <span class="math inline">\(A_1, A_2 ,A_3\)</span> 分别是 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(1000\)</span> 中能被 <span
class="math inline">\(5, 6, 8\)</span> 整除的数集合，那么 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(1000\)</span> 不能被 <span
class="math inline">\(5, 6, 8\)</span> 整除的数的个数为 <span
class="math inline">\(|\overline{A_1} \cap \overline{A_2} \cap
\overline{A_3}|\)</span> <span class="math display">\[
\begin{aligned}
|A_1| &amp;= \lfloor 1000/5 \rfloor = 200 \\
|A_2| &amp;= \lfloor 1000/6 \rfloor = 166 \\
|A_3| &amp;= \lfloor 1000/8 \rfloor = 125 \\
|A_1 \cap A_2| &amp;= \lfloor 1000/30 \rfloor = 33 \\
|A_1 \cap A_3| &amp;= \lfloor 1000/40 \rfloor = 25 \\
|A_2 \cap A_3| &amp;= \lfloor 1000/24 \rfloor = 41 \\
|A_1 \cap A_2 \cap A_3| &amp;= \lfloor 1000/120 \rfloor = 8 \\
\end{aligned}
\]</span> 由容斥原理，原式 <span
class="math inline">\(=1000-(200+166+125)+(33+25+41)-8=600\)</span></p></li>
<li><p>例：从 <span class="math inline">\(0\)</span> 到 <span
class="math inline">\(99999\)</span> 中有多少同时含有数字 <span
class="math inline">\(2, 5, 8\)</span> 的整数。</p>
<p>设 <span class="math inline">\(A_1, A2, A_3\)</span> 分别是不包含数字
<span class="math inline">\(2, 5, 8\)</span> 的集合。 <span
class="math display">\[
\alpha_1 = |A_1| = |A_2| = |A_3| = 9^5 \\
\alpha_2 = |A_1 \cap A_2| = 8^5 \\
\alpha_3 = |A_1 \cap A_2 \cap A_3| = 7^5
\]</span> 满足题意的整数个数为 <span class="math inline">\(10^5 - 3
\times 9^5 + 3 \times 8^5 -7^5\)</span></p></li>
</ul></li>
<li><p><strong>推论6.1.2（容斥原理计数）：</strong>集合 <span
class="math inline">\(S\)</span> 至少具有性质 <span
class="math inline">\(P_1,P_2, \dots ,P_m\)</span> 之一的物体的个数：
<span class="math display">\[
| A_1 \cup  {A_2} \cup \dots \cup  A_n|=
\sum|A_i| - \sum|A_i \cap A_j| +
\sum |A_i \cap A_j \cap A_k| + \dots +
(-1)^{m+1} \sum |A_1 \cap A_2 \cap \dots \cap A_m|
\]</span></p>
<blockquote>
<p>用总数 - 6.1.1</p>
</blockquote></li>
</ul>
<h4 id="带重复的组合">6.2 带重复的组合</h4>
<ul>
<li><p>例：确定多重集 <span class="math inline">\(T=\{3 \cdot a, 4 \cdot
b, 5 \cdot c\}\)</span> 的 <span class="math inline">\(10\)</span>
子集的个数。</p>
<ul>
<li><p>令多重集 <span class="math inline">\(T^*=\{\infty \cdot a, \infty
\cdot b, \infty \cdot c\}\)</span> 的所有 <span
class="math inline">\(10\)</span> 子集的集合为 <span
class="math inline">\(S\)</span>。</p>
<blockquote>
<p>用于下文无穷集取方案表述方便</p>
</blockquote>
<p><span class="math inline">\(A_1\)</span> 是 <span
class="math inline">\(S\)</span> 中包含多于 <span
class="math inline">\(3\)</span> 个 <span
class="math inline">\(a\)</span> 的 <span
class="math inline">\(10\)</span> 子集的集合；<span
class="math inline">\(A_2\)</span> 是 <span
class="math inline">\(S\)</span> 中包含多于 <span
class="math inline">\(4\)</span> 个 <span
class="math inline">\(b\)</span> 的 <span
class="math inline">\(10\)</span> 子集的集合；<span
class="math inline">\(A_3\)</span> 是 <span
class="math inline">\(S\)</span> 中包含多于 <span
class="math inline">\(5\)</span> 个 <span
class="math inline">\(c\)</span> 的 <span
class="math inline">\(10\)</span>子集的集合。</p>
<p>那么，<span class="math inline">\(T\)</span> 的 <span
class="math inline">\(10\)</span> - 组合数等于 <span
class="math inline">\(|\overline{A_1} \cap \overline{A_2} \cap
\overline{A_3}|\)</span>。</p>
<ul>
<li><span class="math inline">\(A_1\)</span> 中的每个子集中 <span
class="math inline">\(a\)</span> 至少出现 <span
class="math inline">\(4\)</span> 次，剩下 <span
class="math inline">\(6\)</span> 个元素可以是 <span
class="math inline">\(T*\)</span> 的任何 <span
class="math inline">\(6\)</span> - 组合，因此：（其余类推）</li>
</ul>
<p><span class="math display">\[
|A_1| =
\left( \begin{matrix} 6+3-1 \\ 6 \end{matrix} \right) =
\left( \begin{matrix} 8 \\ 6 \end{matrix} \right) = 28
\]</span></p>
<ul>
<li><span class="math inline">\(A_1 \cap A_2\)</span> 中的每个子集中
<span class="math inline">\(a\)</span> 至少出现 <span
class="math inline">\(4\)</span> 次同时 <span
class="math inline">\(b\)</span> 至少出现 <span
class="math inline">\(5\)</span> 次，剩下 <span
class="math inline">\(1\)</span> 个元素可以是 <span
class="math inline">\(T*\)</span> 的任何 <span
class="math inline">\(1\)</span> 组合，因此：</li>
</ul>
<p><span class="math display">\[
|A_1 \cap A_2| =
\left( \begin{matrix} 1+3-1 \\ 1 \end{matrix} \right) =
\left( \begin{matrix} 3 \\ 1 \end{matrix} \right) = 3
\]</span></p>
<blockquote>
<p>这个地方先取 <span class="math inline">\(4\)</span> 个 <span
class="math inline">\(a\)</span>，后面仍可以从无穷集 <span
class="math inline">\(T^*\)</span> 中取 <span
class="math inline">\(a\)</span>，保证了情况是完备的</p>
</blockquote></li>
</ul></li>
<li><p>例：求满足 <span class="math inline">\(1 \leq x_1 \leq 5, -2 \leq
x_2 \leq 4, 0 \leq x_3 \leq 5, 3 \leq x_4 \leq 9\)</span> 的方程 <span
class="math inline">\(x_1+x_2+x_3+x_4 =18\)</span>的整数解个数。</p>
<ul>
<li>转化为“确定多重集 <span class="math inline">\(T=\{4 \cdot a, 6 \cdot
b, 5 \cdot c, 6 \cdot d\}\)</span> 的 <span
class="math inline">\(16\)</span> 子集的个数”，解法与上类似</li>
</ul></li>
</ul>
<h4 id="错位排列-derangement">6.3 错位排列 Derangement</h4>
<ul>
<li><p><strong>错位排列：</strong> 设 <span
class="math inline">\(X={1,2, \dots ,n}\)</span>，它的排列用 <span
class="math inline">\(i_1 i_2 \dots i_n\)</span> 表示, 错位排列是使得
<span class="math inline">\(i_1 \neq 1, i_2 \neq 2,\dots, i_n \neq
n\)</span> 的排列。用<span
class="math inline">\(D_n\)</span>表示错位排列个数。</p>
<ul>
<li>前几项：<span class="math inline">\(D_1 = 0，D_2 = 1，D_3 = 2，D_4 =
9\)</span></li>
</ul></li>
<li><p><strong>定理6.3.1：</strong> 对 <span class="math inline">\(n
\geq 1\)</span>，（应用容斥原理） <span class="math display">\[
D_n=n!-\binom{n}{1}(n-1)!+\binom{n}{2}(n-2)!+...+(-1)^n\binom{n}{n}0!
\]</span></p>
<p><span class="math display">\[
D_n = n! \ (1 - \dfrac{1}{1!} + \dfrac{1}{2!} - \dfrac{1}{3!} + \dots +
(-1)^n \dfrac{1}{n!})
\]</span></p>
<ul>
<li>计算可得：<span class="math inline">\(D_5=44, D_6=265, D_7=1854,
D_8=14833\)</span></li>
</ul></li>
<li><p>例：确定 <span class="math inline">\({1, 2,…, 8}\)</span>
的排列中恰有四个整数在它们的自然位置上的排列数。</p>
<ul>
<li><p>解：任选四个整数在自然位置上：$(</p>
<span class="math display">\[\begin{matrix} 8 \\ 4 \end{matrix}\]</span>
<p>) $</p>
<p>剩下四个整数不在其自然位置上： <span
class="math inline">\(D_4\)</span></p>
<p>因此，恰有四个整数在它们的自然位置上的排列数为<span
class="math inline">\(\left( \begin{matrix} 8 \\ 4 \end{matrix} \right)
D_4\)</span></p></li>
</ul></li>
<li><p><strong>错位排列的递推关系1：</strong><span
class="math inline">\(D_n\)</span> 满足如下递推关系： <span
class="math display">\[
D_n = (n-1)(D_{n-2} + D_{n-1}), (n=3,4,\dots) \\
D_2 = 1; D_1 = 0
\]</span> <strong>计算用的递推关系2：</strong> <span
class="math display">\[
D_n = nD_{n-1} + (-1)^n
\]</span></p></li>
</ul>
<h4 id="带有禁止位置的排列">6.4 带有禁止位置的排列</h4>
<ul>
<li><p><strong>带禁止位置的“非攻击型车”：</strong><span
class="math inline">\(\{1,2,…, n\}\)</span> 的排列 <span
class="math inline">\(i_1 i_2 \dots i_n\)</span> 对应于棋盘上以方格
<span class="math inline">\((1, i_1), (2, i_2),\dots, (n, i_n)\)</span>
为坐标的 <span class="math inline">\(n\)</span>
个车的位置。一些位置禁止。</p></li>
<li><p><strong>定理6.4.1：</strong> 将 <span
class="math inline">\(n\)</span>
个非攻击型不可区分的车放到带有禁止位置的 <span class="math inline">\(n
\times n\)</span> 的棋盘中，放法总数等于： <span class="math display">\[
n! - r_1 (n-1)! +  r_2 (n-2)! - \dots + (-1)^k r_k (n-k)! + \dots +
(-1)^n r_n
\]</span></p>
<ul>
<li><span class="math inline">\(r_k\)</span>：所有的 <span
class="math inline">\(k\)</span>
个车放置在其禁止位置上的放置方法数，<span class="math inline">\(k=1,2,…,
n\)</span>，且其计算不考虑剩下的 <span
class="math inline">\(n-k\)</span> 个车的放置</li>
<li>应满足：任意两个车不在同一行或同一列</li>
</ul></li>
</ul>
<h4 id="另一个禁止位置问题">6.5 另一个禁止位置问题</h4>
<ul>
<li><p><strong>相对禁止位置排列计数：</strong><span
class="math inline">\(Q_n\)</span>：<span class="math inline">\(\{1, 2,
\dots , n\}\)</span> 的排列中没有 <span class="math inline">\(12, 23,
\dots , (n-1)n\)</span> 这些模式出现的排列的个数</p>
<ul>
<li>前几项：<span class="math inline">\(Q_1= 1， Q_2 = 1, Q_3 = 3, Q_4 =
11\)</span></li>
</ul></li>
<li><p><strong>用容斥原理计算 <span
class="math inline">\(Q_n\)</span>：</strong>令 <span
class="math inline">\(A_i\)</span> 是 <span
class="math inline">\(i(i+1)\)</span> 出现的排列的集合，<span
class="math inline">\(i=1,2,\dots,n-1\)</span></p>
<ul>
<li><p>计算 <span class="math inline">\(A_i\)</span> : <span
class="math inline">\(A_1\)</span> 可看作 <span
class="math inline">\(1,2, 3,\dots, n\)</span> 的所有排列的集合，因此
<span class="math inline">\(|A_1|=(n-1)!\)</span>。
显然，由于对称性，对任意 <span
class="math inline">\(i\)</span>，都有<span
class="math inline">\(|A_i|=(n-1)!\)</span></p></li>
<li><p>计算<span class="math inline">\(|A_i \cap
A_j|\)</span>：讨论两种情况：</p>
<ol type="1">
<li><span class="math inline">\(A_i \cap A_{i+1}\)</span>。可看作 <span
class="math inline">\(1, 2, …, (i, i+1, i+2), i+3, …, n\)</span> 的所有
排列的集合，因此<span class="math inline">\(|A_i \cap
A_{i+1}|=(n-2)!\)</span></li>
<li><span class="math inline">\(A_i \cap A_j\)</span>，其中 <span
class="math inline">\(j&gt;i+1\)</span>。可看作 <span
class="math inline">\(1,2,…, (i, i+1), i+2, …, ( j, j+1), …, n\)</span>
的所有排列的集合，因此<span class="math inline">\(|A_i \cap
A_j|=(n-2)!\)</span></li>
</ol>
<p>所以，对任意 <span class="math inline">\(i, j\)</span>，都有<span
class="math inline">\(|A_i \cap A_j|=(n-2)!\)</span></p></li>
<li><p>同理可证 ，对于每个 <span class="math inline">\(k\)</span> 子集
<span class="math inline">\(\{i_1,…, i_k\}\)</span>，有 <span
class="math inline">\(|A_{i_1} \cap A_{i_2} \cap \dots \cap
A_{i_k}|=(n-k)!\)</span></p></li>
<li><p>由此推出下面公式。</p></li>
</ul></li>
<li><p><strong>定理6.5.1：</strong>对于 <span class="math inline">\(n
\ge 1\)</span> <span class="math display">\[
\begin{align}
Q_n &amp;= n! + \sum_{k=1}^{n-1} (-1)^k
\left( \begin{matrix} n-1 \\ k \end{matrix} \right) (n-k)!    \\
&amp;= n! -
\left( \begin{matrix} n-1 \\ 1 \end{matrix} \right) (n-1)! +
\left( \begin{matrix} n-1 \\ 2 \end{matrix} \right) (n-2)! + \dots +
(-1)^{n-1} \left( \begin{matrix} n-1 \\ n-1 \end{matrix} \right) 1!
\end{align}
\]</span></p></li>
<li><p>例：旋转木马有 <span class="math inline">\(8\)</span>
个座，每个座位都代表一种不同的动物。<span
class="math inline">\(8\)</span>
个男孩脸朝里围坐在旋转木马上，使得每一个男孩都面对到另一个男孩。他们能够有多少种方法改变座位使得每人面对的男孩都不同于之前面对的男孩？</p>
<ul>
<li>假设 <span class="math inline">\(8\)</span> 个男孩分成了四对：<span
class="math inline">\((1,5), (2,6), (3,7), (4,8)\)</span>。 假设 <span
class="math inline">\(A_1, A_2, A_3, A_4\)</span> 分别表示仍然有 <span
class="math inline">\((1,5), (2,6), (3,7), (4,8)\)</span>
出现的坐法的集合。则使得每人面对的男孩都不同的坐法的数目为：<span
class="math inline">\(|\overline{A_1} \cap \overline{A_2} \cap
\overline{A_3} \cap \overline{A_4}|\)</span></li>
</ul>
<p><span class="math display">\[
|A_1| = |A_i| = 8 * 6! \\
|A_1 \cap A_2| = 8 * 6 * 4! \\
|A_1 \cap A_2 \cap A_3| = 8 * 6 * 4*2! \\
|A_1 \cap A_2 \cap A_3 \cap A_4| = 8 * 6 * 4 * 2
\]</span></p></li>
<li><p>相对禁止位置 <span class="math inline">\(Q_n\)</span> 与错位排列
<span class="math inline">\(D_n\)</span> 的关系： <span
class="math display">\[
Q_n = D_n + D_{n-1}
\]</span></p></li>
</ul>
<h3 id="第7章-递推关系和生成函数"><strong>第7章
递推关系和生成函数</strong></h3>
<blockquote>
<p>生成函数核心思想：</p>
<ol type="1">
<li>把离散数列和幂级数一一对应起来</li>
<li>把离散数列间的相互结合关系对应成为幂级数间的运算关系</li>
<li>由幂级数形式确定离散数列的构造</li>
</ol>
</blockquote>
<blockquote>
<p><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611140632902.png" alt="image-20230611140632902" style="zoom:50%;" /></p>
</blockquote>
<h4 id="若干数列">7.1 若干数列</h4>
<ul>
<li><p>例：设 <span class="math inline">\(h_n\)</span> 是 <span
class="math inline">\(1\)</span> 行 <span
class="math inline">\(n\)</span>
列棋盘用红黄蓝三种颜色着色并使得没有着成红色的方格相邻的着色方法数。求
<span class="math inline">\(h_n\)</span> 满足的递推关系。</p>
<ul>
<li><p>末尾为红：必须前面再放黄色or蓝色保证不相邻 <span
class="math inline">\(2h_{n-2}\)</span></p></li>
<li><p>末尾为蓝or黄：直接拼接即可 <span
class="math inline">\(2h_{n-1}\)</span></p></li>
</ul></li>
<li><p>例：确定 <span class="math inline">\(2 \times n\)</span>
棋盘用多米诺牌完全覆盖的方法数 <span
class="math inline">\(h_n\)</span></p></li>
<li><p>例：确定用单牌和多米诺牌完美覆盖 <span class="math inline">\(1
\times n\)</span> 棋盘的方法数 <span
class="math inline">\(b_n\)</span></p></li>
<li><p><strong><span class="math inline">\(Fibonacci\)</span>
数列：</strong></p>
<ul>
<li>部分和：<span class="math inline">\(s_n = f_0+f_1+ \dots +f_n =
f_{n+2}-1\)</span>
<ul>
<li>证明：数学归纳法</li>
</ul></li>
<li><span class="math inline">\(f_n\)</span> 是偶数当且仅当 <span
class="math inline">\(n\)</span> 被 <span
class="math inline">\(3\)</span> 整除
<ul>
<li>每三项都是偶奇奇</li>
</ul></li>
</ul></li>
<li><p><strong>定理7.1.2：</strong>沿 <span
class="math inline">\(Pascal\)</span>
三角形从左下到右上的对角线上的二项式系数和是斐波那契数，即 <span
class="math display">\[
f_n =
\left( \begin{matrix} n-1 \\ 0 \end{matrix} \right) +
\left( \begin{matrix} n-2 \\ 1 \end{matrix} \right) +
\left( \begin{matrix} n-3 \\ 2 \end{matrix} \right) + \dots +
\left( \begin{matrix} n-k \\ k-1 \end{matrix} \right)
\]</span> 其中，<span class="math inline">\(k=\lfloor (n+1)/2
\rfloor\)</span></p></li>
</ul>
<h4 id="生成函数">7.2 生成函数</h4>
<ul>
<li>令 <span class="math inline">\(h_0, h_1, \dots ,h_n \dots\)</span>
为一无穷数列，其生成函数定义为：</li>
</ul>
<p><span class="math display">\[
g(x)=h_0 +h_1x+h_2x^2+\dots+h_nx^n+\dots
\]</span></p>
<ul>
<li><p>例：设 <span class="math inline">\(k\)</span> 是正整数，<span
class="math inline">\(h_n\)</span> 等于方程 <span
class="math inline">\(e_1+e_2+ \dots +e_k =n\)</span>
的非负整数解个数，即 <span class="math inline">\(h_n\)</span> 为多重集
$S={a_1, a_2, , a_k} $的 <span class="math inline">\(n\)</span> -
组合个数，求数列 <span class="math inline">\(h_0, h_1,…, h_n…\)</span>
的生成函数 <span class="math inline">\(g(x)\)</span>。</p>
<ul>
<li>由于<span class="math inline">\(h_n = \left( \begin{matrix} n+k-1 \\
n \end{matrix} \right)\)</span>。因此，</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
g(x) &amp;= \sum_{n=0}^\infty
\left( \begin{matrix} n+k-1 \\ n \end{matrix} \right) x^n =
\dfrac{1}{(1-x)^k} \ (|x|&lt;1)  \\
&amp;= (\sum_{e_1=0}^\infty x^{e_1})
(\sum_{e_2=0}^\infty x^{e_2}) \dots
(\sum_{e_k=0}^\infty x^{e_k})
\end{aligned}
\]</span></p></li>
<li><p>例：设 <span class="math inline">\(S\)</span> 是多重集合${a_1,
a_2, a_3 , a_4} $。确定数列 <span class="math inline">\(h_0, h_1,…, h_n,
…\)</span> 的生成函数，其中 <span class="math inline">\(h_n\)</span>
是满足以下约束的 <span class="math inline">\(S\)</span> 的 <span
class="math inline">\(n\)</span> 组合数。 (1) <span
class="math inline">\(a_1\)</span> 出现奇数次，<span
class="math inline">\(a_2\)</span> 出现偶数次。 (2) 元素 <span
class="math inline">\(a_1\)</span> 不会出现，<span
class="math inline">\(a_2\)</span> 至多出现 <span
class="math inline">\(1\)</span> 次。 (3) 每个 <span
class="math inline">\(a_i\)</span> 出现的次数是 <span
class="math inline">\(3\)</span> 的倍数。</p>
<ul>
<li>解: (1) 生成函数 <span class="math display">\[
\begin{align}
g(x)
&amp;=(x+x^3+x^5+...+x^{2n+1}+...) (1+x^2+x^4+...+x^{2n}+...)
(1+x+x^2+...+x^n+...)^2 \\
&amp;=x(1+x^2+x^4+...+x^{2n}+...)^2 (1+x+x^2+...+x^n+...)^2 \\
&amp;= x(\dfrac{1}{1-x^2})^2 (\dfrac{1}{1-x})^2
\end{align}
\]</span>
<ol start="2" type="1">
<li><p>生成函数 <span class="math inline">\(g(x) =1
(1+x)(1+x+x^2+…+x^n+…)^2= (1+x)/(1-x)^2\)</span></p></li>
<li><p>生成函数 <span class="math inline">\(g(x) =
(1+x^3+x^6+…x^{3n}+…)^4 = 1/(1-x^3)^4\)</span></p></li>
</ol></li>
</ul></li>
<li><p>例：由生成函数求通项 <span
class="math inline">\(h_n\)</span></p></li>
<li><p><strong>几个常见的展开式：</strong> <span class="math display">\[
(1-x)^n = \sum_{k=0}^\infty \left( \begin{matrix} n \\ k \end{matrix}
\right) x^k \\
\dfrac{1}{(1-x)^n} = \sum_{k=0}^\infty \left( \begin{matrix} n+k-1 \\ k
\end{matrix} \right) x^k
\]</span></p>
<ul>
<li><span class="math inline">\(+x\)</span> 用 <span
class="math inline">\(-x\)</span> 带入 <span
class="math inline">\(x\)</span> 即可</li>
</ul></li>
<li><p>例：求装有苹果、香蕉、桔子和梨的果篮的数量 <span
class="math inline">\(h_n\)</span>，其中每个果篮中，苹果的个数是偶数，香蕉的个数是
<span class="math inline">\(5\)</span> 的倍数, 桔子不超过 <span
class="math inline">\(4\)</span> 个，而且至多只有一个梨. <span
class="math display">\[
\begin{align}
g(x) &amp;=(1+x^2+x^4+…)( 1+x^5+x^{10}+x^{15}+…)(1+x+x^2+x^3+x^4)(
1+x)   \\
&amp;= \dfrac{1}{1-x^2} \cdot \dfrac{1}{1-x^5} \cdot \dfrac{1-x^5}{1-x}
\cdot (1+x)   \\
&amp;= \dfrac{1}{(1-x)^2} \\
&amp;= \sum_{n=0}^\infty \left( \begin{matrix} n+1 \\ n \end{matrix}
\right) x^n  \\
&amp;= \sum_{n=0}^\infty (n+1) x^n
\end{align}
\]</span> 因此，满足条件的 <span class="math inline">\(n\)</span>
组合个数为 <span class="math inline">\(h_n =n+1\)</span>。</p></li>
<li><p>例（带系数）：设 <span class="math inline">\(h_n\)</span> 是方程
<span class="math inline">\(3e_1+4e_2+2e_3+5e_4=n\)</span>
的非负整数解的个数，求序列 <span class="math inline">\(h_0, h_1,
…,h_n,…\)</span> 的生成函数.</p>
<blockquote>
<p>生成函数针对的是系数为 <span class="math inline">\(1\)</span>
的情况，所以化归一下，化成系数为 <span class="math inline">\(1\)</span>
即可</p>
</blockquote>
<p>作变量替换 <span class="math inline">\(f_1=3e_1, f_2=4e_2, f_3=2e_3,
f_4=5e_4\)</span> 得到 <span class="math inline">\(f_1+f_2+f_3+f_4=n
\quad (1)\)</span></p>
<p>因此，<span class="math inline">\(h_n\)</span> 等于方程 <span
class="math inline">\((1)\)</span> 的非负整数解的个数，满足 <span
class="math inline">\(f_1\)</span> 是 <span
class="math inline">\(3\)</span> 的倍数，<span
class="math inline">\(f_2\)</span> 是 <span
class="math inline">\(4\)</span> 的倍数，<span
class="math inline">\(f_3\)</span> 是 <span
class="math inline">\(2\)</span> 的倍数，<span
class="math inline">\(f_4\)</span> 是 <span
class="math inline">\(5\)</span> 的倍数。</p>
<p>因此，生成函数为 <span class="math display">\[
\begin{align}
g(x) &amp;=(1+x^3+x^6+…)(1+x^4+x^8+…)(1+x^2+x^4+…)(1+x^5+x^{10}+…) \\
&amp;=\dfrac{1}{1-x^3}\cdot\dfrac{1}{1-x^4}\cdot\dfrac{1}{1-x^2}\cdot\dfrac{1}{1-x^5}
\end{align}
\]</span></p></li>
</ul>
<h4 id="指数生成函数">7.3 指数生成函数</h4>
<ul>
<li><p>数列 <span class="math inline">\(h_0,h_1,h_2, \dots ,h_n\)</span>
的指数生成函数定义为： <span class="math display">\[
g^{(e)}(x) = h_0 + \dfrac{h_1}{1!} x +
\dfrac{h_2}{2!} x^2 + \dfrac{h_3}{3!} x^3 + \dots +
\dfrac{h_k}{k!} x^k + \dots
\]</span></p></li>
<li><p><strong>带有附加限制的多重集合 <span
class="math inline">\(n\)</span> 排列数列：</strong></p>
<ul>
<li><p>例：用红、蓝、黄三种颜色给 <span class="math inline">\(1 \times
n\)</span>
的棋盘着色，如果要求被着成红色的方格数是偶数，确定给这个棋盘着色的方法数
<span class="math inline">\(h_n\)</span>。</p>
<p>设 <span class="math inline">\(h_n\)</span> 表示着色的方法数，定义
<span class="math inline">\(h_0=1\)</span>。 显然，<span
class="math inline">\(h_n\)</span> 等于 <span
class="math inline">\(3\)</span> 种颜色的多重集合的 <span
class="math inline">\(n\)</span>
排列数，其中每种颜色的重数是无穷的，且要求红色出现的次数是偶数。
因此，指数生成函数为 <span class="math display">\[
\begin{align}
g^{(e)}(x) &amp;= (1 + \dfrac{x^2}{2!} + \dfrac{x^4}{4!} + \dots)
(1 + \dfrac{x^1}{1!} + \dfrac{x^2}{2!} + \dots)
(1 + \dfrac{x^1}{1!} + \dfrac{x^2}{2!} + \dots) \\
&amp;= \dfrac{1}{2}(e^x+e^{-x})e^x e^x = \dfrac{1}{2} (e^{3x}+e^x)  \\
&amp;= \dfrac{1}{2} (\sum_{n=0}^\infty 3^n \dfrac{x^n}{n!} +
\sum_{n=0}^\infty \dfrac{x^n}{n!})
= \dfrac{1}{2} \sum_{n=0}^\infty (3^n+1) \dfrac{x^n}{n!}
\end{align}
\]</span> 得$ h_n=(3^n+1)/2$。</p></li>
</ul></li>
<li><p><strong>常见展开</strong> <span class="math display">\[
e^x = \sum_{n=0}^\infty \dfrac{x^n}{n!}
= 1 + x + \dfrac{x^2}{2!} + \dots + \dfrac{x^n}{n!} + \dots   \\
\dfrac{1}{2} (e^x+e^{-x})  = 1 + \dfrac{x^2}{2!} + \dfrac{x^4}{4!} +
\dots + \dfrac{x^{2n}}{2n!} + \dots    \\
\dfrac{1}{2} (e^x-e^{-x})  = x + \dfrac{x^3}{3!} + \dfrac{x^5}{5!} +
\dots + \dfrac{x^{2n+1}}{(2n+1)!} + \dots
\]</span></p></li>
</ul>
<h4 id="求解线性齐次递推关系">7.4 求解线性齐次递推关系</h4>
<ul>
<li><p><strong>（齐次）线性递推关系：</strong>令 <span
class="math inline">\(h_0, h_1, h_2,…, h_n,…\)</span>
是一个数列，若存在量 <span class="math inline">\(a_1, a_2,…,a_k\)</span>
和量 <span
class="math inline">\(b_n\)</span>（每个量是常数或<strong>依赖于 <span
class="math inline">\(n\)</span> 的数</strong>）使得： <span
class="math display">\[
h_n = a_1 h_{n-1} +  a_2 h_{n-2} + \dots +  a_k h_{n-k} +b_n \ (n \geq
k)
\]</span> 则称该数列满足 <strong><span
class="math inline">\(k\)</span></strong> 阶线性递推关系</p>
<p>若 <span class="math inline">\(b_n =0\)</span>，则称该数列是 <span
class="math inline">\(k\)</span> 阶线性齐次递推关系</p>
<p>若 <span class="math inline">\(a_1, a_2, \dots, a_k\)</span>
都为常数，则称该数列是 <span class="math inline">\(k\)</span>
阶常系数线性递推关系</p>
<blockquote>
<p>解法：</p>
<ul>
<li>特征方程法</li>
<li>生成函数法</li>
</ul>
</blockquote></li>
<li><p><strong>定理7.4.1（特征方程与原递推关系同解）：</strong>令 <span
class="math inline">\(q\)</span> 为一个非零数，则 <span
class="math inline">\(h_n =q_n\)</span> 是常系数线性齐次递推关系 <span
class="math display">\[
h_n = a_1 h_{n-1} +  a_2 h_{n-2} + \dots +  a_k h_{n-k} +b_n \ (a_k \neq
0, n \geq k)
\]</span> 的解当且仅当 <span
class="math inline">\(q\)</span>（特征根）是多项式方程 <span
class="math display">\[
x^k - a_1 x_{k-1} - a_2 x_{k-2} - \dots - a_{k-1} x -a_k = 0
\]</span> 的一个根。</p>
<p>若特征根多项式方程有 <span class="math inline">\(k\)</span>
个不同的根 <span class="math inline">\(q_1, q_2,…, q_k\)</span>，则
<span class="math display">\[
h_n = c_1 q_1 ^n  +  c_2 q_2 ^n + \dots +  c_k q_k ^n
\]</span> 是下述意义下原递推关系的通解：任意给定初始值 <span
class="math inline">\(h_0, h_1, …,h_{k-1}\)</span>，都存在 <span
class="math inline">\(c_1, c_2,…, c_k\)</span>
使得上式是满足原递推关系式和初始条件的唯一的数列.</p>
<blockquote>
<p>线性组合的意思</p>
</blockquote></li>
<li><p>例：确定由 <span class="math inline">\(0, 1, 2\)</span>
组成的长度为 <span class="math inline">\(n\)</span> 且不包含两个连续的
<span class="math inline">\(0\)</span> 或两个连续的 <span
class="math inline">\(1\)</span> 的三进制串的个数 <span
class="math inline">\(a_n\)</span> 的递推关系，然后求出 <span
class="math inline">\(a_n\)</span> 的公式。</p>
<ul>
<li><p>解: 当 <span class="math inline">\(n=0\)</span> 时，为空串，此时
<span class="math inline">\(a_0=1\)</span>；</p>
<p>当 <span class="math inline">\(n=1\)</span> 时, 满足条件的三进制串为
<span class="math inline">\(0, 1, 2\)</span>，得 <span
class="math inline">\(a_1=3\)</span></p>
<p>当 <span class="math inline">\(n&gt;1\)</span> 时，设以 <span
class="math inline">\(0，1，2\)</span> 开头的长度为三进制串的个数分别为
<span class="math inline">\(b_n, c_n, d_n\)</span>，则 <span
class="math inline">\(a_n =b_n+c_n+d_n\)</span>。</p>
<ol type="a">
<li><p>当以 <span class="math inline">\(0\)</span> 开头时，<span
class="math inline">\(b_n=c_{n-1}+d_{n-1} \quad (1)\)</span></p></li>
<li><p>当以 <span class="math inline">\(1\)</span> 开头时，<span
class="math inline">\(c_n=b_{n-1}+d_{n-1} \quad (2)\)</span></p></li>
<li><p>当以 <span class="math inline">\(2\)</span> 开头时，<span
class="math inline">\(d_n=b_{n-1}+c_{n-1}+d_{n-1}=a_{n-1} \quad
(3)\)</span></p></li>
</ol>
<p>把 <span class="math inline">\((1), (2), (3)\)</span>
式左右两边分别相加得：<span class="math inline">\(a_n = b_n+c_n+d_n =
c_{n-1}+d_{n-1}+b_{n-1}+d_{n-1}+a_{n-1} = a_{n-1}+a_{n-2}+a_{n-1} =
2a_{n-1} + a_{n-2}\)</span></p></li>
</ul></li>
<li><p>例：利用<strong>生成函数</strong>求解 <span
class="math inline">\(h_n=h_{n-1}+9h_{n-2}-9h_{n-3} (n&gt;2), h_0=0,
h_1=1, h_2=2\)</span>。（配凑递推式的系数）</p>
<ul>
<li><p>令生成函数为 <span
class="math inline">\(g(x)=h_0+h_1x+h_2x^2+…+h_nx^n+… \quad
(1)\)</span></p>
<p><span class="math inline">\((1)\)</span> 式两边分别同乘 <span
class="math inline">\(–x, -9x^2, 9x^3\)</span> , 得 <span
class="math display">\[
\begin{aligned}
&amp;(1-x-9x^2+9x^3) g(x) \\
&amp;= h_0 + (h_1-h_0)x+(h_2-h_1-9h_0)x^2+(h_3-h_2-9h_1+9h_0)x +… \\
&amp;= h_0 + (h_1-h_0)x+(h_2-h_1-9h_0)x^2 \\
&amp;= x+x^2
\end{aligned}
\]</span> 得<span class="math inline">\(g(x) =(x+x^2)/(1-x-9x^2+9x^3) =
(x+x^2)/(1-x)(1-3x)(1+3x)\)</span>，再求得 <span
class="math inline">\(h_n\)</span></p></li>
</ul></li>
<li><p>例：求解递推关系 <span
class="math inline">\(h_n+h_{n-1}-16h_{n-2}+20h_{n-3}=0 (n \ge
3)\)</span> 其中 <span class="math inline">\(h_0=0, h_1=1, h_2=
-1\)</span>.</p>
<ul>
<li><ol type="1">
<li>求数列的生成函数。<span
class="math inline">\(g(x)=x/(1+x-16x^2+20x^3)\)</span></li>
</ol></li>
<li><ol start="2" type="1">
<li>将 <span class="math inline">\(g(x)\)</span> 表示成代数分式和。由于
<span
class="math inline">\((1+x-16x^2+20x^3)=(1-2x)^2(1+5x)\)</span>，得到
<span class="math display">\[
\begin{align}
g(x)&amp; = \dfrac{x}{(1-2x)^2(1+5x)}   \\
&amp;= \dfrac{c_1}{1-2x} + \dfrac{c_2}{(1-2x)^2} +
\dfrac{c_3}{1+5x}    \\
&amp;= -\dfrac{2/49}{1-2x} + \dfrac{7/49}{(1-2x)^2} - \dfrac{5/49}{1+5x}
\end{align}
\]</span></li>
</ol></li>
<li><ol start="3" type="1">
<li>利用牛顿二项式定理展开。 <span class="math display">\[
\dfrac{1}{1-2x} = \sum_{k=0}^\infty 2^k x^k \\
\dfrac{1}{(1-2x)^2} = \sum_{k=0}^\infty
\left( \begin{matrix} k+1 \\ k \end{matrix} \right) 2^k x^k =
\sum_{k=0}^\infty (k+1) 2^k x^k \\
\dfrac{1}{1+5x} = \sum_{k=0}^\infty (-5)^k x^k
\]</span> 于是得到： <span class="math display">\[
g(x) = \sum_{k=0}^\infty
[-\dfrac{2}{49}2^k + \dfrac{7}{49} (k+1) 2^k - \dfrac{5}{49}(-5)^k] x^k
\\
h_n = -\dfrac{2}{49}2^n + \dfrac{7}{49} (n+1) 2^n - \dfrac{5}{49}(-5)^n
\]</span></li>
</ol></li>
</ul></li>
</ul>
<h4 id="非齐次递推关系">7.5 非齐次递推关系</h4>
<ul>
<li><p><strong>一般非齐次递推关系的通解：</strong>假设有非齐次递推关系
<span class="math inline">\(h_n = a_1 h_{n-1} + a_2 h_{n-2} + \dots +
a_k h_{n-k} +b_n\)</span></p>
<p>若 <span class="math inline">\(f_n\)</span> 是对应齐次递推关系 <span
class="math inline">\(h_n&#39; = h_n - b_n = a_1 h_{n-1} + a_2 h_{n-2} +
\dots + a_k h_{n-k}\)</span> 的通解，而 <span
class="math inline">\(c_n\)</span> 是原非齐次递推关系 <span
class="math inline">\((1)\)</span> 的一个特解，那么 <span
class="math inline">\(h_n = c f_n + c_n\)</span> 是原非齐次递推关系
<span class="math inline">\((1)\)</span> 的通解。</p></li>
<li><p>例：求递推关系 <span class="math inline">\(h_n=3h_{n-1}-4n,
h_0=2\)</span>.</p>
<ul>
<li><p>（1）首先求解对应的齐次递推关系 <span
class="math inline">\(h_n=3h_{n-1}\)</span> 的通解。 特征方程为 <span
class="math inline">\(x-3=0\)</span>，特征根为 <span
class="math inline">\(x=3\)</span>，因此通解为 <span
class="math inline">\(h_n =c3^n\)</span></p></li>
<li><p>（2）求 <span class="math inline">\(h_n=3h_{n-1}-4n\)</span>
的一个特解： 猜测解的形式 <span class="math inline">\(h_n
=r_n+s\)</span>，代入递推关系得到：<span class="math inline">\(r_n+s =
3(r_{n-1}+s)-4n= (3r-4)n+(-3r+3s)\)</span> 得到：<span
class="math inline">\(r=3r-4, s=-3r+3s\)</span> 因此，<span
class="math inline">\(r=2\)</span> 和$ s=3$, 从而 <span
class="math inline">\(h_n=2n+3\)</span> 是递推关系的一个特解。</p></li>
<li><p>代入。从而问题的解为：<span class="math inline">\(h_n=
-3^n+2n+3\)</span></p></li>
</ul></li>
<li><p><strong>尝试特解的一些方法：</strong></p>
<ul>
<li><ol type="1">
<li>如果 <span class="math inline">\(b_n\)</span> 是 <span
class="math inline">\(n\)</span> 的 <span
class="math inline">\(k\)</span> 次多项式，那么尝试 <span
class="math inline">\(h_n\)</span> 也是 <span
class="math inline">\(n\)</span> 的 <span
class="math inline">\(k\)</span> 次多项式</li>
</ol>
<ul>
<li>① 若 <span class="math inline">\(b_n =d\)</span> (常数)，尝试 <span
class="math inline">\(h_n =r\)</span> (常数);</li>
<li>② 若 <span class="math inline">\(b_n =d_n+c\)</span> (<span
class="math inline">\(d, c\)</span> 是常数)，尝试 <span
class="math inline">\(h_n = r_n+s\)</span> (<span
class="math inline">\(r,s\)</span> 是常数);</li>
<li>③ 若 <span class="math inline">\(b_n = a_n^2+dn+c\)</span> (<span
class="math inline">\(a,d,c\)</span> 是常数)，尝试 <span
class="math inline">\(h_n = r_n^2+s_n+t\)</span> (<span
class="math inline">\(r,s,t\)</span> 是常数);</li>
</ul></li>
<li><ol start="2" type="1">
<li>若 <span class="math inline">\(b_n =d^n\)</span> (<span
class="math inline">\(d\)</span> 是常数)是指数形式， 尝试 <span
class="math inline">\(h_n = pd^n\)</span> (<span
class="math inline">\(p\)</span> 是常数)也是指数形式。</li>
</ol>
<ul>
<li>如果失败了可以尝试 <span class="math inline">\(h_n =
pnd^n\)</span></li>
</ul></li>
</ul></li>
</ul>
<h4 id="一个几何例子">7.6 一个几何例子</h4>
<ul>
<li><strong>定理7.6.1（凸多边形三角形剖分方法计数）：</strong>设 <span
class="math inline">\(h_n\)</span>
表示用下面方法把凸多边形区域分成三角形区域的方法数： 在有 <span
class="math inline">\(n+1\)</span>
条边的凸多边形区域内通过插入不相交的对角线，而把它分成三角形区域。 定义
<span class="math inline">\(h_1 =1\)</span>。则 <span
class="math inline">\(h_n\)</span> 满足如下递推关系: <span
class="math display">\[
\begin{align}
h_n &amp;= h_1 h_{n-1} + h_2 h_{n-2} + \dots + h_{n-1} h_1    \\
&amp;= \sum_{k=1}^{n-1} h_k h_{n-k} \ (n \geq 2)
\end{align}
\]</span> 该递推关系解为： <span class="math display">\[
h_n = \dfrac{1}{n}
\left( \begin{matrix} 2n-2 \\ n-1 \end{matrix} \right),(n=1,2,3,\dots)
\]</span> 前几项：<span class="math inline">\(h_1 = 1, h_2 = 1, h_3 = 2,
h_4 = 5\)</span></li>
</ul>
<h3 id="第8章-特殊计数序列"><strong>第8章 特殊计数序列</strong></h3>
<h4 id="catalan-数">8.1 <span class="math inline">\(Catalan\)</span>
数</h4>
<ul>
<li><p>（接上文）<strong><span class="math inline">\(Catalan\)</span>
数列：</strong> <span class="math inline">\(Catalan\)</span> 数列是序列
<span class="math inline">\(C_0, C_1,…, C_n,…,\)</span> 其中 <span
class="math display">\[
C_n = \dfrac{1}{n+1}
\left( \begin{matrix} 2n \\ n \end{matrix} \right),(n=0,1,2,\dots)
\]</span> 是第 <span class="math inline">\(n\)</span> 个 <span
class="math inline">\(Catalan\)</span> 数。</p>
<blockquote>
<p>记法：重要的组合部分是 <span class="math inline">\(n\)</span>
相关，外面的分子不太重要</p>
</blockquote>
<p>前几项：<span class="math inline">\(C_1 = 1, C_2 = 2, C_3 = 5, C_4 =
14\)</span></p>
<blockquote>
<p>千万注意是第 <span class="math inline">\(n\)</span> 个还是第 <span
class="math inline">\(n+1\)</span> 个</p>
<p>且 <span class="math inline">\(C_{n-1}\)</span> 对应凸 <span
class="math inline">\(n+1\)</span> 多边形，相差 <span
class="math inline">\(2\)</span></p>
</blockquote></li>
<li><p>例（括号化问题）：矩阵连乘 <span class="math inline">\(P=
A_1×A_2×…×A_n\)</span>，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？</p>
<ul>
<li>分别计算两个部分，然后对两个部分分别括号化</li>
<li><span class="math inline">\(h_n = h_1h_{n-1} + h_2h_{n-2} +
h_3h_{n-3} + \dots + h_{n-1}h_1\)</span></li>
<li><span class="math inline">\(h_n=C_{n-1}\)</span></li>
</ul></li>
<li><p>例（出栈次序问题）：一个栈(无穷大)的进栈序列为 <span
class="math inline">\(1, 2, 3, …, n\)</span>，有多少个不同的出栈序列?
（后进先出）</p>
<ul>
<li><p>记出栈序列数目为 <span
class="math inline">\(h_n\)</span></p></li>
<li><p>假设一个出栈序列的最后一个出栈元素为 <span
class="math inline">\(k (1≤k ≤n)\)</span>，则有</p>
<p>（1）元素 <span class="math inline">\(1, 2, …, k-1\)</span>
的进栈与出栈在 <span class="math inline">\(k\)</span>
入栈前全部完成;</p>
<p>（2）元素 <span class="math inline">\(k+1,…, n\)</span>
的进栈与出栈在 <span class="math inline">\(k\)</span> 入栈后直至 <span
class="math inline">\(k\)</span> 出栈前全部完成。</p>
<p>因此，由乘法原理，最后一个出栈元素为 <span
class="math inline">\(k\)</span> 的出栈序列的个数为 <span
class="math inline">\(h_{k-1} h_{n-k}\)</span></p></li>
<li><p>由递推关系知 <span
class="math inline">\(h_n=C_n\)</span></p></li>
</ul></li>
<li><p>例（二叉树数目）：<span class="math inline">\(n\)</span>
个节点构成的二叉树的情况有 <span class="math inline">\(h_n =
C_n\)</span> 种</p></li>
<li><p><strong>定理8.1.1：</strong>考虑由 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(+1\)</span> 和 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(-1\)</span> 构成的 <span
class="math inline">\(2n\)</span> 项序列 <span
class="math inline">\(a_1,a_2,\dots,a_{2n}\)</span>，
其部分和满足：<span class="math inline">\(a_1 + a_2 + \dots + a_k \geq 0
\ (k=1,2,…,2n)\)</span> 的序列的个数等于第 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(Catalan\)</span> 数 <span class="math display">\[
C_n = \dfrac{1}{n+1}
\left( \begin{matrix} 2n \\ n \end{matrix} \right) (n \geq 0)
\]</span></p>
<ul>
<li><p>例（找零）：有 <span class="math inline">\(2n\)</span>
个人排成一对进电影院，门票 <span class="math inline">\(50\)</span>
元，<span class="math inline">\(2n\)</span> 个人中的 <span
class="math inline">\(n\)</span> 个人有 <span
class="math inline">\(50\)</span> 元纸币，<span
class="math inline">\(n\)</span> 个人有 <span
class="math inline">\(100\)</span> 元纸币。
电影院设置售票点，假设未备有零钱，有多少种排队方法使得只要有 <span
class="math inline">\(100\)</span> 元的人买票，售票处就有 <span
class="math inline">\(50\)</span> 元的纸币找零？</p>
<p>（1）情况 <span class="math inline">\(1\)</span>：若把 <span
class="math inline">\(2n\)</span> 个人看成不可区分的，将 <span
class="math inline">\(50\)</span> 元用 <span
class="math inline">\(+1\)</span> 表示，<span
class="math inline">\(100\)</span> 元用 <span
class="math inline">\(-1\)</span> 表示。答案 <span
class="math inline">\(C_n\)</span></p>
<p>（2）情况 <span class="math inline">\(2\)</span>：若把 <span
class="math inline">\(2n\)</span> 个人看成可区分的。则需要考虑 <span
class="math inline">\(n\)</span> 个有 <span
class="math inline">\(50\)</span> 元纸币的人的排列，以及 <span
class="math inline">\(n\)</span> 个有 <span
class="math inline">\(100\)</span> 元纸币的人的排列。 因此排队方法数为：
<span class="math display">\[
(n!\ n!)\dfrac{1}{n+1} \
\left( \begin{matrix} 2n \\ n \end{matrix} \right) (n \geq 0)
\]</span></p></li>
<li><p>例：一位大城市的律师在她住所以北 <span
class="math inline">\(n\)</span> 个街区和以东 <span
class="math inline">\(n\)</span> 个街区处工作。每天她走 <span
class="math inline">\(2n\)</span>
个街区上班。如果她不穿越从家到办公室的对角线，有多少可能的道路？</p>
<p>用 <span class="math inline">\(+1\)</span> 表示向东，<span
class="math inline">\(-1\)</span> 表示向北。则每条路径对应一个 <span
class="math inline">\(+1, -1\)</span> 的序列 <span
class="math inline">\(a_1,a_2,\dots,a_{2n}\)</span></p></li>
</ul></li>
<li><p><strong><span class="math inline">\(Catalan\)</span>
序列递推关系和初始条件为：</strong> <span class="math display">\[
C_n = \dfrac{4n-2}{n+1} C_{n-1} (n \geq 1) ,C_0 = 1
\]</span></p></li>
</ul>
<h4 id="差分序列和-stirling-数">8.2 差分序列和 <span
class="math inline">\(Stirling\)</span> 数</h4>
<ul>
<li><p><strong>差分序列：</strong>设 <span class="math inline">\(h_0,
h_1, h_2, …, h_n, …\)</span> 是一个序列。定义新序列: $h_0, h_1, h_2, ,
h_n, $称为 <span class="math inline">\(h_0, h_1, h_2, …, h_n, …\)</span>
的（一阶）差分序列，其中 <span class="math inline">\(\Delta h_n =
h_{n+1} - h_n (n \geq 0)\)</span>，是序列的相邻项的差。</p></li>
<li><p><strong>定理8.2.2：</strong>差分表的第 <span
class="math inline">\(0\)</span> 条对角线等于 <span
class="math inline">\(c_0, c_1, c_2, …, c_p, 0, 0, 0, …\)</span>， 其中
<span class="math inline">\(c_p≠ 0\)</span> 的序列的通项满足： <span
class="math display">\[
h_n =
c_0 \left( \begin{matrix} n \\ 0 \end{matrix} \right) +
c_1 \left( \begin{matrix} n \\ 1 \end{matrix} \right) +
c_2 \left( \begin{matrix} n \\ 2 \end{matrix} \right) + \dots +
c_p \left( \begin{matrix} n \\ p \end{matrix} \right)
\]</span> 的关于 <span class="math inline">\(n\)</span> 的 <span
class="math inline">\(p\)</span> 次多项式。</p></li>
<li><p><strong>定理 8.2.3：</strong>假设序列 <span
class="math inline">\(h_0, h_1, h_2, …, h_n, …\)</span> 的差分表的第
<span class="math inline">\(0\)</span> 条对角线等于 <span
class="math inline">\(c_0, c_1, …, c_p, 0, 0,…\)</span> 那么 <span
class="math display">\[
\sum_{k=0}^n h_k =
c_0 \left( \begin{matrix} n+1 \\ 1 \end{matrix} \right) +
c_1 \left( \begin{matrix} n+1 \\ 2 \end{matrix} \right) +
c_2 \left( \begin{matrix} n+1 \\ 3 \end{matrix} \right) + \dots +
c_p \left( \begin{matrix} n+1 \\ p+1 \end{matrix} \right)
\]</span></p>
<p>其中差分表中第 <span class="math inline">\(0\)</span> 条对角线上的第
<span class="math inline">\(k\)</span> 个元素，记为 <span
class="math inline">\(c(p, k)\)</span>。</p></li>
<li><p><strong>第二类 <span class="math inline">\(Stirling\)</span>
数：</strong> <span class="math display">\[
h_n = n^p = \sum_{k=0}^n \dfrac{c(p,k)}{k!} [n]_k = \sum_{k=0}^n S(p,k)
[n]_k
\]</span> <span class="math inline">\([n]_k\)</span> = <span
class="math inline">\(n\)</span> 个不同元素中取 <span
class="math inline">\(k\)</span> 个元素的排列数 <span
class="math inline">\(P(n, k)\)</span></p></li>
<li><p><strong>定理8.2.4（第二类 <span
class="math inline">\(Stirling\)</span> 数的递推公式）：</strong>如果
<span class="math inline">\(1 ≤ k ≤ p-1\)</span> 则 <span
class="math inline">\(S(p, k) = kS(p-1,k) + S(p-1,
k-1)\)</span></p></li>
<li><p><strong>定理8.2.5（第二类 <span
class="math inline">\(Stirling\)</span> 数的组合解释）：</strong> 第二类
<span class="math inline">\(Stirling\)</span> 数 <span
class="math inline">\(S(p, k)\)</span> 计数的是把 <span
class="math inline">\(p\)</span> 个物品的集合划分到 <span
class="math inline">\(k\)</span>
个不可区分的盒子且没有空盒子的划分的个数。</p>
<ul>
<li><ol type="1">
<li>当 <span class="math inline">\(p\)</span> 独占一个盒子时， 当把
<span class="math inline">\(p\)</span> 从盒子中拿走时，得到剩下的 <span
class="math inline">\(\{1,2,…, p-1\}\)</span> 划分到 <span
class="math inline">\(k-1\)</span> 个非空且不可区分的盒子的划分。
因此，存在 <span class="math inline">\(S(p-1, k-1)\)</span> 种对 <span
class="math inline">\(\{1, 2, …, p\}\)</span> 的满足条件的划分。</li>
</ol></li>
<li><ol start="2" type="1">
<li>当 <span class="math inline">\(p\)</span> 不独占一个盒子时，
相当于先将 <span class="math inline">\(\{1, 2,…, p-1\}\)</span> 放到
<span class="math inline">\(k\)</span> 个盒子，不允许空盒， 共有 <span
class="math inline">\(S(p-1, k)\)</span> 种方案，然后将 <span
class="math inline">\(p\)</span> 放进其中一盒，由乘法原理得方案数为 $
kS(p-1, k)$ 。</li>
</ol></li>
</ul></li>
<li><p>常见的几个关系：</p>
<ul>
<li><span class="math inline">\(S(p,1) = 1\)</span></li>
<li><span class="math inline">\(S(p,2) = 2^{p-1} -1\)</span></li>
<li><span class="math inline">\(S(p,p-1) = \left( \begin{matrix} p \\ 2
\end{matrix} \right)\)</span></li>
<li><span class="math inline">\(S(p, p-2) = \left( \begin{matrix} p \\ 3
\end{matrix} \right) + 3 \left( \begin{matrix} p \\ 4 \end{matrix}
\right) (p \geq 2)\)</span></li>
</ul></li>
<li><p><strong><span class="math inline">\(Bell\)</span>
数：</strong><span class="math inline">\(Bell\)</span> 数是将 <span
class="math inline">\(p\)</span>
个元素的集合分成非空、不可区分的盒子的划分数，记为 <span
class="math inline">\(B_p\)</span>，则：（至少一个盒子， 最多 <span
class="math inline">\(p\)</span> 个盒子） <span class="math display">\[
B_p = S(p,0)+S(p,1)+\dots+S(p,p)
\]</span></p></li>
<li><p><strong>定理8.2.8（第一类 <span
class="math inline">\(Stirling\)</span> 数的递推公式）：</strong>如果
<span class="math inline">\(1≤ k ≤ p-1\)</span> 则： <span
class="math display">\[
s(p, k) = (p-1)s(p-1, k) + s(p-1, k-1)
\]</span></p></li>
<li><p><strong>定理8.2.9（第一类 <span
class="math inline">\(Stirling\)</span> 数的组合解释）：</strong>第一类
<span class="math inline">\(Stirling\)</span> 数 <span
class="math inline">\(s(p, k)\)</span> 是将 <span
class="math inline">\(p\)</span> 个物品排成 <span
class="math inline">\(k\)</span> 个非空的循环排列的方法数。</p>
<ul>
<li><p>设 <span class="math inline">\(p\)</span> 个物品记为 <span
class="math inline">\(1, 2, 3, …, p\)</span>。 将 <span
class="math inline">\(1, 2, 3, …, p\)</span> 排成 <span
class="math inline">\(k\)</span> 个圆圈有两种类型：</p>
<ol type="1">
<li><p>有一个循环排列中只有 <span class="math inline">\(p\)</span>
自己，则共有 <span class="math inline">\(s(p-1,
k-1)\)</span>种;</p></li>
<li><p><span class="math inline">\(p\)</span>
至少和另一个物品在一个循环排列中，则可以通过把 <span
class="math inline">\(1, 2, …, p-1\)</span> 排成 <span
class="math inline">\(k\)</span> 个循环排列，并把 <span
class="math inline">\(p\)</span> 放在 <span class="math inline">\(1, 2,
…, p-1\)</span> 任何 一个物品的左边得到，因此共有 <span
class="math inline">\((p-1) s(p-1, k)\)</span> 种。</p></li>
</ol></li>
</ul></li>
</ul>
<h4 id="分拆数">8.3 分拆数</h4>
<ul>
<li><p>设一个正整数 <span
class="math inline">\(n\)</span>，若存在正整数集 <span
class="math inline">\(\{n_1, n_2,…, n_k\} ( 1≤ k ≤ n，n_i ≤
n)\)</span>，使得 <span class="math inline">\(n_1+n_2+…+n_k=n\)</span>
，则称 <span class="math inline">\(\{n_1, n_2,…, n_k\}\)</span> 是 <span
class="math inline">\(n\)</span> 的一个分拆(或拆分)。 称每个 <span
class="math inline">\(n_i\)</span> 为 <span
class="math inline">\(n\)</span> 的一个部分（或类）。 记 <span
class="math inline">\(n\)</span> 的所有包含 <span
class="math inline">\(k\)</span> 个部分的不同分拆的个数为 <span
class="math inline">\(p_n^k\)</span>，<span
class="math inline">\(n\)</span> 的所有不同分拆的个数记为 <span
class="math inline">\(p_n\)</span>，称为 <span
class="math inline">\(n\)</span> 的分拆数。</p>
<ul>
<li><p>二者的关系为：<span class="math inline">\(p_n^1 + p_n^2 + \dots +
p_n^n = p_n\)</span></p></li>
<li><p>拆分中部分的顺序并不重要</p></li>
</ul></li>
<li><p><span class="math inline">\(n = na_n + (n-1)a_{n-1} + \dots +
2a_2 + a_1 = n\)</span> 对应 <span class="math inline">\(n\)</span>
的一个分拆记作：<span class="math inline">\(\lambda = n^{a_n} \dots
2^{a_2}1^{a_1}\)</span></p></li>
<li><p><strong>分拆数的递推关系：</strong><span
class="math inline">\(\sum_{j=1}^{k}p_n^j = p_{n+k}^k, p_n^1 = p_n^n =
1\)</span></p></li>
<li><p><strong>求 <span
class="math inline">\(p_n^k\)</span>：</strong><span
class="math inline">\(p_n^k = p_{n-k+k}^k =
\sum_{j=1}^kp_{n-k}^j\)</span></p></li>
<li><p><strong>定理8.3.1（转换关系）：</strong>设 <span
class="math inline">\(p_n(r)\)</span> 是最大部分为 <span
class="math inline">\(r\)</span> 的 <span
class="math inline">\(n\)</span> 的分拆的个数，<span
class="math inline">\(q_n(r)\)</span> 是满足分拆各部分不大于 <span
class="math inline">\(r\)</span> 的 <span
class="math inline">\(n-r\)</span> 的分拆数量，<span
class="math inline">\(p_n(r) = q_n(r)\)</span></p></li>
<li><p><strong><span class="math inline">\(Ferrers\)</span>
图：</strong><span class="math inline">\(k\)</span> 行，第 <span
class="math inline">\(i\)</span> 行有 <span
class="math inline">\(n_i\)</span> 点的左对齐点组</p></li>
<li><p><strong>共轭分拆：</strong>将分拆 <span
class="math inline">\(\lambda\)</span> 的 <span
class="math inline">\(Fereers\)</span> 图转置，记为 <span
class="math inline">\(\lambda^*\)</span></p>
<ul>
<li>原分拆的行数对应共轭分拆的最大部分</li>
</ul></li>
<li><p><strong>拆分数定理：</strong>正整数 <span
class="math inline">\(n\)</span> 分成 <span
class="math inline">\(k\)</span> 个部分的拆分个数，等于 <span
class="math inline">\(n\)</span> 分成以 <span
class="math inline">\(k\)</span> 为最大部分的拆分个数</p></li>
<li><p><strong>自共轭分拆：</strong><span class="math inline">\(\lambda
= \lambda*\)</span></p></li>
<li><p><strong>定理8.3.2</strong> 设 <span
class="math inline">\(n\)</span> 是正整数，设 <span
class="math inline">\(p_n^s\)</span> 等于 <span
class="math inline">\(n\)</span> 的自共轭分拆数， 而 <span
class="math inline">\(p_n^t\)</span>
等于分拆成互不相同的若干奇数和的分拆数，则有 <span
class="math display">\[
p_n^s = p_n^t
\]</span></p>
<ul>
<li>利用 <span class="math inline">\(Ferrers\)</span>
图建立两种分拆的一一对应</li>
</ul></li>
<li><p><strong>定理8.3.3（欧拉恒等式）：</strong>设 <span
class="math inline">\(n\)</span> 是正整数，设 <span
class="math inline">\(p_n^o\)</span> 是把 <span
class="math inline">\(n\)</span> 分成奇数和的分拆数， <span
class="math inline">\(p_n^d\)</span> 是把 <span
class="math inline">\(n\)</span> 分成不同部分的分拆个数。则 <span
class="math display">\[
p_n^o = p_n^d
\]</span></p>
<ul>
<li>利用 <span class="math inline">\(Ferrers\)</span>
图建立两种分拆的一一对应</li>
</ul></li>
<li><p>计算分拆数的方法：</p>
<ul>
<li><p>方法一：定理：<span class="math inline">\(n\)</span> 分拆数 <span
class="math inline">\(p_n^k\)</span> 满足下列递推关系： <span
class="math display">\[
\sum_{j=1}^k p_n^i = p_{n+k}^k, p_n^1 = p_n^n = 1
\]</span></p></li>
<li><p>方法二：生成函数（见下）</p></li>
</ul></li>
<li><p><strong>定理8.3.4</strong> 数列 <span class="math inline">\(p_0,
p_1, …, p_n, …\)</span> 的生成函数是 <span class="math display">\[
g(x) = \sum_{n=0}^\infty p_n x^n =
\prod_{k=1}^\infty (1-x^k)^{-1}
\]</span></p>
<ul>
<li><p>证明：由<span class="math inline">\((1-x^k)^{-1} =
1+x^k+x^{2k}+x^{3k}+\dots+x^{a_k k}+\dots\)</span>得 <span
class="math display">\[
\begin{align}
\prod_{k=1}^\infty (1-x^k)^{-1} =
&amp;(1+x+x^2+\dots+x^{1a_1}+\dots) \times  \\
&amp;(1+x^2+x^4+\dots+x^{2a_2}+\dots) \times    \\
&amp;(1+x^k+x^{2k}+\dots+x^{ka_k}+\dots) \times \dots \\
\end{align}
\]</span> 每一个项 <span class="math inline">\(x_n\)</span>
由通过从第一个因子选择 <span
class="math inline">\(x^{1a_1}\)</span>，从第二个因子选择项 <span
class="math inline">\(x^{2a_2}\)</span>，从第三个因子选择项 <span
class="math inline">\(x^{3a_3}\)</span> , <span
class="math inline">\(…\)</span> 得到，其中，<span
class="math inline">\(1a_1+2a_2+3a_3+… ka_k+… = n (0≤a_i
≤n)\)</span></p>
<p>显然，方程 <span class="math inline">\((1)\)</span>
的每个正整数解均对应 <span class="math inline">\(n\)</span>
的一个拆分，因此，<span class="math inline">\(x_n\)</span>
的系数，即方程 <span class="math inline">\((1)\)</span>
的非负整数解的个数，就是 <span class="math inline">\(n\)</span>
的分拆数。</p></li>
</ul></li>
<li><p>几个特殊的生成函数</p>
<ul>
<li><p><span class="math inline">\(n\)</span> 分成 <span
class="math inline">\(k\)</span> 个部分的分拆数 <span
class="math inline">\(p_n^k\)</span> 的生成函数——转化为以 <span
class="math inline">\(k\)</span> 为最大部分的拆分个数 <span
class="math display">\[
g(x)=x^k(1-x)^{-1}(1-x^2)^{-1}...(1-x^k)^{-1}
\]</span></p></li>
<li><p><span class="math inline">\(n\)</span> 分成奇数和的分拆数 <span
class="math inline">\(p_n\)</span> 的生成函数 <span
class="math display">\[
\begin{aligned}
g(x)&amp; =(1-x)^{-1}(1-x^3)^{-1}(1-x^5)^{-1}(1-x^7)^{-1}...  \\
&amp;=(1+x+x^2+...+x^{1a_1}+....)\times
(1+x^3+x^6+...+x^{3a_2}+....)\times (1+x^5+x^{10}+...+x^{5a_k}+....)
\end{aligned}
\]</span></p></li>
<li><p><span class="math inline">\(n\)</span> 分成互不相等的部分的分拆数
<span class="math inline">\(p_n\)</span> 的生成函数 <span
class="math display">\[
g(x)=(1+x)(1+x^2)(1+x^3)...(1+x^n)...
\]</span></p></li>
<li><p><span class="math inline">\(n\)</span>
分成互不相等的奇数部分的分拆数 <span class="math inline">\(p_n\)</span>
的生成函数 <span class="math display">\[
g(x)=(1+x)(1+x^3)(1+x^5)...(1+x^{2k-1})...
\]</span></p></li>
</ul></li>
</ul>
<h3 id="第14章-pólya-计数"><strong>第14章 <span
class="math inline">\(Pólya\)</span> 计数</strong></h3>
<blockquote>
<p>明确给出两种着色方案异同的数学定义</p>
<p>在规定每种颜色出现次数的情况下对着色方案数给出统一的表达式</p>
</blockquote>
<h4 id="置换群与对称群">14.1 置换群与对称群</h4>
<ul>
<li><p>群的定义：给定集合 <span class="math inline">\(G\)</span> 和
<span class="math inline">\(G\)</span> 上的二元运算 “<span
class="math inline">\(•\)</span>”，如果以下四个条件满足，则称代数结构
<span class="math inline">\((G, •)\)</span> 为群:</p>
<p>封闭性、结合律、单位元、逆元</p>
<ul>
<li>群的阶：有限群 <span class="math inline">\(G\)</span>
的元素个数，记为 <span class="math inline">\(|G|\)</span></li>
<li>循环群的生成元：<span class="math inline">\(\exist a \in
G\)</span>，<span class="math inline">\(G\)</span> 中任意元素 <span
class="math inline">\(b\)</span> 均可以表示成 <span
class="math inline">\(a\)</span> 的方幂，则称 <span
class="math inline">\(G\)</span> 为循环群，<span
class="math inline">\(a\)</span> 为该群生成元</li>
</ul></li>
<li><p>置换</p>
<ul>
<li>双射</li>
<li><span class="math inline">\(S_n\)</span> 为 <span
class="math inline">\(X = \{1,2, \dots, n\}\)</span> 的所有 <span
class="math inline">\(n!\)</span> 个置换构成的集合</li>
<li>是函数，可以合成
<ul>
<li>先 <span class="math inline">\(f\)</span> 后 <span
class="math inline">\(g\)</span> 记作 <span class="math inline">\(g
\circ f\)</span>，<span class="math inline">\(f\)</span> 的内容是 <span
class="math inline">\(i_k\)</span>，则 <span class="math inline">\(g
\circ f\)</span> 记作 <span class="math inline">\(j_{i_k}\)</span></li>
<li>满足分配律，通常不满足交换律</li>
</ul></li>
<li>特殊置换
<ul>
<li>自身合成置换</li>
<li>恒等置换</li>
<li>逆置换
<ul>
<li>求法：交换上下两行，然后按自然顺序重新排列第一行的整数</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>置换群：<span class="math inline">\(S_n\)</span> 的非空子集 <span
class="math inline">\(G\)</span>
满足如下四个性质，则称为置换的群，简称置换群</p>
<ul>
<li>封闭性、结合律、单位元、逆元</li>
<li><span class="math inline">\(S_n\)</span> 称为 <span
class="math inline">\(n\)</span> 阶对称群</li>
<li>仅含恒等置换的集合 <span class="math inline">\(G = \{ \iota
\}\)</span> 是一个置换群</li>
<li>置换群满足左消去：<span class="math inline">\(f \circ g = f \circ
h\)</span>，则 <span class="math inline">\(g = h\)</span></li>
</ul></li>
<li><p>几何图形 <span class="math inline">\(\Omega\)</span> 的对称</p>
<ul>
<li>看作顶点、边以及三维情形下的面上的一个置换</li>
<li>对称构成置换群，称为 <span class="math inline">\(\Omega\)</span>
的对称群
<ul>
<li>顶点对称群 <span class="math inline">\(G_c\)</span>
<ul>
<li><span class="math inline">\(n\)</span> 个旋转</li>
<li><span class="math inline">\(n\)</span> 个反射
<ul>
<li><span class="math inline">\(n\)</span> 为偶数：<span
class="math inline">\(\dfrac{n}{2}\)</span> 个关于对角点的反射，<span
class="math inline">\(\dfrac{n}{2}\)</span>
个关于对边中点连线的反射</li>
<li><span class="math inline">\(n\)</span> 为奇数：<span
class="math inline">\(n\)</span> 个关于角点与其对边中点的连线的反射</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>置换群与着色</p>
<ul>
<li><p>一个着色可由一个对称（置换）得到与其等价的另一个着色</p></li>
<li><p>定义 <span class="math inline">\(f * c\)</span> 是使 <span
class="math inline">\(i_k\)</span> 具有颜色 <span
class="math inline">\(c(k)\)</span> 的着色，即 <span
class="math inline">\((f*c)(i_k) = c(k)\)</span></p>
<p><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611210113545.png" alt="image-20230611210113545" style="zoom: 33%;" /></p></li>
<li><p><span class="math inline">\((g \circ f)*c =
g*(f*c)\)</span></p></li>
</ul></li>
<li><p>着色等价关系</p>
<ul>
<li><span class="math inline">\(C\)</span> 是 <span
class="math inline">\(X\)</span> 的一个着色集合，对于 <span
class="math inline">\(G\)</span> 中的任意置换 <span
class="math inline">\(f\)</span> 和 <span
class="math inline">\(C\)</span> 中任意着色 <span
class="math inline">\(c\)</span>，<span class="math inline">\(X\)</span>
的着色 <span class="math inline">\(f*c\)</span> 仍属于 <span
class="math inline">\(C\)</span></li>
<li>定义 <span class="math inline">\(C\)</span> 中关系 <span
class="math inline">\(\sim\)</span>：设 <span class="math inline">\(c_1,
c_2\)</span> 是 <span class="math inline">\(C\)</span>
中的任意两种着色，如果存在 <span class="math inline">\(G\)</span>
中的一个置换 <span class="math inline">\(f\)</span>，使得 <span
class="math inline">\(f*c_1 = c_2\)</span>，则称 <span
class="math inline">\(c_1\)</span> 等价于 <span
class="math inline">\(c_2\)</span>，记为 <span class="math inline">\(c_1
\sim c_2\)</span>
<ul>
<li>满足等价关系的自反性、对称性、传递性</li>
</ul></li>
</ul></li>
<li><p>计算非等价的着色数方法：</p>
<ul>
<li><span class="math inline">\(Burnside\)</span> 定理、<span
class="math inline">\(Pólya\)</span> 计算公式</li>
</ul></li>
</ul>
<h4 id="burnside-定理">14.2 <span
class="math inline">\(Burnside\)</span> 定理</h4>
<ul>
<li><p>稳定核与不变着色集</p>
<ul>
<li>使着色 <span class="math inline">\(c\)</span> 的 <span
class="math inline">\(G\)</span> 中所有置换的集合 <span
class="math inline">\(G(c) = \{f | f \in G, f*c = c\}, c\in
C\)</span>，称为 <span class="math inline">\(c\)</span> 的稳定核
<ul>
<li>任何着色 <span class="math inline">\(c\)</span>
的稳定核也形成一个置换群</li>
</ul></li>
<li>在置换 <span class="math inline">\(f\)</span> 作用下保持不变的 <span
class="math inline">\(C\)</span> 中所有着色的集合 <span
class="math inline">\(C(f) = \{c | c \in C, f*c = c\}, f \in G\)</span>
称为 <span class="math inline">\(f\)</span> 的不变着色集</li>
</ul></li>
<li><p><strong>定理14.2.3 (<span class="math inline">\(Burnside\)</span>
定理)：</strong>设 <span class="math inline">\(G\)</span> 是 <span
class="math inline">\(X\)</span> 的置换群，<span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(X\)</span> 中一个满足下面条件的着色集合：对于
<span class="math inline">\(G\)</span> 中所有 <span
class="math inline">\(f\)</span> 与 <span
class="math inline">\(C\)</span> 中所有 <span
class="math inline">\(c\)</span>，<span
class="math inline">\(f∗c\)</span> 仍在 <span
class="math inline">\(C\)</span> 中，则 <span
class="math inline">\(C\)</span> 中非等价的着色数 <span
class="math inline">\(N(G, C)\)</span> 为 ： <span
class="math display">\[
N(G,C) = \dfrac{1}{|G|} \sum_{f \in G} |C(f)| = \dfrac{1}{|G|} \sum_{c
\in C} |G(c)|
\]</span> 即，<span class="math inline">\(C\)</span>
中非等价的着色数等于在 <span class="math inline">\(G\)</span>
中的置换作用下保持不变的着色的平均数。<span class="math inline">\(C(f) =
\{c|c \in C, f * c = c\}, f \in G\)</span></p>
<p>具体地，设<span
class="math inline">\(G=\{f_1,f_2,\dots,f_n\}\)</span>，则<span
class="math inline">\(N(G,C) = \dfrac{1}{n} \sum_{i=1}^n
|C(f_i)|\)</span></p></li>
<li><p>计数非等价的着色数 <span class="math inline">\(N(G,C)\)</span>
的步骤：</p>
<ul>
<li>确定置换群 <span class="math inline">\(G\)</span>，确定着色集 <span
class="math inline">\(C\)</span></li>
<li>计数 <span class="math inline">\(G\)</span>
中每个置换的不变着色集（或每个着色的稳定核）的大小</li>
<li>套用公式</li>
</ul></li>
<li><p>例：用红、蓝两种颜色给一个正方形的 <span
class="math inline">\(4\)</span>
个顶点着色，试问存在多少种不同的着色方法数</p></li>
<li><p>例(循环排列计数) ：把 <span class="math inline">\(n\)</span>
个不同的对象放在一个圆上，有多少种放法</p></li>
</ul>
<h4 id="pólya-计数">14.3 <span class="math inline">\(Pólya\)</span>
计数</h4>
<blockquote>
<p><span class="math inline">\(Burnside\)</span>
定理计数部分比较复杂，仅考虑置换的循环结构并引入有向圈概念</p>
</blockquote>
<ul>
<li><p><strong>置换循环结构</strong>：<span
class="math inline">\(f\)</span> 是置换，<span class="math inline">\(D_f
= (X, A_f)\)</span> 是顶点集为 <span class="math inline">\(X\)</span>
且边集为 <span class="math inline">\(A_f = \{(i, f(i)) | i \in
X\}\)</span> 的有向图</p>
<ul>
<li><span class="math inline">\(D_f\)</span> 有 <span
class="math inline">\(n\)</span> 个顶点和 <span
class="math inline">\(n\)</span> 条边，且各顶点的入度和出度均为 <span
class="math inline">\(1\)</span></li>
<li>弧集 <span class="math inline">\(A_f\)</span>
可以被划分为若干个有向圈，且每个顶点恰好属于一个有向圈</li>
<li><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611213804336.png" alt="image-20230611213804336" style="zoom:33%;" /></li>
<li><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611213914755.png" alt="image-20230611213914755" style="zoom:33%;" /></li>
</ul></li>
<li><p><strong>循环因子分解</strong></p>
<ul>
<li><p>循环因子分解是唯一的，但是循环出现的次序可以任意变化</p></li>
<li><p><span class="math inline">\(1\)</span> 循环也即恒等置换</p></li>
<li><p>在 <span class="math inline">\(f\)</span> 的循环因子分解中，<span
class="math inline">\(X\)</span> 中的每个元素只出现一次</p></li>
<li><p>例：设 <span class="math inline">\(X=\{1,2,3,4,5,6,7,8\}\)</span>
的置换 <span class="math inline">\(f\)</span> 为：<span
class="math inline">\(f=\pmatrix{1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8\\
6&amp;8&amp;5&amp;4&amp;1&amp;3&amp;2&amp;7}\)</span></p>
<p><span class="math inline">\(|C(f)|=4^3=64\)</span></p></li>
</ul></li>
<li><p><strong>定理14.3.1：</strong>设 <span
class="math inline">\(f\)</span> 是集合 <span
class="math inline">\(X\)</span> 的一个置换。假如用 <span
class="math inline">\(k\)</span> 种颜色对 <span
class="math inline">\(X\)</span> 的元素进行着色。令 <span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(X\)</span> 的所有着色的集合，则 <span
class="math inline">\(f\)</span> 保持 <span
class="math inline">\(C\)</span> 中着色不变的着色数为：<span
class="math inline">\(|C(f )|=k^{\#(f)}\)</span></p>
<ul>
<li>和循环因子分解中循环个数有关，而与每个循环的阶数无关</li>
<li><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230611221943614.png" alt="image-20230611221943614" style="zoom:33%;" /></li>
</ul></li>
<li><p><strong>置换的类型：</strong><span
class="math inline">\(f\)</span> 的循环因子分解中有 <span
class="math inline">\(e_1\)</span> 个 <span
class="math inline">\(1\)</span> - 循环，<span
class="math inline">\(e_2\)</span> 个 <span
class="math inline">\(2\)</span> - 循环，<span
class="math inline">\(\dots\)</span> <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(n\)</span> - 循环，满足 <span
class="math inline">\(1e_1+2e_2+...+ne_n=n\)</span>，称 <span
class="math inline">\(n\)</span> 元组 <span
class="math inline">\((e_1,e_2,...,e_n)\)</span> 是置换 <span
class="math inline">\(f\)</span> 的类型，记作 <span
class="math inline">\(type(f) = (e_1,e_2,...,e_n)\)</span></p></li>
<li><p><strong>置换的单项式：</strong>引入 <span
class="math inline">\(n\)</span> 个变量 <span
class="math inline">\(z_1,z_2,...,z_n\)</span>，<span
class="math inline">\(z_k\)</span> 对应 <span
class="math inline">\(k\)</span> 循环 <span class="math inline">\((k =
1,2, \dots, n)\)</span>，定义 <span class="math inline">\(f\)</span>
的单项式为 <span class="math inline">\(mon(f) =
z_1^{e_1}~z_2^{e_2}...z_n^{e_n}\)</span></p>
<ul>
<li>单项式的总次数 <span class="math inline">\(e_1+e_2+...+e_n =
\#(f)\)</span></li>
<li>按照类型的生成函数是 <span class="math inline">\(G\)</span>
中所有置换的单项式的和 <span class="math inline">\(\sum_{f\in
G}mon(f)=\sum_{f\in
G}{z_1}^{e_1}{z_2}^{e_2}...{z_n}^{e_n}\)</span>，系数对应类型为 <span
class="math inline">\((e_1,e_2, \dots, e_n)\)</span> 的置换的个数</li>
</ul></li>
<li><p><strong>置换的循环指数：</strong><span
class="math inline">\(P_G(z_1,z_2,...,z_n)=\dfrac{1}{|G|}\sum_{f\in
G}mon(f)=\dfrac{1}{|G|}\sum_{f\in
G}{z_1}^{e_1}{z_2}^{e_2}...{z_n}^{e_n}\)</span></p>
<ul>
<li><p>例：求二面体群 <span class="math inline">\(D_4\)</span>
的循环指数</p>
<p><img src="C:\Users\Lee\AppData\Roaming\Typora\typora-user-images\image-20230613133725520.png" alt="image-20230613133725520" style="zoom:33%;" /></p>
<p><span
class="math inline">\(P_{D_4}(z_1,z_2,z_3,z_4)=\dfrac{1}{8}(z_1^4+2z_4+3z_2^2+2z_1^2z_2)\)</span></p></li>
<li><p>用循环指数计算非等价着色数</p>
<ul>
<li><p>用 <span class="math inline">\(z_i = k\)</span> 代入 <span
class="math inline">\(P_G\)</span> 中</p></li>
<li><p><span
class="math inline">\(P_G(z_1,z_2,...,z_n)=\dfrac{1}{|G|}\sum_{f\in
G}mon(f)=\dfrac{1}{|G|}\sum_{f\in
G}{z_1}^{e_1}{z_2}^{e_2}...{z_n}^{e_n}\)</span></p></li>
<li><p><span class="math inline">\(|C(f)| =k^{\#(f)} = k^{e_1+e_2+ \dots
+e_n} = k^{e_1}k^{e_2} \dots k^{e_n}\)</span></p></li>
<li><p><span class="math inline">\(N(G,C)=\dfrac{1}{|G|}\sum_{f\in
G}|C(f)| =\dfrac{1}{|G|}\sum_{f\in G}k^{e_1}k^{e_2}\dots k^{e_n}
=P_G(k,k,...,k)\)</span>w</p></li>
</ul></li>
</ul></li>
<li><p><strong>定理14.3.2：</strong><span
class="math inline">\(N(G,C)=P_G(k,k,...,k)\)</span></p>
<ul>
<li><p>例：求用 <span class="math inline">\(k\)</span>
种颜色对正方形的顶点进行着色的非等价着色数</p>
<ul>
<li>图略</li>
<li><span
class="math inline">\(P_{D_4}(z_1,z_2,z_3,z_4)=\dfrac{1}{8}(z_1^4+2z_4+3z_2^2+2z_1^2z_2)\)</span></li>
<li><span
class="math inline">\(N(D_4,C)=P_{D_4}(k,k,k,k)=\dfrac{1}{8}(k^4+2k+3k^2+2k^2k)=\dfrac{1}{8}(k^4+2k^3+3k^2+2k)\)</span></li>
</ul></li>
</ul></li>
<li><p><strong>二元变量生成函数：</strong>非等价着色数等于 <span
class="math inline">\(P_G(r+b, r^2+b^2, \dots, r^n+b^n)\)</span> 中
<span class="math inline">\(r^pb^q\)</span> 的系数</p>
<ul>
<li><p>例：用 <span class="math inline">\(2\)</span>
种颜色对一个正方形的顶点着色，求它们的非等价着色数的生成函数</p>
<p>​ <span
class="math inline">\(P_{D_4}(z_1,z_2,z_3,z_4)=\dfrac{1}{8}(z_1^4+2z_4+3z_2^2+2z_1^2z_2)\)</span></p>
<p>​ <span class="math inline">\(\begin{aligned}
&amp;P_{D_4}(r+b,r^2+b^2,r^3+b^3,r^4+b^4) \\
&amp;=\dfrac{1}{8}((r+b)^4+2(r^4+b^4)+3(r^2+b^2)^2+2(r+b)^2(r^2+b^2)) \\
&amp;=r^4+r^3b+2r^2b^2+r b^3+b^4. \end{aligned}\)</span></p></li>
</ul></li>
<li><p><strong><span class="math inline">\(Pólya\)</span>
定理：</strong><span
class="math inline">\(\{u_1,u_2,\ldots,u_k\}\)</span> 是 <span
class="math inline">\(k\)</span> 种颜色的一个集合，则针对各颜色数目的
<span class="math inline">\(C\)</span>
的非等价着色数的生成函数是由循环</p>
<p>指数 <span class="math inline">\(P_G(z_1,z_2,...,z_n)\)</span>
通过做变量代换 <span
class="math inline">\(z_j=u_1^j+u_2^j+...+u_k^j(j=1,2,...,n)\)</span>
得到的表达式 $
P_G(u_1+u_2++u_k,u_1<sup>2+u_2</sup>2++u_k<sup>2,,u_1</sup>n+u_2<sup>n++u_k</sup>n)$</p>
<ul>
<li><p><span
class="math inline">\(u_1^{p_1}u_2^{p_2}...u_k^{p_k}\)</span> 的系数等于
<span class="math inline">\(X\)</span> 中的 <span
class="math inline">\(p_1\)</span> 个元素着色成 <span
class="math inline">\(u_1\)</span>，<span
class="math inline">\(p_2\)</span> 个元素着色成 <span
class="math inline">\(u_2\)</span>，<span
class="math inline">\(\dots\)</span>，<span
class="math inline">\(p_k\)</span> 个元素着色成 <span
class="math inline">\(u_k\)</span> 的非等价的着色数</p></li>
<li><p>例：用 <span class="math inline">\(3\)</span>
种颜色对一个正方形的顶点着色，求它们的非等价着色数的生成函数</p>
<p>​ <span
class="math inline">\(P_{D_4}(z_1,z_2,z_3,z_4)=\dfrac{1}{8}(z_1^4+2z_4+3z_2^2+2z_1^2z_2)\)</span></p>
<p>​ <span class="math inline">\(\begin{aligned}
&amp;P_{D_4}(r+b+g,r^2+b^2+b^2,r^3+b^3+g^3,r^4+b^4+g^4) \\
&amp;=\dfrac{1}{8}((r+b+g)^4+2(r^4+b^4+g^4)+3(r^2+b^2+g^2)^2+2(r+b+g)^2(r^2+b^2+g^2))
\\ \end{aligned}\)</span></p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Mathematics</category>
        <category>S4</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Combinatorics</tag>
      </tags>
  </entry>
</search>
